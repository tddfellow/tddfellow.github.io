<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Test-driven-development | That TDD Fellow | Tech Blog | Screencasts]]></title>
  <link href="http://www.tddfellow.com/blog/categories/test-driven-development/atom.xml" rel="self"/>
  <link href="http://www.tddfellow.com/"/>
  <updated>2016-09-30T23:14:37+02:00</updated>
  <id>http://www.tddfellow.com/</id>
  <author>
    <name><![CDATA[Oleksii Fedorov (waterlink)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Build Your Own Testing Framework. Part 4]]></title>
    <link href="http://www.tddfellow.com/blog/2016/09/17/build-your-own-testing-framework-part-4/"/>
    <updated>2016-09-17T10:00:32+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/09/17/build-your-own-testing-framework-part-4</id>
    <content type="html"><![CDATA[<p>Welcome back to the new issue of &ldquo;Build Your Own Testing Framework&rdquo; series! As you might have noticed, currently, our testing framework only outputs failures and nothing else. It is impossible to know if it actually runs any tests when they all pass because there is no output. Today we will implement a simple reporter for our testing framework. It will report the name of the test suite and names of the tests that are being executed, for example:</p>

<pre><code>SpyTest
    testIsNotCalledInitially
    testAssertNotCalledFailsWhenWasCalled
    testIsCalledAfterBeingCalled
    testAssertCalledFailsWhenWasNotCalled
</code></pre>

<p>This article is the fourth one of the series &ldquo;Build Your Own Testing Framework&rdquo;, so make sure to stick around for next parts! All articles of these series can be found <a href="/blog/categories/build-your-own-testing-framework/">here</a>.</p>

<p>Shall we get started?</p>

<!--more-->


<h2>Render the name of the test suite</h2>

<p>So where should the name of the test suite come from? Probably it should be a test suite class name. Currently, all of them are anonymous classes and therefore don&rsquo;t have a name:</p>

<pre><code class="javascript">runTestSuite(function () {
  //         ^          ^
  //       - no name here -
  // ...
});
</code></pre>

<p>We would like all test suites to have that name, for example:</p>

<pre><code class="javascript">runTestSuite(function SpyTest() {
  //                 ^       ^
  //            - here is the name -
  // ...
});
</code></pre>

<p>We should write a test for this case:</p>

<ol>
<li>Create a test suite with the name</li>
<li>Run the test suite with function <code>runTestSuite</code></li>
<li>Assert that the test suite name is reported</li>
</ol>


<p>Let&rsquo;s try to write a test in a <code>RunTestSuiteTest.js</code> test suite for that:</p>

<pre><code class="javascript">this.testItOutputsNameOfTheTest = function () {
  runTestSuite(function TestSuiteName(t) {});

  // TODO: assert that the test suite name is reported
};
</code></pre>

<p>Now it is problematic: how are we going to assert that something is reported? Should we replace <code>console.log(message)</code> or <code>process.stdout.write(message)</code> with our own implementation, so that we can test it?:</p>

<pre><code class="javascript">var logged = "";
var oldConsoleLog = console.log;

console.log = function (message) {
  logged = logged + message + "\n";
};
</code></pre>

<p>And then we should be able to assert with: <code>t.assertTrue(logged.indexOf("TestSuiteName") &gt;= 0)</code>. Finally we will need to restore the old <code>console.log</code> function:</p>

<pre><code class="javascript">this.testItOutputsNameOfTheTest = function () {
  var logged = "";
  var oldConsoleLog = console.log;

  console.log = function (message) {
    logged = logged + message + "\n";
  };

  runTestSuite(function TestSuiteName(t) {});

  t.assertTrue(logged.indexOf("TestSuiteName" &gt;= 0));

  console.log = oldConsoleLog;
};
</code></pre>

<p>While this code works, it has multitude of problems:</p>

<ul>
<li>If the test fails then <code>oldConsoleLog</code> function is not restored;</li>
<li>It has too much setup (which we could extract as a function);</li>
<li>It has teardown (which would be nice to avoid if we could);</li>
<li>It is hard to read because from 8 lines of code only 2 are delivering the core intent;</li>
<li>And it is testing how exactly test suite name is being reported, which is basically a View-like concern.</li>
</ul>


<p>And fixing the last problem will actually fix everything else because this problem causes others. We can fix it by introducing some sort of <code>Reporter</code> type, that can respond to <code>reportTestSuite(name)</code> message:</p>

<pre><code class="javascript">this.testItOutputsNameOfTheTest = function () {
  runTestSuite(function TestSuiteName(t) {
  }, {reporter: reporter});

  t.assertTrue(reporter.hasReportedTestSuite("TestSuiteName"));
  // or even better:
  reporter.assertHasReportedTestSuite("TestSuiteName");
};
</code></pre>

<p><code>reporter</code> in this case is some sort of test double. And what are they? - Find out here: <a href="/blog/2016/09/18/introducing-test-doubles/">Introducing Test Doubles</a>.</p>

<h2>Implementing the reporter spy</h2>

<p>So our <code>reporter</code> object in the test seems terribly like a Spy Double to me, let&rsquo;s test-drive it:</p>

<pre><code class="javascript">// test/ReporterSpyTest.js
var runTestSuite = require("../src/TestingFramework");
var ReporterSpy = require("./ReporterSpy");

runTestSuite(function ReporterSpy_BehaviorTest(t) {
  var reporter = new ReporterSpy(t);

  // Let's write our first test:
  this.testAssertHasReportedTestSuite_whenFailing = function () {
    t.assertThrow(
      "Expected test suite 'HelloWorld' to be reported",
      function () {
        reporter.assertHasReportedTestSuite("HelloWorld");
      }
    );
  };
});

// Error: Cannot find module './ReporterSpy'

// Create file test/ReporterSpy.js
</code></pre>

<p>Now we are getting the following error:</p>

<pre><code>//     var reporter = new ReporterSpy(t);
//                    ^
//
// TypeError: ReporterSpy is not a function
</code></pre>

<p>We need to create ReporterSpy object now:</p>

<pre><code class="javascript">module.exports = function ReporterSpy(assertions) {

};
</code></pre>

<p>Now we are getting:</p>

<pre><code>// Error: Expected to equal
//   Expected test suite 'HelloWorld' to be reported,
// but got:
//   reporter.assertHasReportedTestSuite is not a function
</code></pre>

<p>Now we need to create a function <code>assertHasReportedTestSuite(name)</code> for out <code>ReporterSpy</code>:</p>

<pre><code class="javascript">this.assertHasReportedTestSuite = function (expectedName) {
  assertions.assertTrue(
    false,
    "Expected test suite 'HelloWorld' to be reported"
  );
};
</code></pre>

<p>Next we need to make sure, that <code>expectedName</code> is actually present in the error message by triangulating with different name:</p>

<pre><code class="javascript">this.testAssertHasReportedTestSuite_whenFailing_withOtherName = function () {
  t.assertThrow("Expected test suite 'OtherTestSuite' to be reported", function () {
    reporter.assertHasReportedTestSuite("OtherTestSuite");
  });
};

// Error: Expected to equal
//   Expected test suite 'OtherTestSuite' to be reported,
// but got:
//   Expected test suite 'HelloWorld' to be reported

// And we need to change the respective string:
"Expected test suite '" + expectedName + "' to be reported"
</code></pre>

<p>Then we need to make sure that we do succeed when the message is received:</p>

<pre><code class="javascript">this.testAssertHasReportedTestSuite_whenSucceeding = function () {
  t.assertNotThrow(function () {
    reporter.reportTestSuite("HelloWorld");
    reporter.assertHasReportedTestSuite("HelloWorld");
  });
};

// Error:
//   Expected not to throw error,
// but thrown
//   'reporter.reportTestSuite is not a function'

// So we need to define this function in ReporterSpy:
this.reportTestSuite = function (name) {

};

// Error:
//   Expected not to throw error,
// but thrown
//   'Expected test suite 'HelloWorld' to be reported'

// Now we need to provide the simplest implementation we can,
// we can do that by introducing the boolean variable:

module.exports = function ReporterSpy(assertions) {
  // initially nothing is reported
  var hasReported = false;

  this.assertHasReportedTestSuite = function (expectedName) {
    assertions.assertTrue(
      // we should fail only when nothing was reported
      hasReported,
      "Expected test suite '" + expectedName + "' to be reported"
    );
  };

  this.reportTestSuite = function (name) {
    // and we mark it as reported when we do receive the message
    hasReported = true;
  };
};
</code></pre>

<p>And all our tests pass. Now, when the wrong name is getting reported we should still fail:</p>

<pre><code class="javascript">this.testAssertHasReportedTestSuite_whenReporting_andFailing = function () {
  t.assertThrow("Expected test suite 'HelloWorld' to be reported", function () {
    reporter.reportTestSuite("OtherTestSuite");
    reporter.assertHasReportedTestSuite("HelloWorld");
  });
};

// Error: Expected to throw an error,
// but nothing was thrown

// Now we need to actually store the name of reported test suite:

module.exports = function ReporterSpy(assertions) {
  // initially, we didn't receive any reports
  var testSuiteName = null;

  this.assertHasReportedTestSuite = function (expectedName) {
    assertions.assertTrue(
      // we fail only if received testSuiteName is not right
      testSuiteName === "HelloWorld",
      "Expected test suite '" + expectedName + "' to be reported"
    );
  };

  this.reportTestSuite = function (name) {
    // and we need to store the reported name
    testSuiteName = name;
  };
};
</code></pre>

<p>And all tests pass again. Although, we should notice this weird condition:</p>

<pre><code class="javascript">testSuiteName === "HelloWorld"
</code></pre>

<p>Looks like our current production code is not generic enough, it will work well only with the <code>expectedName</code> equal to <code>"HelloWorld"</code>. Let&rsquo;s fix that by triangulating over this parameter:</p>

<pre><code class="javascript">this.testAssertHasReportedTestSuite_whenReporting_andFailingWithDifferentName = function () {
  t.assertThrow("Expected test suite 'OtherTestSuite' to be reported", function () {
    reporter.reportTestSuite("HelloWorld");
    reporter.assertHasReportedTestSuite("OtherTestSuite");
  });
};

// Error: Expected to throw an error,
// but nothing was thrown

// And we should fix it by actually using the `expectedName`:

assertions.assertTrue(
  testSuiteName === expectedName,
  //               ^ fixed here ^
  "Expected test suite '" + expectedName + "' to be reported"
);
</code></pre>

<p>And all the tests pass. Now we can get back to our failing test for the <code>runTestSuite</code>:</p>

<h2>Implementing rendering of the name of the test suite</h2>

<pre><code class="javascript">this.testItOutputsNameOfTheTest = function () {
  runTestSuite(function TestSuiteName(t) {
  }, {reporter: reporter});

  reporter.assertHasReportedTestSuite("TestSuiteName");
};
</code></pre>

<p>To implement this, first we will need to accept <code>options</code> parameter with sane defaults:</p>

<pre><code class="javascript">function runTestSuite(testSuiteConstructor, options) {
  options = options || {};
  var reporter = options.reporter || new SimpleReporter();

  // ...
}

// We have to implement this, otherwise our test suite will fail
function SimpleReporter() {
    this.reportTestSuite = function (name) {
        process.stdout.write("\n" + name + "\n");
    };
}
</code></pre>

<p>After making the failing test pass and triangulating over the name of the test suite:</p>

<pre><code class="javascript">function runTestSuite(testSuiteConstructor, options) {
  options = options || {};
  var reporter = options.reporter || new SimpleReporter();

  reporter.reportTestSuite(testSuiteConstructor.name)

  // ...
}
</code></pre>

<p>And all tests pass now. Unfortunately, this is the output that we see now:</p>

<pre><code></code></pre>

<p>Yeah, empty lines. This is because <code>(function () {}).name</code> is equal to <code>""</code>. We need to give proper names to all our anonymous constructors for the test suites:</p>

<pre><code class="javascript">runTestSuite(function RunTestSuiteTest(t) { ... });
runTestSuite(function AssertEqualTest(t) { ... });
// .. and so on ..
</code></pre>

<p>And now we should see the correct output:</p>

<pre><code>AssertEqualTest

AssertNotEqualTest

AssertNotThrowTest

AssertThrowTest

AssertTrueTest

FizzBuzzKataTest

.. and so on ..
</code></pre>

<p>Great, now we would like to render the name of the executed test:</p>

<h2>Render the name of the executed test</h2>

<pre><code class="javascript">this.testItOutputsNameOfTheTest = function () {
  runTestSuite(function TestSuiteName(t) {
    this.testSomeTestName = function () {};
    this.testSomeOtherTestName = function () {};
  }, {reporter: reporter});

  reporter.assertHasReportedTestSuite("TestSuiteName");
  reporter.assertHasReportedTest("testSomeTestName");
  reporter.assertHasReportedTest("testSomeOtherTestName");
};
</code></pre>

<p>Of course this fails, because we need to implement <code>assertHasReportedTest(name)</code> now for our <code>ReporterSpy</code>. Let&rsquo;s test-drive it:</p>

<pre><code class="javascript">// test/ReporterSpyTest.js
this.testAssertHasReportedTest_whenFailing = function () {
  t.assertThrow("Expected test 'testName' to be reported", function () {
    reporter.assertHasReportedTest("testName");
  });
};

// Error: Expected to equal
//   Expected test 'testName' to be reported,
// but got:
//   reporter.assertHasReportedTest is not a function

// We need to define assertHasReportedTest(name) method:
this.assertHasReportedTest = function (expectedName) {

};

// Error: Expected to throw an error,
// but nothing was thrown

// We need to make it throw the expected error:
this.assertHasReportedTest = function (expectedName) {
  assertions.assertTrue(
    false,
    "Expected test 'testName' to be reported"
  );
};

// And the test passes. Message hard-codes `testName` -
// we should triangulate over it:

this.testAssertHasReportedTest_whenFailing_withDifferentName = function () {
  t.assertThrow("Expected test 'testDifferentName' to be reported", function () {
    reporter.assertHasReportedTest("testDifferentName");
  });
};

// Error: Expected to equal
//   Expected test 'testDifferentName' to be reported,
// but got:
//   Expected test 'testName' to be reported

// And to fix it:
"Expected test '" + expectedName + "' to be reported"

// Next test will force us to implement simple reportTest function:
this.testAssertHasReportedTest_whenSucceeding = function () {
  t.assertNotThrow(function () {
    reporter.reportTest("testName");
    reporter.assertHasReportedTest("testName");
  });
};

// Error: reporter.reportTest is not a function

// After fixing this and triangulating a bit, we get:

module.exports = function ReporterSpy(assertions) {
  var testName = null;
  // ...
  this.assertHasReportedTest = function (expectedName) {
    assertions.assertTrue(
      testName === expectedName,
      "Expected test '" + expectedName + "' to be reported"
    );
  };
  this.reportTest = function (name) {
    testName = name;
  };
}

// Finally we need ability to report multiple tests:

this.testAssertHasReportedTest_whenSucceeding_withMultipleReports = function () {
  t.assertNotThrow(function () {
    reporter.reportTest("testName");
    reporter.reportTest("testOtherName");
    reporter.assertHasReportedTest("testName");
  });
};

// Error: Expected not to throw error,
// but thrown 'Expected test 'testName' to be reported'

// And to implement this:
module.exports = function ReporterSpy(assertions) {
  // we will store all reported names,
  // initially no names are reported
  var testNames = [];
  // ...
  this.assertHasReportedTest = function (expectedName) {
    assertions.assertTrue(
      // check if expectedName was reported
      testNames.indexOf(expectedName) &gt;= 0,
      "Expected test '" + expectedName + "' to be reported"
    );
  };
  this.reportTest = function (name) {
    // store the reported test name
    testNames.push(name);
  };
}
</code></pre>

<p>Unfortunately, this does not pass our tests, because this test fails now:</p>

<pre><code class="javascript">this.testAssertHasReportedTest_whenReporting_andFailing = function () {
  t.assertThrow("Expected test 'testName' to be reported", function () {
    reporter.reportTest("testOtherName");
    reporter.assertHasReportedTest("testName");
  });
};
</code></pre>

<p>After an investigation, it becomes clear, that this happens because we can not re-use <code>reporter</code> variable defined at the higher level since all tests share the same <code>testSuite</code> object at the moment. We will have to move the creation of the <code>reporter</code> variable inside of each test:</p>

<pre><code class="javascript">this.testAssertHasReportedTest_whenReporting_andFailing = function () {
  var reporter = new ReporterSpy(t);
  // ...
};

this.testAssertHasReportedTest_whenReporting_andFailing_withOtherName = function () {
  var reporter = new ReporterSpy(t);
  // ...
};

// .. and so on ..
</code></pre>

<p>And this makes all our tests pass.</p>

<h2>Stateless tests</h2>

<p>This is quite a noticeable problem, that our users can be frustrated with, so we probably should make it easy on them and allow such variables to be fresh for every test. This can be achieved quite easy if we were to create a new <code>testSuite</code> for each test. Let&rsquo;s write a simple test to show the problem:</p>

<pre><code class="javascript">// test/StatelessTest.js
var runTestSuite = require("../src/TestingFramework");

runTestSuite(function StatelessTest(t) {
  var answer = 41;

  this.testItCanMutateVariable_andImmediatelyUseNewValue = function () {
    answer++;
    t.assertEqual(42, answer);
  };

  this.testItCanMutateVariableAgain_andGetTheSameResult = function () {
    answer++;
    t.assertEqual(42, answer);
  };
  // this fails as expected:
  // Error: Expected to equal 42, but got: 43
});
</code></pre>

<p>And now let&rsquo;s implement it by creating the <code>testSuite</code> for every test:</p>

<pre><code class="javascript">function runTestSuite(testSuiteConstructor, options) {
  options = options || {};
  var reporter = options.reporter || new SimpleReporter();

    reporter.reportTestSuite(testSuiteConstructor.name);

    var testSuitePrototype = createTestSuite(testSuiteConstructor);
    // ^ we change this from `testSuite` to `testSuitePrototype`  ^

  for (var testName in testSuitePrototype) {
    if (testName.match(/^test/)) {
      var testSuite = createTestSuite(testSuiteConstructor);
            // ^   and we create our testSuite every time here   ^
      testSuite[testName]();
    // ^  and run test on it ^
    }
  }
}

function createTestSuite(testSuiteConstructor) {
    return new testSuiteConstructor(assertions);
}
</code></pre>

<p>After doing this, we can move <code>var reporter = new ReporterSpy(t);</code> to the top level of the <code>ReporterSpyTest</code> suite again. And all the tests pass.</p>

<h2>Implementation of the rendering of the test name</h2>

<p>Finally, we need to make sure that the test suite, that we have written before will pass:</p>

<pre><code class="javascript">this.testItOutputsNameOfTheTest = function () {
    runTestSuite(function TestSuiteName(t) {
        this.testSomeTestName = function () {};
        this.testSomeOtherTestName = function () {};
    }, {reporter: reporter});

    reporter.assertHasReportedTestSuite("TestSuiteName");
    reporter.assertHasReportedTest("testSomeTestName");
    reporter.assertHasReportedTest("testSomeOtherTestName");
};
</code></pre>

<p>As expected it fails with <code>Error: Expected test 'testSomeTestName' to be reported</code>. After fixing it and applying triangulation once, we would end up with the following implementation:</p>

<pre><code class="javascript">// src/TestingFramework.js in runTestSuite function:
for (var testName in testSuitePrototype) {
    if (testName.match(/^test/)) {

        reporter.reportTest(testName);
// ^  here is our implementation  ^

        var testSuite = createTestSuite(testSuiteConstructor);
        testSuite[testName]();
    }
}

function SimpleReporter() {
    // ...
    // and we should not forget to implement it for real reporter
  this.reportTest = function (name) {
    process.stdout.write("\t" + name + "\n");
  };
}
</code></pre>

<p>Now, it seems that both <code>ReporterSpy</code> and <code>SimpleReporter</code> are implementing the same Duck type - <code>Reporter</code>. What Duck Type is? - find out here: <a href="/blog/2016/09/18/meet-duck-type/">Meet Duck Type</a>.</p>

<h2>Contract testing all Reporter duck types</h2>

<p>So we should test all our ducks that their public API don&rsquo;t get out of sync:</p>

<pre><code class="javascript">var TestingFramework = require("../src/TestingFramework");
var runTestSuite = TestingFramework;
var SimpleReporter = TestingFramework.SimpleReporter;

var ReporterSpy = require("./ReporterSpy");

const IMPLEMENTATIONS = [
    SimpleReporter,
    ReporterSpy
];

IMPLEMENTATIONS.forEach(function (ReporterImplementation) {
  runTestSuite(function (t) {
    var reporter = new ReporterImplementation();

    this.testDefines_reportTestSuite = function () {
      var reportTestSuite = reporter.reportTestSuite;
      t.assertEqual("function", typeof(reportTestSuite));
      t.assertEqual(1, reportTestSuite.length);
    };

    this.testDefines_reportTest = function () {
      var reportTest = reporter.reportTest;
      t.assertEqual("function", typeof(reportTest));
      t.assertEqual(1, reportTest.length);
    }
  });
});
</code></pre>

<p>All the tests pass. Unfortunately, the output regarding this test suite looks weird:</p>

<pre><code>
    testDefines_reportTestSuite
    testDefines_reportTest


    testDefines_reportTestSuite
    testDefines_reportTest
</code></pre>

<p>The test suite name is empty. I think we need an ability to define a custom and dynamic test suite name:</p>

<h2>Custom name for the test suite</h2>

<p>We can achieve this by allowing any test suite to define special hook method, that will return its custom name, like <code>testSuite.getTestSuiteName()</code>. Let&rsquo;s write a test for this:</p>

<pre><code class="javascript">this.testItCanHaveCustomNameOfTheTestSuite = function () {
  runTestSuite(function (t) {
    this.getTestSuiteName = function () {
      return "CustomNameOfTheTestSuite";
    };
  }, {reporter: reporter});

  reporter.assertHasReportedTestSuite("CustomNameOfTheTestSuite");
};
</code></pre>

<p>After implementing it and triangulating over the name once the code looks like this:</p>

<pre><code class="javascript">function runTestSuite(testSuiteConstructor, options) {
  options = options || {};
  var reporter = options.reporter || new SimpleReporter();

  var testSuitePrototype = createTestSuite(testSuiteConstructor);

  reporter.reportTestSuite(
    getTestSuiteName(testSuiteConstructor, testSuitePrototype)
// ^ this is the function that we introduced here to make it pass ^
  );

    for (var testName in testSuitePrototype) { ... }
}

function getTestSuiteName(testSuiteConstructor, testSuitePrototype) {
    if (typeof(testSuitePrototype.getTestSuiteName) !== "function") {
        return testSuiteConstructor.name;
    }

    return testSuitePrototype.getTestSuiteName();
}
</code></pre>

<p>Now, if we were to use this feature in our duck type tests:</p>

<pre><code class="javascript">IMPLEMENTATIONS.forEach(function (ReporterImplementation) {
  runTestSuite(function (t) {
    this.getTestSuiteName = function () {
      return ReporterImplementation.name + "_ReporterTest";
    };

    // ...
});
</code></pre>

<p>Then we are getting the proper output:</p>

<pre><code>SimpleReporter_ReporterTest
    testDefines_reportTestSuite
    testDefines_reportTest

ReporterSpy_ReporterTest
    testDefines_reportTestSuite
    testDefines_reportTest
</code></pre>

<h2>Bottom Line</h2>

<p>I think we are done with implementing our first simple reporter. Now we can see that the tests are actually executing and passing. The code can be found here: <a href="https://github.com/waterlink/BuildYourOwnTestingFrameworkPart4">https://github.com/waterlink/BuildYourOwnTestingFrameworkPart4</a></p>

<p>There is still a lot to go through. In a few next episodes we will:</p>

<ul>
<li>Make sure that first failure does not cause test suite to stop running;</li>
<li>Make sure the exit code is right;</li>
<li>Report OK and FAIL;</li>
<li>Output carefully formatted failures to the STDERR.</li>
</ul>


<p>Stay tuned!</p>

<h2>Thanks</h2>

<p>Thank you for reading, my dear reader. If you liked it, please share this article on social networks and follow me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you have any questions or feedback for me, don&rsquo;t hesitate to reach me out on Twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Stuck While Doing TDD. Part 3: Triangulation to the Rescue!]]></title>
    <link href="http://www.tddfellow.com/blog/2016/08/31/getting-stuck-while-doing-tdd-part-3-triangulation-to-the-rescue/"/>
    <updated>2016-08-31T02:35:32+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/08/31/getting-stuck-while-doing-tdd-part-3-triangulation-to-the-rescue</id>
    <content type="html"><![CDATA[<p>Welcome back to the &ldquo;Getting Stuck While Doing TDD&rdquo; series. Today we are going to learn the Golden Rule of TDD and how to not get stuck while doing TDD.</p>

<h2>TL;DR</h2>

<ul>
<li>&ldquo;As tests get more specific, production code gets more generic&rdquo;.</li>
<li><code>RED</code> is as important as other in Red-Green-Refactor cycle. If next test does not fail, it is either: already implemented, or has to wait until a later time (until it will fail).</li>
<li><p>At its core the Triangulation Technique has the following idea:</p>

<p>After implementing one business rule (with Red-Green-Refactor) make sure to find all &ldquo;weirdnesses&rdquo; or non-generalities in the production code and one-by-one eliminate them by writing a test, that proves such non-generality, and then making it pass while removing non-generality. This is the third cycle of TDD - Mini Cycle.</p></li>
</ul>


<!--more-->


<p>This is a series of articles:</p>

<ol>
<li><a href="/blog/2016/08/30/getting-stuck-while-doing-tdd-part-1-example/">Part 1: Example</a></li>
<li><a href="/blog/2016/08/31/getting-stuck-while-doing-tdd-part-2-buggy-code-and-forcing-our-way-through/">Part 2: Buggy Code and Forcing Our Way Through</a></li>
<li>Part 3: Triangulation to the Rescue! (reading this)</li>
</ol>


<p>Shall we get started?</p>

<h2>Specific/Generic Rule of TDD</h2>

<blockquote><p>As tests get more specific, production code gets more generic.</p></blockquote>

<p>When making the next failing test pass, our production code should also pass a whole class of similar tests. Best shown in the very simple example. The task at hand is to write the function <code>sum(a, b)</code> that will add two numbers. Let&rsquo;s see us a violation of the Specific/Generic rule:</p>

<pre><code class="ruby">expect(sum(2, 2)).to eq(4)
# =&gt; NoMethodError: undefined method `sum'

def sum(a, b); end
# =&gt; expected: 4, got: nil

def sum(a, b)
  4
end
# =&gt; PASS

expect(sum(2, 3)).to eq(5)
# =&gt; expected: 5, got: 4

def sum(a, b)
  if b == 2
    4
  else
    5
  end
end
# =&gt; PASS
</code></pre>

<p>The production code to make this last test pass is as specific as the failing test now. The test of the same class (where we change the value of the <code>b</code> parameter) will fail for it:</p>

<pre><code class="ruby">expect(sum(2, 42)).to eq(44)
# =&gt; expected: 44, got: 5
</code></pre>

<p>To follow the Specific/Generic rule we ought to make <code>4</code> into <code>2 + b</code> like that:</p>

<pre><code class="ruby">def sum(a, b)
  2 + b
end
# =&gt; PASS
</code></pre>

<p>This way, when we change <code>b</code> to any value it will still pass the test, aside from the fact, that we didn&rsquo;t do anything about <code>a</code>. This is because we still don&rsquo;t have any test showing us, that parameter <code>a</code> is important, like the following one:</p>

<pre><code class="ruby">expect(sum(4, 7)).to eq(11)
# =&gt; expected: 11, got: 9
</code></pre>

<p>Again we can make it pass in a very specific fashion by introducing specific <code>if</code> statement, or we could do it to pass the whole class of such tests:</p>

<pre><code class="ruby">def sum(a, b)
  a + b
end
# =&gt; PASS
</code></pre>

<p>Have you noticed, that from the test suite side we had to &ldquo;prove&rdquo; that some knowledge in the system is important and had to be used? This technique is called Triangulation.</p>

<h2>Triangulation Technique</h2>

<p>In the essence, Triangulation technique has a very simple idea at its core:</p>

<ol>
<li>Change certain important* knowledge in the system.</li>
<li>Assert that the production code behaves in an accordingly expected manner.</li>
</ol>


<p><em>* - important from the perspective of the system or unit under the test</em></p>

<h2>Red-Green-Refactor has to have all stages</h2>

<p>One Red-Green-Refactor cycle really has to have all stages in it. And I&rsquo;m not ranting right now about &ldquo;Refactor&rdquo; stage, that is a given. Rather, I insist on the &ldquo;Red&rdquo; stage - in TDD, when we write a new test, it has to fail. Writing tests that do not fail is another way to get ourselves stuck while doing TDD. One could ask: &ldquo;If I can&rsquo;t write this test because it does not fail, what should I do about the requirement it represents?&rdquo;, and the answer is rather simple - either this requirement is already implemented and tested by other tests, or we still need this test and we will get back to it later when it actually will fail.</p>

<p>As we can remember, in the first part of these series, we were going through an <code>OrderKindValidator</code> example, and we were writing multiple tests in a row, that were all expecting the same outcome and of course they didn&rsquo;t fail, because we had one line in our function that made them all pass. If we were to sprinkle some other tests, that do fail (like a test for a valid order kind), after making it pass, all of these tests will now be failing and therefore they are good candidates for our next test. Let&rsquo;s see it with our own eyes:</p>

<pre><code class="ruby">it_fails_with("Order kind can not be empty")
  .when_order_kind_is_absent
# =&gt; expected InvalidOrderError with "Order kind can not be empty",
# =&gt; got #&lt;NoMethodError:
# =&gt;      undefined method `validate' for #&lt;OrderKindValidator:0x000000020335c0&gt;&gt;

class OrderKindValidator
  def validate(order)
  end
end
# =&gt; expected InvalidOrderError with "Order kind can not be empty"
# =&gt; but nothing was raised

def validate(order)
  raise InvalidOrderError, "Order kind can not be empty"
end
# =&gt; PASS
</code></pre>

<p>Now is the point, where we have to choose our next test, and last time we have chosen the test with the same outcome and it did not go so well. Let&rsquo;s choose a test with different outcome, e.g.: when valid order kind is provided:</p>

<pre><code class="ruby">it_does_not_fail
  .when_order_kind_is(%w(private))
# =&gt; expected no Exception,
# =&gt; got #&lt;InvalidOrderError: Order kind can not be empty&gt;
</code></pre>

<p>Now, we have 2 options, to either check for <code>order[:kind] == %w(private)</code> or to check for <code>order[:kind]</code> being absent. It does not matter what we choose at this point, so let&rsquo;s go with the first one:</p>

<pre><code class="ruby">def validate(order)
  if order[:kind] == %w(private)
    return
  end

  raise InvalidOrderError, "Order kind can not be empty"
end
# =&gt; PASS
</code></pre>

<p>Now let&rsquo;s apply Triangulation technique. We should always ask ourselves the question: &ldquo;What is weird about this code?&rdquo; and &ldquo;What failing test should I write to point out this weirdness?&rdquo;. First weirdness we can spot is that the validator currently accepts only one order kind - <code>private</code>. According to our requirements it should also accept <code>corporate</code>:</p>

<pre><code class="ruby">it_does_not_fail
  .when_order_kind_is(%w(corporate))
# =&gt; expected no Exception,
# =&gt; got #&lt;InvalidOrderError: Order kind can not be empty&gt;

def validate(order)
  kinds = order[:kind]
  if kinds == %w(private) || kinds == %w(corporate)
    # ...
end
# =&gt; PASS
</code></pre>

<p>We also know, that our system should handle duplicate entries in <code>order[:kind]</code>:</p>

<pre><code class="ruby">it_does_not_fail
  .when_order_kind_is(%w(private private))
# =&gt; expected no Exception,
# =&gt; got #&lt;InvalidOrderError: Order kind can not be empty&gt;

def validate(order)
  kinds = order[:kind]
  if kinds.include?("private") || kinds == %w(corporate)
    # ...
end
# =&gt; expected InvalidOrderError with "Order kind can not be empty",
# =&gt; got #&lt;NoMethodError: undefined method `include?'
# =&gt; for nil:NilClass&gt;
</code></pre>

<p>Wow! We, of course, can check for <code>kinds</code> to not be <code>nil</code>, but I would rather listen to this test failure and put a check for <code>kinds</code> being absent (and this makes for our second check, that we could have chosen from):</p>

<pre><code class="ruby">def validate(order)
  kinds = order[:kind]

  if kinds.nil?
    raise InvalidOrderError, "Order kind can not be empty"
  end

  if kinds.include?("private") || kinds == %w(corporate)
    return
  end

  raise InvalidOrderError, "Order kind can not be empty"
end
# =&gt; PASS
</code></pre>

<p>So this passes all our tests. It may look weird, and this is exactly the pointer for us which test to write next to prove, that this weirdness is incorrect:</p>

<pre><code class="ruby">it_fails_with("Order kind can be one of: 'private', 'corporate', 'bundle'")
  .when_order_kind_is(%w(invalid))
# =&gt; expected InvalidOrderError
# =&gt; with "Order kind can be one of: 'private', 'corporate', 'bundle'",
# =&gt; got #&lt;InvalidOrderError: Order kind can not be empty&gt;

def validate(order)
  # ...

  raise InvalidOrderError,
    "Order kind can be one of: 'private', 'corporate', 'bundle'"
end
# =&gt; PASS
</code></pre>

<p>Production code starts looking not so clean and I think it is time to give things proper names:</p>

<pre><code class="ruby">class OrderKindValidator
  def validate(order)
    kinds = order[:kind]

    if empty?(kinds)
      fail_with("Order kind can not be empty")
    end

    unless valid?(kinds)
      fail_with("Order kind can be one of: 'private', 'corporate', 'bundle'")
    end
  end

  def valid?(kinds)
    kinds.include?("private") || kinds == %w(corporate)
  end

  def empty?(kinds)
    kinds.nil?
  end

  def fail_with(message)
    raise InvalidOrderError, message
  end
end
</code></pre>

<p>There is only one weirdness, that is left for triangulation in current production code, before we can move on to the next requirement - <code>private</code> can be duplicated while <code>corporate</code> can not:</p>

<pre><code class="ruby">it_does_not_fail
  .when_order_kind_is(%w(corporate corporate))
# =&gt; expected no Exception,
# =&gt; got #&lt;InvalidOrderError: Order kind can be one of: 'private', 'corporate', 'bundle'&gt;

def valid?(kinds)
  kinds.include?("private") ||
      kinds.include?("corporate")
end
# =&gt; PASS
</code></pre>

<p>Great, now we can safely go back to our empty order kind edge cases:</p>

<pre><code class="ruby">it_fails_with("Order kind can not be empty")
  .when_order_kind_is([])
# =&gt; expected InvalidOrderError with "Order kind can not be empty",
# =&gt; got #&lt;InvalidOrderError: Order kind can be one of: 'private', 'corporate', 'bundle'&gt;

def empty?(kinds)
  kinds.nil? ||
      kinds.empty?
end
# =&gt; PASS

it_fails_with("Order kind can not be empty")
  .when_order_kind_is([nil])
# =&gt; expected InvalidOrderError with "Order kind can not be empty",
# =&gt; got #&lt;InvalidOrderError: Order kind can be one of: 'private', 'corporate', 'bundle'&gt;

def empty?(kinds)
  kinds.nil? ||
      kinds.empty? ||
      kinds[0].nil?
end
# =&gt; PASS

it_fails_with("Order kind can not be empty")
  .when_order_kind_is([""])
# =&gt; expected InvalidOrderError with "Order kind can not be empty",
# =&gt; got #&lt;InvalidOrderError: Order kind can be one of: 'private', 'corporate', 'bundle'&gt;

def empty?(kinds)
  kinds.nil? ||
      kinds.empty? ||
      kinds[0].nil? ||
      kinds[0].empty?
end
# =&gt; PASS
</code></pre>

<p>And it is a good opportunity to eliminate some duplication:</p>

<pre><code class="ruby">def empty?(kinds)
  empty_value?(kinds) ||
      empty_value?(kinds[0])
end

def empty_value?(value)
  value.nil? || value.empty?
end
</code></pre>

<p>Now, it is a good time to triangulate, because we have a weirdness in our code: <code>kinds[0]</code>. To prove that this is too specific we can write another test:</p>

<pre><code class="ruby">it_fails_with("Order kind can not be empty")
  .when_order_kind_is(["private", ""])
# =&gt; expected InvalidOrderError with "Order kind can not be empty"
# =&gt; but nothing was raised

def empty?(kinds)
  empty_value?(kinds) ||
      kinds.any? { |kind| empty_value?(kind) }
end
# =&gt; PASS
</code></pre>

<p>Notice, how every single test that we have written was failing and how easy it was to make it pass. This suggests that we are probably moving in the right direction. Let&rsquo;s test our next requirement - we can combine <code>private</code> and <code>bundle</code>:</p>

<pre><code class="ruby">it_does_not_fail
  .when_order_kind_is(%w(private bundle))
# =&gt; PASS
</code></pre>

<p>Wait a minute. This is really bad. We should have a failing test here. This happened because we are checking only for the inclusion of <code>private</code> or <code>corporate</code> and we do not care about anything else in the <code>order[:kind]</code> array. We have to discard this test and try to go with failing version of the same business rule - invalid order kind can not be combined with <code>private</code>:</p>

<pre><code class="ruby">it_fails_with("Order kind can be one of: 'private', 'corporate', 'bundle'")
  .when_order_kind_is(%w(private invalid))
# =&gt; expected InvalidOrderError
# =&gt; with "Order kind can be one of: 'private', 'corporate', 'bundle'"
# =&gt; but nothing was raised

def valid?(kinds)
  return false if kinds[1] == "invalid"

  kinds.include?("private") ||
      kinds.include?("corporate")
end
# =&gt; PASS
</code></pre>

<p>While this works, it leads to two other weirdnesses: <code>kinds[1]</code> and <code>"invalid"</code>, let&rsquo;s the latter first:</p>

<pre><code class="ruby">it_fails_with("Order kind can be one of: 'private', 'corporate', 'bundle'")
  .when_order_kind_is(%w(private another_invalid))
# =&gt; expected InvalidOrderError
# =&gt; with "Order kind can be one of: 'private', 'corporate', 'bundle'"
# =&gt; but nothing was raised

def valid?(kinds)
  return false if kinds[1] &amp;&amp; kinds[1] != "private"

  kinds.include?("private") ||
      kinds.include?("corporate")
end
# =&gt; expected no Exception,
# =&gt; got #&lt;InvalidOrderError: Order kind can be one of: 'private', 'corporate', 'bundle'&gt;
# .. and more failures ..
</code></pre>

<p>Other tests fail now, from them it is possible to see, that second kind should be either <code>private</code> or <code>corporate</code>:</p>

<pre><code class="ruby">def valid?(kinds)
  return false if kinds[1] &amp;&amp;
      kinds[1] != "private" &amp;&amp;
      kinds[1] != "corporate"

  kinds.include?("private") ||
      kinds.include?("corporate")
end
# =&gt; PASS
</code></pre>

<p>This looks rather clunky, we should make it a bit cleaner:</p>

<pre><code class="ruby">ALLOWED_ORDER_KINDS = %w(private corporate)

def valid?(kinds)
  return false if kinds[1] &amp;&amp;
      !ALLOWED_ORDER_KINDS.include?(kinds[1])

  kinds.include?("private") ||
      kinds.include?("corporate")
end
</code></pre>

<p>Let&rsquo;s eliminate the other weirdness - <code>kinds[1]</code>, it probably should verify all kinds in the array:</p>

<pre><code class="ruby">it_fails_with("Order kind can be one of: 'private', 'corporate', 'bundle'")
  .when_order_kind_is(%w(invalid private))
# =&gt; expected InvalidOrderError
# =&gt; with "Order kind can be one of: 'private', 'corporate', 'bundle'"
# =&gt; but nothing was raised

def valid?(kinds)
  return false if kinds.any? { |kind|
    !ALLOWED_ORDER_KINDS.include?(kind)
  }

  kinds.include?("private") ||
      kinds.include?("corporate")
end
# =&gt; PASS
</code></pre>

<p>And now this can be greatly simplified by inverting the boolean logic:</p>

<pre><code class="ruby">def valid?(kinds)
  kinds.all? { |kind|
    ALLOWED_ORDER_KINDS.include?(kind)
  }
end
</code></pre>

<p>Now that we have dealt with all weirdnesses in our production code, let&rsquo;s get back to our requirement:</p>

<pre><code class="ruby">it_does_not_fail
  .when_order_kind_is(%w(private bundle))
# =&gt; expected no Exception,
# =&gt; got #&lt;InvalidOrderError: Order kind can be one of: 'private', 'corporate', 'bundle'&gt;
</code></pre>

<p>Wow! Now it fails exactly as it should. This means that it is now the right time for this test! Let&rsquo;s make it pass by adding <code>bundle</code> to the list of allowed order kinds:</p>

<pre><code class="ruby">ALLOWED_ORDER_KINDS = %w(private corporate bundle)
# =&gt; PASS
</code></pre>

<p>Nice! Our next requirement is about <code>bundle</code> not being used on its own, i.e.: either <code>private</code> or <code>corporate</code> is required:</p>

<pre><code class="ruby">it_fails_with("Order kind should be 'private' or 'corporate'")
  .when_order_kind_is(%w(bundle))
# =&gt; expected InvalidOrderError with "Order kind should be 'private' or 'corporate'"
# =&gt; but nothing was raised

def validate(order)
  # ...

  if kinds == %w(bundle)
    fail_with("Order kind should be 'private' or 'corporate'")
  end
end
# =&gt; PASS
</code></pre>

<p>And this is good enough, because that is really the only case, when this can happen until the list of allowed order kinds is extended by future business requirements. We should at least give this condition a proper name:</p>

<pre><code class="ruby">unless has_required?(kinds)
  fail_with("Order kind should be 'private' or 'corporate'")
end

# ...

def has_required?(kinds)
  kinds != %w(bundle)
end
</code></pre>

<p>Except, that we could provide duplicated <code>bundle</code>:</p>

<pre><code class="ruby">it_fails_with("Order kind should be 'private' or 'corporate'")
  .when_order_kind_is(%w(bundle bundle))
# =&gt; expected InvalidOrderError
# =&gt; with "Order kind should be 'private' or 'corporate'"
# =&gt; but nothing was raised

def has_required?(kinds)
  # Easy to fix if we de-duplicate it with #uniq:
  kinds.uniq != %w(bundle)
end
# =&gt; PASS
</code></pre>

<p>Now it is time to move on to the final requirement about conflicts between <code>private</code> and <code>corporate</code>:</p>

<pre><code class="ruby">it_fails_with("Order kind can not be 'private' and 'corporate' at the same time")
  .when_order_kind_is(%w(private corporate))
# =&gt; expected InvalidOrderError
# =&gt; with "Order kind can not be 'private' and 'corporate' at the same time"
# =&gt; but nothing was raised

def validate(order)
  # ...

  if kinds == %w(private corporate)
    fail_with("Order kind can not be 'private' and 'corporate' at the same time")
  end
end
# =&gt; PASS
</code></pre>

<p>Of course, <code>kinds == %w(private corporate)</code> can be considered too specific for production code, we should triangulate it:</p>

<pre><code class="ruby">it_fails_with("Order kind can not be 'private' and 'corporate' at the same time")
  .when_order_kind_is(%w(corporate private))
# =&gt; expected InvalidOrderError
# =&gt; with "Order kind can not be 'private' and 'corporate' at the same time"
# =&gt; but nothing was raised

if kinds.include?("private") &amp;&amp;
    kinds.include?("corporate")
  fail_with("Order kind can not be 'private' and 'corporate' at the same time")
end
# =&gt; PASS
</code></pre>

<p>And, finally, let&rsquo;s give this condition a proper name:</p>

<pre><code class="ruby">if has_conflicts?(kinds)
  fail_with("Order kind can not be 'private' and 'corporate' at the same time")
end

# ...

def has_conflicts?(kinds)
  kinds.include?("private") &amp;&amp;
    kinds.include?("corporate")
end
</code></pre>

<p>I believe we are done now. Source for this example can be found in <a href="https://github.com/waterlink/order_kind_validator/pull/3">an open pull request here</a>.</p>

<p>Let&rsquo;s recap how Triangulation technique worked for us here.</p>

<h2>Triangulation Technique in Depth</h2>

<p>The main goal of triangulation is to prove that the code is not general enough along some axis (class of tests) by writing a test and then making sure it passes. Effective application of the technique requires to prove and eliminate all such &ldquo;weirdnesses&rdquo; or non-generalities from the production code after each Red-Green-Refactor cycle for business requirements. This is, in fact, the 3rd cycle of Test-Driven-Development called Mini Cycle of TDD, it should be executed about every 10 minutes.</p>

<p>Another observation is that following this technique we are introducing only one small piece of knowledge into our production code, for example:</p>

<ul>
<li>When writing a test for next business requirement, we are introducing the fact that we need an <code>if</code> statement with a certain body (in this example it was a <code>raise error</code> statement). Since we can not introduce the <code>if</code> statement without a condition we need to put some condition there and we put a very specific condition on purpose since we know that it is tested and it is simple.</li>
<li>Next, we are proving that this condition is too specific by writing a test, and then making it pass with a more generic solution. This way we are introducing a tiny little bit more knowledge in our production code.</li>
<li>We are repeating this iterative process until the production code is generic enough for the current specification (test suite). And we start over. This is the Mini Cycle of TDD.</li>
</ul>


<h2>Bottom Line</h2>

<p>Today we have learned the Golden Rule of TDD - &ldquo;As tests get more specific, production code gets more generic&rdquo;, and we have learned the Triangulation Technique, that allows us to follow this rule in an incremental and confident way. Additionally, we have learned, that following Red-Green-Refactor strictly is important, and this includes even the <code>RED</code> stage of this cycle - when the test for business requirement does not fail, it is either: already implemented or it has to wait for later.</p>

<p>This is a series of articles:</p>

<ol>
<li><a href="/blog/2016/08/30/getting-stuck-while-doing-tdd-part-1-example/">Part 1: Example</a></li>
<li><a href="/blog/2016/08/31/getting-stuck-while-doing-tdd-part-2-buggy-code-and-forcing-our-way-through/">Part 2: Buggy Code and Forcing Our Way Through</a></li>
<li>Part 3: Triangulation to the Rescue! (reading this)</li>
</ol>


<p>You would not want to miss next articles on this tech blog, we still have a lot to talk about:</p>

<ul>
<li>Continuous Integration and Continuous Delivery - importance of not impeding others,</li>
<li>Open-Closed Principle - changing behavior by adding new code,</li>
<li>Mutational Testing, &ldquo;Build Your Own Testing Framework&rdquo; series, 4 Cycles of TDD, Test-Driven Development screencasts and so much more!</li>
</ul>


<h2>Thanks!</h2>

<p>Thank you for reading, my dear reader. If you liked it, please share this article on social networks and follow me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you have any questions or feedback for me, don&rsquo;t hesitate to reach me out on Twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Stuck While Doing TDD. Part 2: Buggy Code and Forcing Our Way Through]]></title>
    <link href="http://www.tddfellow.com/blog/2016/08/31/getting-stuck-while-doing-tdd-part-2-buggy-code-and-forcing-our-way-through/"/>
    <updated>2016-08-31T02:35:06+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/08/31/getting-stuck-while-doing-tdd-part-2-buggy-code-and-forcing-our-way-through</id>
    <content type="html"><![CDATA[<p>Welcome back to the &ldquo;Getting Stuck While Doing TDD&rdquo; series. Today we are going to see the results of getting stuck while doing TDD and scratch the surface of how to avoid this outcome.</p>

<p>Code examples today will be in Ruby programming language. The technique itself is, of course, language-agnostic.</p>

<h2>TL;DR</h2>

<ul>
<li>It is painful and difficult to force your way through when getting stuck in TDD.</li>
<li>It results in degraded guarantees from TDD (such as test coverage, semantical stability, and confidence).</li>
</ul>


<p>Ways to avoid this outcome:</p>

<ul>
<li>do not write tests that will not fail with the current production code</li>
<li>choose next test to write that will address particular detail about production code that is wrong or not general enough (Triangulation)</li>
</ul>


<p>Finally, do not forget to remove redundant tests if any.</p>

<!--more-->


<p>This is a series of articles:</p>

<ol>
<li><a href="/blog/2016/08/30/getting-stuck-while-doing-tdd-part-1-example/">Part 1: Example</a></li>
<li>Part 2: Buggy Code and Forcing Our Way Through (reading this)</li>
<li><a href="/blog/2016/08/31/getting-stuck-while-doing-tdd-part-3-triangulation-to-the-rescue/">Part 3: Triangulation to the Rescue!</a></li>
</ol>


<h2>Buggy if-riddled code</h2>

<p>Buggy <code>if</code>-riddled code is what we&rsquo;ve got. It is even not so easy to read. While we can refactor it to be more readable that won&rsquo;t change the presence of bugs, though. Let&rsquo;s still do it to understand what happens in this code better:</p>

<pre><code class="ruby">class OrderKindValidator
  def validate(order)
    kinds = order[:kind]

    validate_only_known(kinds)
    validate_has_required(kinds)
    validate_no_conflicting(kinds)
    validate_non_empty(kinds)
  end

  private

  def validate_non_empty(kinds)
    if empty?(kinds)
      fail_with("Order kind can not be empty")
    end
  end

  def validate_no_conflicting(kinds)
    if has_conflicting(kinds)
      fail_with("Order kind can not be 'private' and 'corporate' at the same time")
    end
  end

  def validate_has_required(kinds)
    if has_no_required(kinds)
      fail_with("Order kind should be 'private' or 'corporate'")
    end
  end

  def validate_only_known(kinds)
    if invalid?(kinds)
      fail_with("Order kind can be one of: 'private', 'corporate', 'bundle'")
    end
  end

  def empty?(kind)
    kind != ["private"] &amp;&amp; kind != ["corporate"] &amp;&amp;
        kind != %w(private bundle) &amp;&amp;
        kind != %w(corporate bundle)
  end

  def has_conflicting(kind)
    kind == %w(private corporate)
  end

  def has_no_required(kind)
    kind == ["bundle"]
  end

  def invalid?(kind)
    kind == ["invalid"]
  end

  def fail_with(message)
    raise InvalidOrderError.new(message)
  end
end
</code></pre>

<p>Structure of the class, actually, sounds just right, but conditions are not good:</p>

<pre><code class="ruby">def empty?(kind)
  kind != ["private"] &amp;&amp; kind != ["corporate"] &amp;&amp;
      kind != %w(private bundle) &amp;&amp;
      kind != %w(corporate bundle)
end
</code></pre>

<p>Really? It does not do what it says. At all. It basically just solves the problem very specifically to the tests. I can easily come up with a test that will break it:</p>

<pre><code class="ruby">it_fails_with("Order kind can be one of: 'private', 'corporate', 'bundle'")
    .when_order_kind_is ["almost anything"]

# Error: expected InvalidOrderError with
#    "Order kind can be one of: 'private', 'corporate', 'bundle'",
# got #&lt;InvalidOrderError: Order kind can not be empty&gt;

# or other test
it_does_not_fail.when_order_kind_is %w(corporate corporate)
</code></pre>

<pre><code class="ruby">def has_conflicting(kind)
  kind == %w(private corporate)
end
</code></pre>

<p>This at least does what it says. But only for one specific case, instead of general one. One test that I can come up with right away:</p>

<pre><code class="ruby">it_fails_with("Order kind can not be 'private' and 'corporate' at the same time")
    .when_order_kind_is %w(private corporate bundle)

# and another one:
it_fails_with("Order kind can not be 'private' and 'corporate' at the same time")
    .when_order_kind_is %w(corporate private)
</code></pre>

<pre><code class="ruby">def has_no_required(kind)
  kind == ["bundle"]
end
</code></pre>

<p>While this may work for our current requirements, it is really confusing for the reader. Method name says: &ldquo;has no required kind&rdquo; while method body checks if it is only <code>bundle</code>. And it does not work well with that edge case:</p>

<pre><code class="ruby">it_fails_with("Order kind should be 'private' or 'corporate'")
    .when_order_kind_is %w(bundle bundle)
</code></pre>

<p>While this case is quite unlikely, nothing in business rules forbid that and some other part of the system may as well duplicate <code>bundle</code> kind for some reason or it may be a user input mistake.</p>

<pre><code class="ruby">def invalid?(kind)
  kind == ["invalid"]
end
</code></pre>

<p>This method, indeed, checks that <code>kind</code> is <code>invalid</code>. Literally <code>"invalid"</code>. Which would mean, that all kinds except exactly <code>"invalid"</code> are allowed. This is not true according to our business rules. In fact, we have already written the failing test for this some moments ago:</p>

<pre><code class="ruby">it_fails_with("Order kind can be one of: 'private', 'corporate', 'bundle'")
    .when_order_kind_is ["almost anything"]
</code></pre>

<p>Let&rsquo;s comment out these failing tests and try to force-TDD our way through these bugs by uncommenting and fixing them one-by-one following Red-Green-Refactor loop:</p>

<h2>Forcing our way through</h2>

<p>So, let&rsquo;s uncomment our first failing test:</p>

<pre><code class="ruby">it_fails_with("Order kind can be one of: 'private', 'corporate', 'bundle'")
    .when_order_kind_is ["almost anything"]
</code></pre>

<p>We are expecting <code>validate_only_known</code> to fail with its message and that means <code>invalid?(kinds)</code> should return true. To make it return <code>true</code> in this case and preserve its old behavior we will need to remove <code>private</code>, <code>corporate</code> and <code>bundle</code> from <code>kinds</code> and check that it is not empty:</p>

<pre><code class="ruby">def invalid?(kinds)
  (kinds - %w(private corporate bundle)).any?
end
</code></pre>

<p>See how we had to write the whole thing in one go. There is no chance to write it incrementally because there will be a bunch of tests that fail. Wait! While it does not fail for any tests related to invalid kinds, it fails for all tests related to emptiness:</p>

<pre><code>OrderKindValidator
  fails with message "Order kind can not be empty"
    when order kind is [""] (FAILED - 1)
    when order kind is ["", ""] (FAILED - 2)
    when order kind is ["private", ""] (FAILED - 3)
    when order kind is absent (FAILED - 4)
    when order kind is nil (FAILED - 5)
</code></pre>

<p>So we need to change more production code to make this one tiny test pass. It looks like <code>validate_non_empty</code> is a culprit now - it is being called after <code>validate_only_known</code>. It should be the other way around:</p>

<pre><code class="ruby">def validate(order)
  kinds = order[:kind]

  validate_non_empty(kinds)
# ^ we moved this up here ^

  validate_only_known(kinds)
  validate_has_required(kinds)
  validate_no_conflicting(kinds)
end
</code></pre>

<p>Oh! Now a bunch of other tests fails:</p>

<pre><code>OrderKindValidator
  fails with message "Order kind should be 'private' or 'corporate'"
    when order kind is ["bundle"] (FAILED - 1)

  fails with a message "Order kind can not be 'private' and 'corporate' at the same time"
    when order kind is ["private", "corporate"] (FAILED - 4)

  fails with a message "Order kind can be one of: 'private', 'corporate', 'bundle'"
    when order kind is ["almost anything"] (FAILED - 2)
    when order kind is ["invalid"] (FAILED - 3)
</code></pre>

<p>From failure messages it is possible to guess, that the culprit is <code>empty?(kinds)</code> function that fails in too much cases now, such as: <code>["bundle"]</code>, <code>["private", "corporate"]</code>, <code>["almost anything"]</code> and <code>["invalid"]</code>. This is because it was not doing what it said it was:</p>

<pre><code class="ruby">def empty?(kinds)
  kinds != ["private"] &amp;&amp; kinds != ["corporate"] &amp;&amp;
      kinds != %w(private bundle) &amp;&amp;
      kinds != %w(corporate bundle)
end
</code></pre>

<p>And this is why it was hard to change the order of validations. We will have to completely rewrite this function. Let&rsquo;s start small and see which tests fail:</p>

<pre><code class="ruby">def empty?(kinds)
  false
end
</code></pre>

<p>The failures are:</p>

<pre><code>OrderKindValidator
  fails with message "Order kind can not be empty"
    when order kind is ["private", ""] (FAILED - 1)
    when order kind is [nil] (FAILED - 2)
    when order kind is ["", ""] (FAILED - 3)
    when order kind is nil (FAILED - 4)
    when order kind is [""] (FAILED - 5)
    when order kind is absent (FAILED - 6)
    when order kind is [nil, nil] (FAILED - 7)
    when order kind is ["private", nil] (FAILED - 8)
    when order kind is [] (FAILED - 9)
</code></pre>

<p>Good, only tests related directly to this case are failing. So one-by-one we can construct our condition while fixing these test failures:</p>

<ol>
<li><code>kinds.nil?</code></li>
<li><code>|| kinds.empty?</code></li>
<li><code>|| kinds[0].nil?</code>   (turned out to be redundant in the end)</li>
<li><code>|| kinds[0].empty?</code> (turned out to be redundant in the end)</li>
<li><code>|| kinds.any? { |k| k.nil? || k.empty? }</code></li>
</ol>


<p>After refactoring <code>empty?</code> the function now is looking this way:</p>

<pre><code class="ruby">def empty?(kinds)
  absent_or_empty?(kinds) ||
      kinds.any? { |kind| absent_or_empty?(kind) }
end

def absent_or_empty?(value)
  value.nil? || value.empty?
end
</code></pre>

<p>And all tests, finally, pass. It took a lot of effort and re-writing to get this one little test to pass. This is what we call &ldquo;Getting Stuck&rdquo; in TDD. There is always an order of tests that will lead to this result almost for any somewhat complex problem.</p>

<p>The code can be found in GitHub repository in <a href="https://github.com/waterlink/order_kind_validator/pull/2/files">an open pull request here</a>.</p>

<p>Almost guaranteed ways to get stuck in TDD:</p>

<ul>
<li>write tests that do not fail,</li>
<li>do not address weird results of &ldquo;simplest thing that could possibly work&rdquo; to make the test pass and moving on to the next business rule,</li>
<li>make production code a mirror of the tests and too specific, not general.</li>
</ul>


<p>And to not get stuck is to do the opposite:</p>

<ul>
<li>do not write the test that will not fail (wait until later, when it will fail), and</li>
<li>always first write the test that will point out next deficiency in the current production code (in TDD this is called Triangulation), and</li>
<li>while making some failing test pass, make sure that the change in production code covers not only this one specific test, rather, a whole class of tests (Golden Rule of TDD: As tests get more specific, production code gets more generic).</li>
</ul>


<h2>Bottom Line</h2>

<p>Today we have seen how bad the results of getting stuck while doing TDD can be. In the next article of these series, we will explore Golden Rule of TDD and the technique called Triangulation, that allows us to incrementally test-drive code in a way, that it will always be conforming to the Golden Rule of TDD and therefore will never get us stuck. Stay tuned!</p>

<p>This is a series of articles:</p>

<ol>
<li><a href="/blog/2016/08/30/getting-stuck-while-doing-tdd-part-1-example/">Part 1: Example</a></li>
<li>Part 2: Buggy Code and Forcing Our Way Through (reading this)</li>
<li><a href="/blog/2016/08/31/getting-stuck-while-doing-tdd-part-3-triangulation-to-the-rescue/">Part 3: Triangulation to the Rescue!</a></li>
</ol>


<p>You would not want to miss next articles on this tech blog, we still have a lot to talk about:</p>

<ul>
<li>Triangulation technique in Test-Driven Development - overlooking this technique might cause one fail at doing TDD (these series),</li>
<li>Continuous Integration and Continuous Delivery - importance of not impeding others,</li>
<li>Open-Closed Principle - changing behavior by adding new code,</li>
<li>Mutational Testing, &ldquo;Build Your Own Testing Framework&rdquo; series, Test-Driven Development screencasts and so much more!</li>
</ul>


<h2>Thanks!</h2>

<p>Thank you for reading, my dear reader. If you liked it, please share this article on social networks and follow me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you have any questions or feedback for me, don&rsquo;t hesitate to reach me out on Twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Stuck While Doing TDD. Part 1: Example]]></title>
    <link href="http://www.tddfellow.com/blog/2016/08/30/getting-stuck-while-doing-tdd-part-1-example/"/>
    <updated>2016-08-30T15:27:30+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/08/30/getting-stuck-while-doing-tdd-part-1-example</id>
    <content type="html"><![CDATA[<p>Following 3 rules of TDD sounds really simple at first. In practice, there is a moment when one has to implement the whole algorithm at once to make currently failing test pass. This is called &ldquo;getting stuck&rdquo; in TDD. In this article, we will explore how exactly this happens and how to prevent that.</p>

<p>Code examples today will be in Ruby programming language. The technique itself is, of course, language-agnostic.</p>

<h2>TL;DR</h2>

<p>&ldquo;Getting stuck&rdquo; happens for a couple of reasons:</p>

<ul>
<li>wrong order of tests</li>
<li>production code is not getting more general with each test</li>
</ul>


<!--more-->


<p>This is a series of articles:</p>

<ol>
<li>Part 1: Example (reading this)</li>
<li><a href="/blog/2016/08/31/getting-stuck-while-doing-tdd-part-2-buggy-code-and-forcing-our-way-through/">Part 2: Buggy Code and Forcing Our Way Through</a></li>
<li><a href="/blog/2016/08/31/getting-stuck-while-doing-tdd-part-3-triangulation-to-the-rescue/">Part 3: Triangulation to the Rescue!</a></li>
</ol>


<h2>&ldquo;Getting Stuck&rdquo; in TDD</h2>

<p>Usually &ldquo;Getting Stuck&rdquo; follows this pattern:</p>

<ul>
<li>write some test and implement it via &ldquo;simplest thing that might possibly work&rdquo;,</li>
<li>write another test and implement it again in a non-general manner,</li>
<li>write some more tests in that fashion, while never addressing the fact that production code now looks completely wrong from what it should probably be looking like,</li>
<li>write a new test, that forces us to completely rewrite production code in a complete algorithm just to make it pass.</li>
</ul>


<p>This last step usually takes minutes to hours depending on the complexity of the problem at hand. Additionally, the first few tests are basically wasted time since they did not produce any bits of knowledge in the production code that persisted in production code in the end. Even worse, chances are that the algorithm that we have just written is not fully covered by current tests, since we have written it in one go just to make current failing test pass - this is no longer correct TDD and can not guarantee high test coverage, and, therefore, can not guarantee high confidence anymore.</p>

<p>Let&rsquo;s go through a small example on how one can get stuck in TDD:</p>

<h2>Order Kind Validation - Getting Stuck</h2>

<p>Let&rsquo;s define the problem at hand first. We have some sort of order request as an input to our system and we need to validate that its kind is correct:</p>

<ul>
<li>valid order kinds: <code>private</code>, <code>corporate</code>, <code>bundle</code>,</li>
<li>order kinds can be combined,</li>
<li><code>private</code> and <code>corporate</code> order kinds can not be combined, otherwise <code>InvalidOrderError</code> with message <code>Order kind can not be 'private' and 'corporate' at the same time</code>,</li>
<li>either <code>private</code> or <code>corporate</code> should be always present, otherwise <code>InvalidOrderError</code> with message <code>Order kind should be 'private' or 'corporate'</code>,</li>
<li>if order kind is not in the above list, then we need to raise <code>InvalidOrderError</code> with message <code>Order kind can be one of: 'private', 'corporate', 'bundle'</code>,</li>
<li>if order kind is not present or an empty string, then we need to raise <code>InvalidOrderError</code> with message <code>Order kind can not be empty</code>.</li>
</ul>


<p>This is a fairly simple problem and it is easy to get stuck while doing TDD here. So let&rsquo;s write our first test: &ldquo;When order has no order_kind, then we should get InvalidOrderError with message &lsquo;Order kind can not be empty&rsquo;&rdquo;:</p>

<pre><code class="ruby">RSpec.describe OrderKindValidator do
  it "fails with a message about order kind being empty when it is absent" do
    validator = OrderKindValidator.new

    expect { validator.validate({ items: 42 }) }
        .to raise_error(InvalidOrderError, "Order kind can not be empty")
  end
end
</code></pre>

<p>And the simplest implementation possible:</p>

<pre><code class="ruby">class OrderKindValidator
  def validate(order)
    raise InvalidOrderError.new("Order kind can not be empty")
  end
end

class InvalidOrderError &lt; StandardError
end
</code></pre>

<p>Next test is our next simplest edge case - when kind&rsquo;s value is <code>nil</code>:</p>

<pre><code class="ruby">it "fails with a message about order kind being empty when it is nil" do
  validator = OrderKindValidator.new

  expect { validator.validate({items: 42, kind: nil }) }
      .to raise_error(InvalidOrderError, "Order kind can not be empty")
end
</code></pre>

<p>It does not fail at all, so we don&rsquo;t have any reason to change the production code. We can already spot a little duplication - <code>validator</code> variable. Let&rsquo;s extract it as a named subject of the test suite:</p>

<pre><code class="ruby">subject(:validator) { OrderKindValidator.new }
</code></pre>

<p>And <code>OrderKindValidator</code> can be replaced with <code>described_class</code> (RSpec feature), so that we will not have to change too much in case we wanted to change name of the class:</p>

<pre><code class="ruby">subject(:validator) { described_class.new }
</code></pre>

<p>Next simplest edge case - when kind is an empty array:</p>

<pre><code class="ruby">it "fails with a message about order kind being empty when it has zero elements" do
  expect { validator.validate({items: 42, kind: [] }) }
      .to raise_error(InvalidOrderError, "Order kind can not be empty")
end
</code></pre>

<p>I believe I am spotting annoying pattern now:</p>

<pre><code class="ruby">it "fails with message MESSAGE when it is KIND_CASE" do
  expect { validator.validate({items: 42, kind: KIND_VALUE}) }
    .to raise_error(InvalidOrderError, MESSAGE)
end
</code></pre>

<p>It would be really nice to write it in this fashion:</p>

<pre><code class="ruby">it_fails_with("Order kind can not be empty").when_order_kind_is_absent
it_fails_with("Order kind can not be empty").when_order_kind_is nil
it_fails_with("Order kind can not be empty").when_order_kind_is []
</code></pre>

<p>And as another duplication piles up:</p>

<pre><code class="ruby">it_fails_with_order_kind_not_empty = it_fails_with("Order kind can not be empty")

it_fails_with_order_kind_not_empty.when_order_kind_is_absent
it_fails_with_order_kind_not_empty.when_order_kind_is nil
it_fails_with_order_kind_not_empty.when_order_kind_is []
</code></pre>

<p>Now the next tests look very easy and simple:</p>

<pre><code class="ruby">it_fails_with_order_kind_not_empty.when_order_kind_is [nil]
it_fails_with_order_kind_not_empty.when_order_kind_is [""]
it_fails_with_order_kind_not_empty.when_order_kind_is [nil, nil]
it_fails_with_order_kind_not_empty.when_order_kind_is ["", ""]
it_fails_with_order_kind_not_empty.when_order_kind_is ["private", ""]
it_fails_with_order_kind_not_empty.when_order_kind_is ["private", nil]
</code></pre>

<p>And they all pass right from the go. The implementation for the <code>it_fails_with</code> is looking like this:</p>

<pre><code class="ruby">RSpec.describe OrderKindValidator do
  class ItFailsWith
    def initialize(spec, expected_message)
      @spec = spec
      @expected_message = expected_message
    end

    def when_order_kind_is_absent
      expect_failure("absent", {items: 42})
    end

    def when_order_kind_is(value)
      expect_failure(value.inspect, {items: 42, kind: value})
    end

    private

    def expect_failure(feature, order, expected_message = @expected_message)
      @spec.it("fails with message #{expected_message.inspect} when order kind is #{feature}") do
        expect { validator.validate(order) }
            .to raise_error(InvalidOrderError, expected_message)
      end
    end
  end

  def self.it_fails_with(message)
    ItFailsWith.new(self, message)
  end
end
</code></pre>

<p>So, let&rsquo;s write our next edge case - when order kind is invalid:</p>

<pre><code class="ruby">it_fails_with("Order kind can be one of: 'private', 'corporate', 'bundle'")
    .when_order_kind_is ["invalid"]
</code></pre>

<p>Pretty neat! And oh, it fails:</p>

<pre><code>expected InvalidOrderError with
  "Order kind can be one of: 'private', 'corporate', 'bundle'",
got #&lt;InvalidOrderError: Order kind can not be empty&gt;
</code></pre>

<p>And the fix:</p>

<pre><code class="ruby">def validate(order)
  if order[:kind] == ["invalid"]
    raise InvalidOrderError.new(
        "Order kind can be one of: 'private', 'corporate', 'bundle'"
    )
  end

  raise InvalidOrderError.new("Order kind can not be empty")
end
</code></pre>

<p>Let&rsquo;s write our next test - when order kind is <code>private</code>:</p>

<pre><code class="ruby">it_does_not_fail.when_order_kind_is ["private"]
</code></pre>

<p>This fails as expected with <code>expected no Exception, got #&lt;InvalidOrderError: Order kind can not be empty&gt;</code>. And to make it pass we need to wrap second <code>raise</code> statement in the <code>if</code> condition:</p>

<pre><code class="ruby">if order[:kind] != ["private"]
  raise InvalidOrderError.new("Order kind can not be empty")
end
</code></pre>

<p>The implementation for <code>it_does_not_fail</code> looks like that:</p>

<pre><code class="ruby">class ItDoesNotFail
  def initialize(spec)
    @spec = spec
  end

  def when_order_kind_is(value)
    @spec.it("does not fail when order kind is #{value.inspect}") do
      expect { validator.validate({items: 42, kind: value}) }
        .not_to raise_error
    end
  end
end

def self.it_does_not_fail
  ItDoesNotFail.new(self)
end
</code></pre>

<p>Let&rsquo;s write our next test:</p>

<pre><code class="ruby">it_does_not_fail.when_order_kind_is ["corporate"]
</code></pre>

<p>And it fails with the expected error: <code>expected no Exception, got #&lt;InvalidOrderError: Order kind can not be empty&gt;</code>. The fix is to amend our <code>if</code> condition with that case:</p>

<pre><code class="ruby">if order[:kind] != ["private"] &amp;&amp; order[:kind] != ["corporate"]
                                # ^  we have added this case  ^
  raise InvalidOrderError.new("Order kind can not be empty")
end
</code></pre>

<p>And the tests pass. Our next business rule is that one of <code>private</code> and <code>corporate</code> should be always present:</p>

<pre><code class="ruby">it_fails_with("Order kind should be 'private' or 'corporate'")
    .when_order_kind_is ["bundle"]
</code></pre>

<p>As expected the test fails:</p>

<pre><code>expected InvalidOrderError with
  "Order kind should be 'private' or 'corporate'",
got #&lt;InvalidOrderError: Order kind can not be empty&gt;
</code></pre>

<p>And to fix it we just need to sprinkle another <code>if</code> statement in the middle of the function:</p>

<pre><code class="ruby">if order[:kind] == ["bundle"]
  raise InvalidOrderError.new("Order kind should be 'private' or 'corporate'")
end
</code></pre>

<p>As expected, the test passes. Now we should test the next business rule - order can not be of <code>private</code> and <code>corporate</code> kind at the same time:</p>

<pre><code class="ruby">it_fails_with("Order kind can not be 'private' and 'corporate' at the same time")
    .when_order_kind_is %w(private corporate)
</code></pre>

<p>This, as expected, fails with error message:</p>

<pre><code>expected InvalidOrderError with
  "Order kind can not be 'private' and 'corporate' at the same time",
got #&lt;InvalidOrderError: Order kind can not be empty&gt;
</code></pre>

<p>And easiest way to fix that is to add another <code>if</code> statement:</p>

<pre><code class="ruby">if order[:kind] == %w(private corporate)
  raise InvalidOrderError.new(
      "Order kind can not be 'private' and 'corporate' at the same time"
  )
end
</code></pre>

<p>And it passes. Let&rsquo;s test that we can combine <code>private</code> or <code>corporate</code> with <code>bundle</code> order kinds:</p>

<pre><code class="ruby">it_does_not_fail.when_order_kind_is %w(private bundle)
</code></pre>

<p>And it fails with error: <code>expected no Exception, got #&lt;InvalidOrderError: Order kind can not be empty&gt;</code>. To fix this we will have to amend our last <code>if</code> condition in the function even more:</p>

<pre><code class="ruby">if order[:kind] != ["private"] &amp;&amp; order[:kind] != ["corporate"] &amp;&amp;
    order[:kind] != %w(private bundle)
  # ^    this is our new condition    ^
  raise InvalidOrderError.new("Order kind can not be empty")
end
</code></pre>

<p>And the test passes. Let&rsquo;s refactor the code a bit:</p>

<ul>
<li>First, we should extract <code>order[:kind]</code> duplication to a local variable <code>kind</code></li>
<li>Extract common parts of <code>raise</code> statement to the private method</li>
</ul>


<p>After this, <code>OrderKindValidator</code> will look a bit cleaner:</p>

<pre><code class="ruby">class OrderKindValidator
  def validate(order)
    kind = order[:kind]

    if kind == ["invalid"]
      fail_with("Order kind can be one of: 'private', 'corporate', 'bundle'")
    end

    if kind == ["bundle"]
      fail_with("Order kind should be 'private' or 'corporate'")
    end

    if kind == %w(private corporate)
      fail_with("Order kind can not be 'private' and 'corporate' at the same time")
    end

    if kind != ["private"] &amp;&amp; kind != ["corporate"] &amp;&amp;
        kind != %w(private bundle)
      fail_with("Order kind can not be empty")
    end
  end

  private

  def fail_with(message)
    raise InvalidOrderError.new(message)
  end
end
</code></pre>

<p>Let&rsquo;s write our next test for the same business rule (now a corporate bundle):</p>

<pre><code class="ruby">it_does_not_fail.when_order_kind_is %w(corporate bundle)
</code></pre>

<p>And it fails with error: <code>expected no Exception, got #&lt;InvalidOrderError: Order kind can not be empty&gt;</code>. To fix this we need to add <code>&amp;&amp; kind != %w(corporate bundle)</code> to our last <code>if</code> condition again.</p>

<p>The code can be found in GitHub repository in <a href="https://github.com/waterlink/order_kind_validator/pull/1/files">an open pull request here</a>.</p>

<p>Now it seems that we have implemented all the business rules (we have all tests for them). Or did we?</p>

<h2>Bottom Line</h2>

<p>Buggy <code>if</code>-riddled code is what we&rsquo;ve got. We will see why in the next part of &ldquo;Getting Stuck While Doing TDD&rdquo; series. Stay tuned!</p>

<p>This is a series of articles:</p>

<ol>
<li>Part 1: Example (reading this)</li>
<li><a href="/blog/2016/08/31/getting-stuck-while-doing-tdd-part-2-buggy-code-and-forcing-our-way-through/">Part 2: Buggy Code and Forcing Our Way Through</a></li>
<li><a href="/blog/2016/08/31/getting-stuck-while-doing-tdd-part-3-triangulation-to-the-rescue/">Part 3: Triangulation to the Rescue!</a></li>
</ol>


<p>Today we have implemented our not-so-complex problem at hand while following 3 rules of TDD. The result was not of the best quality and we will take a look why in further articles of these series. You would not want to miss next articles on this tech blog, we still have a lot to talk about:</p>

<ul>
<li>Triangulation technique in Test-Driven Development - overlooking this technique might cause one fail at doing TDD (these series),</li>
<li>Continuous Integration and Continuous Delivery - importance of not impeding others,</li>
<li>Open-Closed Principle - changing behavior by adding new code,</li>
<li>Mutational Testing, &ldquo;Build Your Own Testing Framework&rdquo; series, Test-Driven Development screencasts and so much more!</li>
</ul>


<h2>Thanks!</h2>

<p>Thank you for reading, my dear reader. If you liked it, please share this article on social networks and follow me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you have any questions or feedback for me, don&rsquo;t hesitate to reach me out on Twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Build Your Own Testing Framework. Part 3]]></title>
    <link href="http://www.tddfellow.com/blog/2016/08/14/build-your-own-testing-framework-part-3/"/>
    <updated>2016-08-14T13:55:17+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/08/14/build-your-own-testing-framework-part-3</id>
    <content type="html"><![CDATA[<p>Welcome back to the new issue of &ldquo;Build Your Own Testing Framework&rdquo; series! Today we are going to unit-test <code>runTestSuite</code> function of our testing framework. Currently, only its happy path is implicitly tested via every test of the system. Additionally, this function&rsquo;s unhappy paths are, in fact, untestable at the moment.</p>

<p>This article is the third one of the series &ldquo;Build Your Own Testing Framework&rdquo;, so make sure to stick around for next parts! All articles of these series can be found <a href="/blog/categories/build-your-own-testing-framework/">here</a>.</p>

<p>Shall we get started?</p>

<!--more-->


<h2>Testing existing code</h2>

<p>Let&rsquo;s take another look at the <code>runTestSuite</code> function:</p>

<pre><code class="javascript">function runTestSuite(testSuiteConstructor) {
    var testSuite = new testSuiteConstructor(assertions);

    for (var testName in testSuite) {
        if (testName.match(/^test/)) {
            testSuite[testName]();
        }
    }
}
</code></pre>

<p>This function currently:</p>

<ol>
<li>Creates a new test suite from the passed in function-constructor.</li>
<li>Finds every method that starts with the string <code>test</code>.</li>
<li>And calls every such method.</li>
</ol>


<h3>Test that it calls at least one test method</h3>

<pre><code class="javascript">var runTestSuite = require("../src/TestingFramework");

runTestSuite(function (t) {
    this.testItCallsOneTestMethod = function () {
        var called = false;

        runTestSuite(function (t) {
            this.testSomeInterestingFunction = function () {
                called = true;
            };
        });

        t.assertTrue(called);
    };
});
</code></pre>

<p>And this test passes. To be sure, that we are actually testing anything, let&rsquo;s make sure that <code>testSomeInterestingFunction</code> is not being called:</p>

<pre><code class="javascript">if (testName.match(/^test/) &amp;&amp;
    testName != "testSomeInterestingFunction") {
//  ^   make sure our method is not called  ^
    testSuite[testName]();
}
</code></pre>

<p>This fails as expected: <code>Error: Expected to be true, but got false</code>. Undoing this mutation causes the test to pass again. This is good, since we have seen this test fail when we expect it to fail. This proves the semantic stability of our test.</p>

<p>So, what will happen if we replace the whole <code>if</code> condition with <code>true</code>?</p>

<pre><code class="javascript">if (true) {
    testSuite[testName]();
}
</code></pre>

<p>As expected, all tests will pass. Seems that we need to add a new test here:</p>

<h3>Test that it does not call non-test methods</h3>

<pre><code class="javascript">this.testItDoesNotCallMethodThatDoesNotStartWithTestPrefix = function () {
    var called = false;

    runTestSuite(function (t) {
        this.someFunction = function () {
            called = true;
        };
    });

    t.assertTrue(!called);
};
</code></pre>

<p>And this fails as expected. This makes our test suite semantically stable against this sort of mutation. Undoing the mutation should make the test suite pass. And it does.</p>

<p>There is another surviving mutant that I can come up with:</p>

<pre><code class="javascript">for (var testName in testSuite) {
    if (testName.match(/^test/)) {
        testSuite[testName]();
    }
    break; // &lt;- surviving mutant
}
</code></pre>

<p>This means, that only first function will only ever run. Since all our tests are currently verifying that only one function is called or not we will need another test to defeat this mutant:</p>

<h3>Test that it calls all provided test methods</h3>

<pre><code class="javascript">this.testItCallsAllTestMethods = function () {
    var calledOne = false;
    var calledTwo = false;
    var calledThree = false;

    runTestSuite(function (t) {
        this.testFunctionOne = function () {
            calledOne = true;
        };

        this.testFunctionTwo = function () {
            calledTwo = true;
        };

        this.testFunctionThree = function () {
            calledThree = true;
        };
    });

    t.assertTrue(calledOne);
    t.assertTrue(calledTwo);
    t.assertTrue(calledThree);
};
</code></pre>

<p>Careful here: <code>testItCallsAllTestMethods</code> has to be the first test in the test suite for it to be ever called with the current mutation. As expected this test fails and undoing the mutation makes it pass.</p>

<p><code>testItCallsAllTestMethods</code> is superior to the <code>testItCallsOneTestMethod</code>, so we can remove the latter.</p>

<p>The amount of duplication in this code does not make me happy. Seems like we are missing the ability to verify if a certain function was called or not. Let&rsquo;s try to extract this abstraction:</p>

<pre><code class="javascript">function spy() {
    function that() {
        that.called = true;
    }

    that.called = false;

    return that;
};
</code></pre>

<p>And then the usage would look like that:</p>

<pre><code class="javascript">this.testItCallsAllTestMethods = function () {
    var spyOne = spy();
    var spyTwo = spy();
    var spyThree = spy();

    runTestSuite(function (t) {
        this.testFunctionOne = spyOne;
        this.testFunctionTwo = spyTwo;
        this.testFunctionThree = spyThree;
    });

    t.assertTrue(spyOne.called);
    t.assertTrue(spyTwo.called);
    t.assertTrue(spyThree.called);
};

this.testItDoesNotCallMethodThatDoesNotStartWithTestPrefix = function () {
    var aSpy = spy();

    runTestSuite(function (t) {
        this.someFunction = aSpy;
    });

    t.assertTrue(!aSpy.called);
};
</code></pre>

<h2>Testing <code>assertions.spy()</code></h2>

<p>It seems, that having <code>t.spy()</code> available for the users of our testing framework might be very useful! Let&rsquo;s test-drive it:</p>

<pre><code class="javascript">// Initially, it should not be called
this.testIsNotCalledInitially = function () {
    t.assertTrue(!t.spy().called);
};

// TypeError: t.spy is not a function

// Implementation in `assertions object`:
spy: function () {
    return {
        called: false
    }
}

// Let's check that it can be called as a function
this.testItCanBeCalledAsFunction = function () {
    t.spy()();
};

// TypeError: t.spy(...) is not a function

// Simplest implementation:
spy: function () {
    return function () {};
}

// Let's check that after being called it has correct `.called` value
this.testIsCalledAfterBeingCalled = function () {
    var aSpy = t.spy();
    aSpy();
    t.assertTrue(aSpy.called);
};

// Error: Expected to be true, but got false

// And final implementation:
spy: function () {
    return function that() {
        that.called = true;
    };
}
</code></pre>

<p>Test <code>testItCanBeCalledAsFunction</code> is inferior to <code>testIsCalledAfterBeingCalled</code>, so we can remove it.</p>

<p>To make the assertion more fluent we might want to have <code>aSpy.assertCalled()</code> and <code>aSpy.assertNotCalled()</code>:</p>

<pre><code class="javascript">// Let's replace our first test's `assertTrue(!...)` with `.assertNotCalled()`
this.testIsNotCalledInitially = function () {
    t.spy().assertNotCalled();
};

// TypeError: t.spy(...).assertNotCalled is not a function

// And the stupid implementation:
spy: function () {
    function that() {
        that.called = true;
    }

    that.assertNotCalled = function () {};

    return that;
}

// This needs some triangulation:
this.testAssertNotCalledFailsWhenWasCalled = function () {
    var aSpy = t.spy();
    aSpy();

    t.assertThrow("Expected not to be called", function () {
        aSpy.assertNotCalled();
    });
};

// Error: Expected to throw an error, but nothing was thrown

// And to make it pass:
that.assertNotCalled = function () {
    assertions.assertTrue(!that.called, "Expected not to be called");
};
</code></pre>

<p>Let&rsquo;s do the same with the other test:</p>

<pre><code class="javascript">// Replace `assertTrue` in the second test with `assertCalled`:
this.testIsCalledAfterBeingCalled = function () {
    var aSpy = t.spy();
    aSpy();
    aSpy.assertCalled();
};

// TypeError: aSpy.assertCalled is not a function

// And the stupid implementation:
that.assertCalled = function () {};

// Let's triangulate it a bit:
this.testAssertCalledFailsWhenWasNotCalled = function () {
    t.assertThrow("Expected to be called", function () {
        t.spy().assertCalled();
    });
};

// Error: Expected to throw an error, but nothing was thrown

// And the implementation:
that.assertCalled = function () {
    assertions.assertTrue(that.called, "Expected to be called");
};
</code></pre>

<p>And the full implementation of <code>spy()</code> function:</p>

<pre><code class="javascript">spy: function () {
    function that() {
        that.called = true;
    }

    that.assertNotCalled = function () {
        assertions.assertTrue(!that.called, "Expected not to be called");
    };

    that.assertCalled = function () {
        assertions.assertTrue(that.called, "Expected to be called");
    };

    return that;
}
</code></pre>

<h2>Bottom Line</h2>

<p>Today we have tested all the existing behavior of the <code>runTestSuite</code> function. That has driven us to implement very simple spies for our testing framework.</p>

<p>We have successfully applied manual Mutational Testing to the existing functionality to derive Semantically Stable tests for it. We did some Triangulation too today. Generally speaking, in TDD Triangulation technique is something that is used on a daily basis, when TDD is practiced properly. Future articles will expand on Triangulation, Mutational Testing, and Semantic Stability in more detail, so stay tuned!</p>

<p>There are only a few problems left, that bother me:</p>

<ul>
<li>We often do <code>t.assertTrue(!condition)</code>, seems that we lack <code>t.assertFalse(condition)</code> assertion.</li>
<li>We often call functions without any assertions to do an implicit assertion, that the call is not throwing any exception. This can be confusing: it is better to make that assertion explicitly - seems like we need <code>t.assertNotThrow</code>.</li>
<li>Seems that it is useful to have <code>NOT</code> version of every assertion. Even though we don&rsquo;t need <code>t.assertNotEqual</code> right now, from my experience with testing it is often very useful.</li>
</ul>


<p>Creating these assertions I will leave as an exercise to the reader. From now on, we will assume they are implemented and we will use them where appropriate. Code is available on GitHub: <a href="https://github.com/waterlink/BuildYourOwnTestingFrameworkPart3">https://github.com/waterlink/BuildYourOwnTestingFrameworkPart3</a></p>

<p>Next time we will add more requirements for our <code>runTestSuite</code> function, such as:</p>

<ul>
<li>Continue running tests after the first failure.</li>
<li>Report successfully passed tests.</li>
<li>Report failures.</li>
<li>Report test run stats (counts of successful and failed tests).</li>
<li>Avoid shared state between tests of the same test suite.</li>
</ul>


<p>Stay tuned!</p>

<h2>Thanks!</h2>

<p>Thank you for reading, my dear reader. If you liked it, please share this article on social networks and follow me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you have any questions or feedback for me, don&rsquo;t hesitate to reach me out on Twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>
]]></content>
  </entry>
  
</feed>
