<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tdd | That TDD Fellow | Tech Blog | Screencasts]]></title>
  <link href="http://www.tddfellow.com/blog/categories/tdd/atom.xml" rel="self"/>
  <link href="http://www.tddfellow.com/"/>
  <updated>2016-12-28T20:49:58+01:00</updated>
  <id>http://www.tddfellow.com/</id>
  <author>
    <name><![CDATA[Oleksii Fedorov (waterlink)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Learning Test-Driven Development With Javascript: End-to-End Testing]]></title>
    <link href="http://www.tddfellow.com/blog/2016/12/23/learning-test-driven-development-with-javascript-end-to-end-testing/"/>
    <updated>2016-12-23T10:13:33+01:00</updated>
    <id>http://www.tddfellow.com/blog/2016/12/23/learning-test-driven-development-with-javascript-end-to-end-testing</id>
    <content type="html"><![CDATA[<p><strong>Level: Beginner.</strong></p>

<p>&ldquo;Learning TDD with Javascript&rdquo; is the series of articles where we learn basics of automated testing and test-driven development. While the language of choice for the code examples is Javascript, all described concepts are language-agnostic and are applicable in various technological stacks. In these articles, a reader is expected to do small exercises after each major topic to reinforce that theoretical knowledge with practice. Some of these exercises are practical and will involve coding, or simple writing; others will be food for thought. Also, a reader might want to get their feedback on these exercises, so don&rsquo;t hesitate to send the results my way: <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x6f;&#x6c;&#x65;&#x6b;&#115;&#105;&#x69;&#x40;&#x74;&#100;&#x64;&#x66;&#101;&#x6c;&#x6c;&#x6f;&#119;&#46;&#99;&#111;&#x6d;">&#x6f;&#x6c;&#101;&#x6b;&#115;&#105;&#x69;&#64;&#116;&#x64;&#x64;&#x66;&#101;&#108;&#x6c;&#111;&#x77;&#46;&#x63;&#111;&#109;</a> - feedback on the practice is quite important as it helps to improve quicker, when you know what is well and what can be improved and how. Also, don&rsquo;t hesitate to send any questions and feedback regarding the content of these articles. Your questions, feedback, and your practical results will help authors shape this content better.</p>

<p>Today we are going to learn how to write tests that imitate real user interaction for the whole application. We are going to build a small web application using Vanilla Javascript. Vanilla Javascript is a plain Javascript without any framework or library. Such tests that imitate real user interaction via User Interface (UI) are called End-to-End Tests. These tests are the most simple to write because we only need to think about our application in the same way user does:</p>

<ul>
<li>Imitating the user clicking on the button would mean for us to trigger a button click;</li>
<li>Imitating the user typing text in the input field would mean for us to change input&rsquo;s value;</li>
<li>Imitating the user clicking on the link would mean for us to trigger a link click;</li>
<li>And so on.</li>
</ul>


<!-- more -->


<p>We don&rsquo;t need to think about specific implementation details, such as: which functions and classes do we have in our code and how they interact with each other, is there any interaction with the back-end server or 3rd-party API. Also, we don&rsquo;t need to be proficient with interaction testing - this is the topic for the future series.</p>

<p>Of course, for that kind of simplicity we are trading something off. In the case of End-to-End tests, they are slower, suffer concurrency, wait, and timeout problems, and are harder to maintain in the long run. We don&rsquo;t have to worry about that just yet because we want to learn how to write tests in general, and this kind of simplicity is perfect for us in this case.</p>

<p>Such simplicity stems from the fact that End-to-End tests, mostly, are direct translations of user stories (use case scenarios) into the UI manipulation code.</p>

<h2>User Story</h2>

<p>User stories are scenarios describing an individual feature of the software via user story context, sequences of user interactions and user expectations. User story context is the description of the situation the user and the software system are in at the beginning of the scenario. An example of the system context: &ldquo;user John is registered in the system with password &lsquo;welcome&rsquo;.&rdquo; An example of the user context: &ldquo;user is at the login page.&rdquo; User interaction is the description of a particular action user takes inside of the system, usually, doing something within the UI, for example: &ldquo;User enters email &lsquo;<a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#106;&#111;&#x68;&#x6e;&#x40;&#x65;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x6f;&#x72;&#103;">&#x6a;&#111;&#104;&#x6e;&#x40;&#101;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#46;&#111;&#x72;&#103;</a>&rsquo; in the email input field&rdquo; or &ldquo;User clicks on the submit button.&rdquo; Finally, user expectation is the description of what particular information user should receive from the system, for example: &ldquo;User sees the success message on the page&rdquo; or &ldquo;User receives the email with the verification code.&rdquo;</p>

<p>User stories come in different flavor and formats. It can be a free-form text, describing three parts: context, interactions, and expectations; or it can be in a formal &ldquo;Given-When-Then&rdquo; form. &ldquo;Given&rdquo; part is the sequence of the user story context descriptions, &ldquo;When&rdquo; part is the sequence of the user interaction descriptions, and &ldquo;Then&rdquo; part is the sequence of user expectation descriptions. Both forms can be used interchangeably, and some software companies use one or another formal version of the user story format consistently.</p>

<p>Let&rsquo;s take a look at the example of the free-form user story together with the example of the Given-When-Then user story for the same feature:</p>

<div class="next-table-layout-is-fixed"></div>


<table>
<thead>
<tr>
<th>Free-form</th>
<th>Given-When-Then</th>
</tr>
</thead>
<tbody>
<tr>
<td><hr></td>
<td><hr></td>
</tr>
<tr>
<td>User with email &lsquo;<a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x6a;&#x6f;&#104;&#110;&#64;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#x65;&#x2e;&#x6f;&#114;&#103;">&#x6a;&#x6f;&#104;&#x6e;&#64;&#101;&#x78;&#97;&#109;&#x70;&#108;&#x65;&#x2e;&#111;&#114;&#103;</a>&rsquo; and password &lsquo;welcome&rsquo; exists in the system<br>John enters his email &lsquo;<a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x6a;&#111;&#x68;&#x6e;&#x40;&#101;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#111;&#114;&#x67;">&#106;&#x6f;&#x68;&#110;&#64;&#x65;&#120;&#97;&#x6d;&#112;&#x6c;&#101;&#x2e;&#x6f;&#114;&#103;</a>&rsquo; into the email field and his password &lsquo;welcome&rsquo; into the password field on the login page<br>After that John submits the login form<br>Finally, John expects to see their profile page with the indication of him being logged in (name &lsquo;John&rsquo; is present on the page)</td>
<td><strong>Given</strong> User with email &lsquo;<a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x6a;&#111;&#104;&#110;&#x40;&#101;&#120;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#x6f;&#x72;&#103;">&#106;&#x6f;&#x68;&#x6e;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#x6f;&#114;&#x67;</a>&rsquo; and password &lsquo;welcome&rsquo; exists<br><strong>And</strong> I am at the login page<br><strong>When</strong> I enter &lsquo;<a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#106;&#x6f;&#104;&#x6e;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#x2e;&#x6f;&#x72;&#103;">&#x6a;&#111;&#104;&#110;&#64;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#x2e;&#x6f;&#114;&#103;</a>&rsquo; in the email field<br><strong>And</strong> I enter &lsquo;welcome&rsquo; in the password field<br><strong>And</strong> I click on the submit button<br><strong>Then</strong> I see the profile page<br><strong>And</strong> I see my name as the title of the profile page</td>
</tr>
</tbody>
</table>


<p>As we can see, free-form can be very vague and is very flexible, and formal form is more strict and precise. The free-form on its own doesn&rsquo;t have much upsides or downsides - it is as good as it is written. On the other hand, the formal form does give us some value and also trades something off for that value. They are generally easy to write and, because they are so specific, are easy to translate to the automated test. On the other hand, they may hamper creativity either while creating the user story or when implementing it.</p>

<p>It is important to mention that these use case scenarios are not full user stories or features. One feature can have multiple scenarios like that - together they are called acceptance criteria. When all such scenarios of the given feature work correctly, the feature is done. There is another vital part of the user story - general description, that should contain the rationale behind the story and the value for the user or any other important actor in the system, such as the stakeholder. Before we write scenarios, we often come up with the rationale like that and it drives us to write a scenario. For example, for the feature above we would have used something like that:</p>

<div class="next-table-layout-is-fixed"></div>


<table>
<thead>
<tr>
<th>Free-form</th>
<th>Given-When-Then</th>
</tr>
</thead>
<tbody>
<tr>
<td><hr></td>
<td><hr></td>
</tr>
<tr>
<td>John needs to authenticate to the system so that he can access his private content</td>
<td><strong>As John</strong>, I want to be able to authenticate to the system<br><strong>So that</strong> I can access my private content</td>
</tr>
</tbody>
</table>


<p>Because formal form user stories are more precise, easier to write and simpler to translate to the automated test, we are going to use them to learn End-to-End testing in the context of Test-Driven Development.</p>

<h3>Exercises</h3>

<ol>
<li>Write a scenario for authentication story, when John enters the wrong password.</li>
<li>Write a user story with rationale and scenarios for the sign-up feature.</li>
<li>Imagine we are developing an instant messaging application. What do you think would be the next feature after login/sign-up? Write the user story with rationale and scenarios for this feature.</li>
</ol>


<p>Do you have questions? Or do you want to get quick feedback on how you did the exercises? - mail me: <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x6f;&#x6c;&#x65;&#x6b;&#x73;&#x69;&#105;&#x40;&#116;&#100;&#x64;&#102;&#101;&#108;&#x6c;&#111;&#119;&#x2e;&#99;&#111;&#x6d;">&#x6f;&#108;&#x65;&#x6b;&#x73;&#105;&#105;&#64;&#116;&#100;&#100;&#102;&#101;&#x6c;&#x6c;&#x6f;&#x77;&#46;&#x63;&#x6f;&#x6d;</a></p>

<h2>Setting Up the Project</h2>

<p>Now we will be writing a simple web application, using Vanilla Javascript (ECMAScript 5), so that our setup is rather simple. For the testing, we will be using a standalone version of the Jasmine testing framework. Also, we will be writing a single page application (SPA), so that we don&rsquo;t have to worry about rendering different pages in our tests for now. We are aiming for the following directory structure of our project:</p>

<pre><code>.
├── lib
├───── .. external libraries, such as Jasmine ..
├── spec
├───── .. sources with Jasmine automated tests ..
└── src
├───── .. sources with our main code ..
├── index.html       - entry point to the application
├── SpecRunner.html  - entry point to our test suite
</code></pre>

<p>First, create required directories: <code>lib</code>, <code>spec</code> and <code>src</code>. Then download the latest standalone Jasmine release here: <a href="https://github.com/jasmine/jasmine/releases">https://github.com/jasmine/jasmine/releases</a> (jasmine-standalone-{version}.zip file). At the time of writing, the version is <code>2.5.2</code>. Unzip that file into your project directory. You should get the following files from it:</p>

<ul>
<li><code>./lib/jasmine-2.5.2/</code> directory - contains all the resources required by Jasmine.</li>
<li><code>./SpecRunner.html</code> - example entry point to our test suite.</li>
<li><code>./src/Player.js</code> and <code>./src/Song.js</code> - example source files.</li>
<li><code>./spec/PlayerSpec.js</code> and <code>./spec/SpecHelper.js</code> - example automated Jasmine tests.</li>
</ul>


<p>Now, try to open <code>SpecRunner.html</code> in your browser. It should run these example tests, and they should all pass. Here is how it should look like:</p>

<p><img src="/images/learning-tdd-with-js/jasmine-example-run.png" alt="Jasmine example test run with all tests green" /></p>

<p>Also, create an empty <code>index.html</code>:</p>

<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>And now we should have the desired project structure. So how does that Jasmine testing framework works, anyways?</p>

<h2>Crash Course into Jasmine</h2>

<p>Let&rsquo;s take a look at the example test file to get the gist of how Jasmine works:</p>

<pre><code class="javascript">// spec/PlayerSpec.js

describe("Player", function() {
  var player;
  var song;

  beforeEach(function() {
    player = new Player();
    song = new Song();
  });

  it("should be able to play a Song", function() {
    player.play(song);
    expect(player.currentlyPlayingSong).toEqual(song);

    //demonstrates use of custom matcher
    expect(player).toBePlaying(song);
  });

  describe("when song has been paused", function() {
    beforeEach(function() {
      player.play(song);
      player.pause();
    });

    it("should indicate that the song is currently paused", function() {
      expect(player.isPlaying).toBeFalsy();

      // demonstrates use of 'not' with a custom matcher
      expect(player).not.toBePlaying(song);
    });

    it("should be possible to resume", function() {
      player.resume();
      expect(player.isPlaying).toBeTruthy();
      expect(player.currentlyPlayingSong).toEqual(song);
    });
  });

  // demonstrates use of spies to intercept and test method calls
  it("tells the current song if the user has made it a favorite", function() {
    spyOn(song, 'persistFavoriteStatus');

    player.play(song);
    player.makeFavorite();

    expect(song.persistFavoriteStatus).toHaveBeenCalledWith(true);
  });

  //demonstrates use of expected exceptions
  describe("#resume", function() {
    it("should throw an exception if song is already playing", function() {
      player.play(song);

      expect(function() {
        player.resume();
      }).toThrowError("song is already playing");
    });
  });
});
</code></pre>

<p>First important concept here is the <code>describe("...", function () { ... })</code>. <code>describe</code> function is used to describe a certain concept or a certain context. For example, <code>describe("Player", ...)</code> means that we are going to define tests for <code>Player</code> class or some other <code>Player</code> concept. Also, describes can be nested to indicate that we are describing some specific context (<code>describe("when a song has been paused", ...)</code>) or sub-concept of current concept, such as the method of currently described class (<code>describe("#resume", ...)</code>). That is a good example, of what the unit test suite might be describing. In the case of End-to-End tests we would like to describe a full feature, so <code>describe("Login Feature", ...)</code> is a good bet. The second argument for the <code>describe</code> is the function that will contain all tests and sub-describes for the described concept. This function is the capturing closure, so defining variables and functions on the outer-level describe will make them available on the inner-level describes and the tests themselves.</p>

<p>Second important concept here is the <code>it("...", function () { ... })</code>. <code>it</code> function is used to create a test for the currently described concept, context or sub-concept. The first argument is the description of what <em>it</em> does, where <em>it</em> is the described concept. For example, given we describe a <code>music player</code> and our context is <code>when the volume is at max</code>, then we might write the test <code>it("is deafening", ...)</code>. In the case of End-to-End tests we are describing a feature, so <em>it</em> will refer to our application, or application&rsquo;s user interface, for example: <code>it("shows user's nickname", ...)</code>. The second argument to the <code>it</code> is the function with the test itself. Here we will setup the stage for the test, call our main code and verify that everything happened as we expect.</p>

<p>Finally, the third important concept is the <code>expect(...).to...</code>. That is Jasmine&rsquo;s form of assertion. That is where we verify that our code worked as we expect it to. As an argument to expect we provide an actual value. The actual value is something that our code has returned as a result of the function or method execution or something that we have read from the UI using UI manipulation code, or something that we have read from some 3rd party service, such as our back-end server, 3rd-party API or database. Essentially, this is the value that we are verifying to be correct. The second part is the Jasmine matcher - the method defined on the object, that is returned from <code>expect(value)</code> call, that allows us to define what we want to assert about that value. The most used one is <code>toEqual(...)</code>, which asserts that the value was equal to some expected value.</p>

<p>These three concepts should be enough to start writing tests. Don&rsquo;t worry about everything else that you see in this example file from standalone Jasmine distribution. We will discover some of these concepts as we go. Now, let&rsquo;s remove <code>src/Player.js</code>, <code>src/Song.js</code>, <code>spec/PlayerSpec.js</code> and <code>spec/SpecHelper.js</code>, and run our test suite - it is enough to reload the page to re-run our test suite. Test run should report that <code>No specs found</code>:</p>

<p><img src="/images/learning-tdd-with-js/jasmine-no-specs-found.png" alt="Jasmine no specs found example" /></p>

<p>To get the gist of how <code>describe("...", function () { ... })</code>, <code>it("...", function () { ... })</code> and <code>expect(...).toEqual(...)</code> works, let&rsquo;s write our first failing test. Also, that will let us see if the testing framework is configured correctly and is capable of showing us the test failure. Let&rsquo;s create a new file called <code>spec/JasmineWorksSpec.js</code>:</p>

<pre><code class="javascript">// spec/JasmineWorksSpec.js

describe("testing framework", function () {
  it("works", function () {
    expect(2 + 2).toEqual(5);
  });
});
</code></pre>

<p>And we need to add this test file to the <code>SpecRunner.html</code>:</p>

<p>&#8220;`html</p>

<!-- include source files here... -->




<!-- include spec files here... -->


<script src="spec/JasmineWorksSpec.js"></script>


<pre><code>
And if we run our test suite, we should see a failure:
</code></pre>

<p>testing framework works
  Expected 4 to equal 5.
&#8220;`</p>

<p>And we ought to make it pass by fixing our incorrect assertion: <code>expect(2 + 2).toEqual(4);</code>. And if we run the test suite again, by reloading the page in the browser, all the test should pass.</p>

<h2>Writing our First Simple Tests</h2>

<p>Now we can write some real tests to practice usage of <code>describe</code>, <code>it</code> and <code>expect(...).toEqual</code>: let&rsquo;s create <code>ArithmeticsSpec.js</code> and write some tests for behavior of <code>add</code> function:</p>

<pre><code class="javascript">// spec/ArithmeticsSpec.js

describe("Arithmetics", function () {

  describe("#add(a, b)", function () {
    it("calculates the sum of two numbers", function () {
      // ARRANGE
      var a = 3;
      var b = 4;
      var expected = 7;

      // ACT
      var actual = Arithmetics.add(a, b);

      // ASSERT
      expect(actual).toEqual(expected);
    });
  });

});
</code></pre>

<p>Don&rsquo;t forget to add the <code>&lt;script src="spec/ArithmeticsSpec.js"&gt;&lt;/script&gt;</code> to the <code>SpecRunner.html</code>. This test will fail first because <code>Arithmetics</code> module is not defined. We will define it as an empty object. Next failure is because <code>Arithmetics.add</code> is not a function - it is undefined. We will define that function with two arguments inside of the <code>Arithmetics</code> object. Finally, the test will fail, because we expect the result to be seven, but it was undefined. We will make the simplest thing we can do to pass the failing test - return seven. That will make the test pass. The code will be in <code>src/Arithmetics.js</code>, which we include in our <code>SpecRunner.html</code>, and will look like that:</p>

<pre><code class="javascript">// src/Arithmetics.js

var Arithmetics = {
  add: function (a, b) {
    return 7;
  }
};
</code></pre>

<p>That, of course, is not correct implementation, so we need another test to drive out the proper implementation - test with different inputs and a different result. To make it pass we will have to use <code>a + b</code>:</p>

<pre><code class="javascript">// spec/ArithmeticsSpec.js
describe("Arithmetics", function () {

  describe("#add(a, b)", function () {
    it("calculates the sum of two numbers", function () { ... });

    it("calculates the sum of two other numbers", function () {
      // ARRANGE
      var a = 73;
      var b = 89;
      var expected = 162;

      // ACT
      var actual = Arithmetics.add(a, b);

      // ASSERT
      expect(actual).toEqual(expected);
    });
  });

});

// src/Arithmetics.js
var Arithmetics = {
  add: function (a, b) {
    return a + b;
  }
};
</code></pre>

<h3>Three &ldquo;A&#8221;s: Arrange, Act, and Assert</h3>

<p>Have you noticed three comments that I have left in the example tests&#8217; code: <code>ARRANGE</code>, <code>ACT</code> and <code>ASSERT</code>? These are three &ldquo;A&#8221;s of writing a good test. Arrange is the part of the test, where we set up the stage: prepare input data, create objects, load resources, change the state of the system - it is the part where we create the context for our test. Act is the part of the test, where we call our system under the test. In the <code>Arithmetics</code> example it was a function <code>Arithmetics.add(a, b)</code>. The system under the test can return some useful value or change its state. To verify that either is correct we, finally, use Assert section of our test - part of the test where we verify the outcome of the call to the system under the test.</p>

<p>The sections <code>ARRANGE</code>, <code>ACT</code> and <code>ASSERT</code> are spelled out in the comments only for the reader&rsquo;s convenience - usually, real projects don&rsquo;t have such comments. It is worth noting that for learning and practicing purposes it is a good idea to name these sections explicitly in our tests - this develops a habit of recognizing which part of the test should belong to which section. Also, the formula Act -> Arrange -> Assert makes it easier to come up with the test when we lack deep experience in testing, or with the particular testing framework, or an environment.</p>

<p>Going a bit back to our user story scenarios: have you noticed the connection between &ldquo;Arrange, Act and Assert&rdquo; and &ldquo;Given-When-Then&rdquo;? Arrange part of the test corresponds to the Given part of the scenario, Act part of the test corresponds to the When part of the scenario, and Assert part of the test corresponds to the Then part of the scenario. Let&rsquo;s see it on of our previous example scenarios:</p>

<div class="next-table-is-top-aligned"></div>


<table>
<thead>
<tr>
<th>Test Section</th>
<th>Scenario Step</th>
</tr>
</thead>
<tbody>
<tr>
<td><hr></td>
<td><hr></td>
</tr>
<tr>
<td>ARRANGE</td>
<td><strong>Given</strong> User with email ‘john@example.org’ and password ‘welcome’ exists<br><strong>And</strong> I am at the login page</td>
</tr>
<tr>
<td><br></td>
<td><br></td>
</tr>
<tr>
<td>ACT</td>
<td><strong>When</strong> I enter ‘john@example.org’ in the email field<br><strong>And</strong> I enter ‘welcome’ in the password field<br><strong>And</strong> I click on the submit button</td>
</tr>
<tr>
<td><br></td>
<td><br></td>
</tr>
<tr>
<td>ASSERT</td>
<td><strong>Then</strong> I see the profile page<br><strong>And</strong> I see my name as the title of the profile page</td>
</tr>
</tbody>
</table>


<h3>Exercises</h3>

<ol>
<li>Write tests and implement functions on <code>Arithmetics</code> module: <code>subtract</code>, <code>multiply</code> and <code>divide</code>.</li>
<li>Inline Arrange, Act and Assert in a one-liner. Can you still recognize implicit Arrange, Act and Assert sections in that one line? Is it more or less readable? Is there a middle ground between two versions? Why would you choose one or the other?</li>
<li>Classify parts of the free-form story for the user log in from before as Arrange, Act, and Assert. Was it easier, than classifying formal Given-When-Then form? Was it harder? Or maybe the same? How would it be if you never saw Given-When-Then version of that free-form story?</li>
</ol>


<h2>Writing our First End-to-End Test</h2>

<p>Now that we know approximately, how to arrange the steps of our scenario into the test, let&rsquo;s give it a shot. We will start by creating a new test file for our login feature called <code>LoginFeatureSpec.js</code>. Don&rsquo;t forget to put an appropriate script tag in the <code>SpecRunner.html</code>. We will start by writing the skeleton of our test suite: <code>describe</code> and <code>it</code> inside of it. Next, we will put scenario steps as comments to our test, and we will split them into three sections: Arrange, Act, and Assert. It will look like this:</p>

<pre><code class="javascript">// spec/LoginFeatureSpec.js

describe("Login Feature", function () {

  it("allows to login with correct credentials", function () {
    // ARRANGE
    // Given User with email ‘john@example.org’ and password ‘welcome’ exists
    // And I am at the login page

    // ACT
    // When I enter ‘john@example.org’ in the email field
    // And I enter ‘welcome’ in the password field
    // And I click on the submit button

    // ASSERT
    // Then I see the profile page
    // And I see my name as the title of the profile page
  });

});
</code></pre>

<p>Next step would be to change the first <strong>Given</strong> comment to the function call. We should give a good readable name to that function. One straightforward option would be <code>givenUserExists(email, password).' Another good option is</code>addUser({email: email, password: password})<code>. While they are not that different, I prefer</code>addUser<code>for its higher conceptual flexibility - we will likely need that function in some different scenario step in the future. While I prefer that, we should not do that yet, because we might never need the function like that, and</code>givenUserExists<code>will do us more good right now since it resembles the scenario step so much. When we need this flexibility, we'll perform a refactoring. So for now, let's create an empty function with that name in a new file</code>spec/FeatureSteps.js<code>and load this file from our</code>SpecRunner.html`.</p>

<p>This empty function, on its own, doesn&rsquo;t do us much good because all our tests will pass. If we continue replacing our steps in comments with such functions, we will end up with one big failure at the Assert section, and we will have to write a lot of code at once to fix that. To drive ourselves to implement the function <code>givenUserExists</code> properly right now, we should write an assertion right after the call. This assertion is not part of Assert section - it is a part of test-driving the functionality of our feature steps. A good assertion here will be to ask our user storage mechanism if such user exists right after we created that user. Also, it would be a good idea to check that user does not exist, before we created it. Also, we will extract variables <code>email</code> and <code>password</code> because we have to repeat them all over the place already. Let&rsquo;s see how it will look like:</p>

<pre><code class="javascript">// spec/LoginFeatureSpec.js

describe("Login Feature", function () {

  it("allows to login with correct credentials", function () {
    // ARRANGE

    // Given User with email ‘john@example.org’ and password ‘welcome’ exists
    var email = "john@example.org";
    var password = "welcome";
    expect(Users.exists(email, password)).toEqual(false);
    givenUserExists(email, password);
    expect(Users.exists(email, password)).toEqual(true);

    // ...
  });

});
</code></pre>

<p>When we run our tests, the breadcrumbs of test failures will drive us to create this basic functionality. First, we will create <code>Users.js</code> with empty <code>Users</code> module and import it from <code>SpecRunner.html</code>. Then, next failure will drive us to add method <code>exists(email, password)</code> on <code>Users</code> module, that will always return <code>false</code>. Next, make function <code>givenUserExists(email, password)</code> call <code>Users.add(email, password)</code>, which in turn will make us create a function <code>Users.add(email, password)</code>, that will store email-password pair to the list of users in the memory. And, finally, make <code>Users.exists</code> to search for the email-password pair in that in-memory list. And finally, our test will pass. Let&rsquo;s take a look at how these steps will look in our code:</p>

<pre><code class="javascript">// =&gt; Error: Users is undefined
// in src/Users.js:
var Users = {};

// =&gt; Error: Users.exists is not a function
// in src/Users.js:
var Users = {
  exists: function (email, password) {}
};

// =&gt; Error: expected undefined to equal false
// in src/Users.js:
var Users = {
  exists: function (email, password) {
    return false;
  }
};

// =&gt; Error: expected false to equal true
// in the (second assertion)
// in spec/FeatureSteps.js:
function givenUserExists(email, password) {
  Users.add(email, password);
}

// =&gt; Error: Users.add is not a function
// in src/Users.js:
var Users = {
  users: [],

  exists: function (email, password) { ... },

  add: function (email, password) {
    this.users.push({email: email, password: password});
  }
}

// this still fails with:
// =&gt; Error: expected false to equal true
// because we need to implement Users.exists "properly"
// in src/Users.js:
var Users = {
  users: [],

  exists: function (email, password) {
    return this.users.length &gt; 0;
  },

  add: function (email, password) { ... }
}

// =&gt; All tests PASS
</code></pre>

<p>It is funny, how simple <code>Users.exists(email, password)</code> function is. It verifies that we have at least one user. While this is not a correct code, this is good enough for our current test. As we know that this code is not entirely correct, we need to remember to write the test(s) to prove it incorrect, so that we can make it proper with confidence. Since we want first to finish the current test, we should add a to-do list item to write such test. We have two edge cases here that will not work with our implementation: when we have only one user in the system and the credentials we provided do not match and when we have multiple users in the system, and we provide correct credentials for the second one:</p>

<pre><code class="javascript">xdescribe("when user has different credentials", function () {
  it("does not allow to login with wrong credentials", function () {

  });
});

xdescribe("when there are more than one user", function () {
  it("allows to login with correct credentials", function () {

  });
});
</code></pre>

<p>Have you noticed <code>xdescribe</code>? It is a different form of the <code>describe</code>, that allows us to mark the whole context as pending. It won&rsquo;t run the tests inside, and it will mark them as pending in the test run report. That is the ultimate way to maintain a Test-Driven TODO List. As we test-drive our code, we will find more of these. In the report they look like this:</p>

<p><img src="/images/learning-tdd-with-js/jasmine-e2e-pending-tests.png" alt="pending jasmine tests" /></p>

<p>Let&rsquo;s finish continue implementing our steps. The comment <code>And I am at the login page</code> transparently becomes a function <code>givenIAmAtTheLoginPage()</code>. As we already have seen, it doesn&rsquo;t do us any good just to replace the comment with a function call that does nothing - so we should surround it with proper assertions. We know that login page should have some text input for email and another password field for password, and we will need a button to confirm user&rsquo;s intent to log in. Also, because we are developing a single page application, we would need some container for the currently active page. Let&rsquo;s say we need these things:</p>

<ul>
<li>Initially, we will have only one container with <code>id="page"</code> and no content. We probably ought to define it in our HTML file.</li>
<li>When we render our login page, we should have:

<ul>
<li>email text input field with <code>id="email"</code>,</li>
<li>password input field with <code>id="password"</code>,</li>
<li>and button with <code>id="do_login"</code>.</li>
</ul>
</li>
</ul>


<p>Now that we have spelt this out, it is fairly straightforward to write assertions surrounding the <code>givenIAmAtTheLoginPage()</code> call:</p>

<pre><code class="javascript">// Initially, we will have only one container with `id="page"`
var container = document.querySelector("#page");
expect(container).not.toEqual(null);
// and no content
expect(container.innerHTML).toEqual("");
</code></pre>

<p>That fails because we don&rsquo;t have such element in our HTML. We need to create it both in our <code>SpecRunner.html</code>. Also, now it will be important to move all our <code>&lt;script&gt;</code> tags from the <code>&lt;head&gt;</code> to the <code>&lt;body&gt;</code> below the container that we have just created. <code>SpecRunner.html</code> should look this way after that:</p>

<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Jasmine Spec Runner v2.5.2&lt;/title&gt;

    &lt;link rel="shortcut icon" type="image/png" href="lib/jasmine-2.5.2/jasmine_favicon.png"&gt;
    &lt;link rel="stylesheet" href="lib/jasmine-2.5.2/jasmine.css"&gt;
&lt;/head&gt;

&lt;body&gt;

    &lt;div id="page"&gt;&lt;/div&gt;

    &lt;script src="lib/jasmine-2.5.2/jasmine.js"&gt;&lt;/script&gt;
    &lt;script src="lib/jasmine-2.5.2/jasmine-html.js"&gt;&lt;/script&gt;
    &lt;script src="lib/jasmine-2.5.2/boot.js"&gt;&lt;/script&gt;

    &lt;!-- include source files here... --&gt;
    &lt;script src="src/Arithmetics.js"&gt;&lt;/script&gt;
    &lt;script src="src/Users.js"&gt;&lt;/script&gt;

    &lt;!-- include spec files here... --&gt;
    &lt;script src="spec/JasmineWorksSpec.js"&gt;&lt;/script&gt;
    &lt;script src="spec/ArithmeticsSpec.js"&gt;&lt;/script&gt;
    &lt;script src="spec/FeatureSteps.js"&gt;&lt;/script&gt;
    &lt;script src="spec/LoginFeatureSpec.js"&gt;&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Now, our next failure is that <code>givenIAmAtTheLoginPage()</code> function is not defined. We can define it as empty function in our <code>spec/FeatureSteps.js</code> file for now. This will turn our tests green again. We still haven&rsquo;t made our assertions about the state of the UI after the call to <code>givenIAmAtTheLoginPage</code> - let&rsquo;s do this now:</p>

<pre><code class="javascript">var emailInput = container.querySelector("#email");
expect(emailInput.tagName).toEqual("input");
expect(emailInput.type).toEqual("email");
</code></pre>

<p>That fails with the error <code>Cannot read property tagName of null</code>, which means that we don&rsquo;t have <code>#email</code> element inside of the <code>#page</code> container. Simplest thing to do would be to add that element to the <code>#page</code> container in our <code>SpecRunner.html</code>. And it won&rsquo;t work! Because we have an assertion that verifies, that before calling to the <code>givenIAmAtTheLoginPage</code> we do not have anything in the <code>#page</code> container. Now we have to do something useful in the function <code>givenIAmAtTheLoginPage</code>. For example, we can call <code>LoginPage.render()</code>. Which does not exist yet and we will need to create it in the file <code>src/LoginPage.js</code> and load it from our <code>SpecRunner.html</code>. To fix current failure we will need to create a <code>#email</code> element there and append it to our <code>#page</code> container:</p>

<pre><code class="javascript">// spec/FeatureSteps.js
function givenIAmAtTheLoginPage() {
  LoginPage.render();
}

// src/LoginPage.js
var LoginPage = {
  render: function () {
    var emailInput = document.createElement("div");
    emailInput.id = "email";

    var container = document.querySelector("#page");
    container.appendChild(emailInput);
  }
};
</code></pre>

<p>That makes the current test failure go away, but we have two more: <code>Expected 'DIV' to equal 'input'.</code> and <code>Expected undefined to equal 'email'.</code>. To make these pass, we would need to change <code>document.createElement(...)</code> call to use <code>input</code> tag name and also we will need to set the input type to <code>email</code>. And as we see, the tag name stored in <code>emailInput.tagName</code> is all-caps, so we will have to fix our assertion also to expect that:</p>

<pre><code class="javascript">// first we'll fix the assertion:
// in spec/LoginFeatureSpec.js
expect(emailInput.tagName).toEqual("INPUT");

// and then we will fix the emailInput creation:
// in src/LoginPage.js
var emailInput = document.createElement("input");
emailInput.id = "email";
emailInput.type = "email";
</code></pre>

<p>And if we run our tests, they all pass. Great! We should now do the same for our password input field and the login button:</p>

<pre><code class="javascript">// in spec/LoginFeatureSpec.js
var passwordInput = container.querySelector("#password");
expect(passwordInput.tagName).toEqual("INPUT");
expect(passwordInput.type).toEqual("password");
var loginButton = container.querySelector("#do_login");
expect(loginButton.tagName).toEqual("BUTTON");
expect(loginButton.textContent).toEqual("Login");

// in src/LoginPage.js
var passwordInput = document.createElement("input");
passwordInput.id = "password";
passwordInput.type = "password";
container.appendChild(passwordInput);

var loginButton = document.createElement("button");
loginButton.id = "do_login";
loginButton.textContent = "Login";
container.appendChild(loginButton);
</code></pre>

<p>And all tests pass again. Let&rsquo;s take another look at how our test looks like. It is quite complicated, and it has so much stuff, that is hugely detailed and precise, that it is not possible to see a user story scenario there anymore. One possible solution to that problem is to push the assertions that are related to the feature scenario step to the respective step functions. Now it looks much better. We should use the same concept for all our further steps. After refactoring test code looks like this:</p>

<pre><code class="javascript">// in spec/LoginFeatureSpec.js
it("allows to login with correct credentials", function () {
  // ARRANGE
  var email = "john@example.org";
  var password = "welcome";
  givenUserExists(email, password);
  givenIAmAtTheLoginPage();

  // ACT
  // When I enter ‘john@example.org’ in the email field
  // And I enter ‘welcome’ in the password field
  // And I click on the submit button

  // ASSERT
  // Then I see the profile page
  // And I see my name as the title of the profile page
});

// in spec/FeatureSteps.js
function givenUserExists(email, password) {
    expect(Users.exists(email, password)).toEqual(false);

    Users.add(email, password);

    expect(Users.exists(email, password)).toEqual(true);
}

function givenIAmAtTheLoginPage() {
    var container = document.querySelector("#page");
    expect(container).not.toEqual(null);
    expect(container.innerHTML).toEqual("");

    LoginPage.render();

    var emailInput = container.querySelector("#email");
    expect(emailInput.tagName).toEqual("INPUT");
    expect(emailInput.type).toEqual("email");

    var passwordInput = container.querySelector("#password");
    expect(passwordInput.tagName).toEqual("INPUT");
    expect(passwordInput.type).toEqual("password");

    var loginButton = container.querySelector("#do_login");
    expect(loginButton.tagName).toEqual("BUTTON");
    expect(loginButton.textContent).toEqual("Login");
}
</code></pre>

<p>Now, let&rsquo;s follow the same pattern for our Act section. First, we will deal with <code>When I enter ‘john@example.org’ in the email field</code>. This seems to be a call to a function <code>whenIEnterInTheField("#email", email)</code> - we will implement it using Javascript&rsquo;s APIs. We will do the same for the <code>And I enter ‘welcome’ in the password field</code>, which will use the same function <code>whenIEnterInTheField("#password", password).</code> Finally, we will implement <code>whenIClickOn("#do_login")</code> as a replacement for the comment <code>And I click on the submit button</code>. We will also sprinkle assertions inside of the steps to make sure that we are using the Javascript APIs correctly. The code will look like this:</p>

<pre><code class="javascript">// in spec/LoginFeatureSpec.js
it("allows to login with correct credentials", function () {
    // ARRANGE
    var email = "john@example.org";
    var password = "welcome";
    givenUserExists(email, password);
    givenIAmAtTheLoginPage();

    // ACT
    whenIEnterInTheField("#email", email);
    whenIEnterInTheField("#password", password);
    whenIClickOn("#do_login");

    // ASSERT
    // Then I see the profile page
    // And I see my name as the title of the profile page
});

// in spec/FeatureSteps.js
function whenIEnterInTheField(selector, value) {
    var element = document.querySelector(selector);
    expect(element).not.toEqual(null);
    expect(element.value).toEqual("");

    element.value = value;

    var elementAfterChange = document.querySelector(selector);
    expect(element.value).toEqual(value);
}

function whenIClickOn(selector) {
    var element = document.querySelector(selector);
    expect(element).not.toEqual(null);

    element.click();
}
</code></pre>

<p>Now comes the most interesting part of writing this feature test - Assert section. So far, Arrange and Act sections were driving us to create an infrastructure-like code of our application. Now, with Assert section we will have to implement more of our domain logic. Let&rsquo;s start with the <code>Then I see the profile page</code>. Let&rsquo;s try to figure our what that could mean:</p>

<ul>
<li>We no longer have a login page in our <code>#page</code> container.</li>
<li><code>#page</code> container should somehow indicate that we are on the <code>Profile</code> page:

<ul>
<li>could be achieved by adding a sub-container with <code>id="profile_page"</code> to it.</li>
</ul>
</li>
<li>We don&rsquo;t know much more about what the profile page is. What we do know is:

<ul>
<li>the profile page has a name of the user as the title of the page.</li>
</ul>
</li>
</ul>


<p>Interesting, so far, we didn&rsquo;t have a concept of the Name of the User. I guess it is time to create one in our arrange block, with all the changes and additional assertions in our feature steps that we have to do:</p>

<pre><code class="javascript">// in spec/LoginFeatureSpec.js
// ARRANGE
var email = "john@example.org";
var password = "welcome";
var name = "John Smith";
givenUserExists(email, password, name);

// in spec/FeatureSteps.js
function givenUserExists(email, password, name) {
  expect(Users.exists(email, password)).toEqual(false);

  Users.add(email, password, name);            // &lt;=

  expect(Users.exists(email, password)).toEqual(true);

  expect(Users.nameOf(email)).toEqual(name);   // &lt;=
}

// also we need to add name field to the user data
// and implement nameOf(email) function
// in src/Users.js
add: function (email, password, name) {
  this.users.push({
    email: email,
    password: password,
    name: name
  });
},

nameOf: function (email) {
  return this.users[0].name;
}
</code></pre>

<p>And the tests will pass again. And now we have a tested concept of the name in our code. Tested - to the extent required for this test, where we have only one user in the system. Now we can replace the comment <code>Then I see the profile page</code> with the scenario step function call <code>thenISeeTheProfilePage()</code>. The implementation of it will verify that <code>#email</code>, <code>#password</code> and <code>#do_login</code> are no longer present on the page and it will verify that container <code>#page-profile</code> is present and it has <code>#title</code> element in it. Making it pass will require us to add a <code>click</code> event listener to the <code>loginButton</code> in the <code>LoginPage</code>, that will remove contents of the <code>#page</code> container and will call to <code>ProfilePage.render()</code> following the analogy of <code>LoginPage</code>. That drives us to create this module and its <code>render()</code> function. According to our next test failure, this function should create <code>#profile_page</code> sub-container in <code>#page</code> container, so we do that. Finally, we have one last failure, that drives us to create <code>#title</code> element in <code>ProfilePage.render()</code> function. And all tests are green again. Let&rsquo;s take a look at these changes:</p>

<pre><code class="javascript">// in spec/LoginFeatureSpec.js
// ASSERT
// Then I see the profile page
thenISeeTheProfilePage();

// in spec/FeatureSteps.js
function thenISeeTheProfilePage() {
  // assert login page is gone
  expect(document.querySelector("#email")).toEqual(null);
  expect(document.querySelector("#password")).toEqual(null);
  expect(document.querySelector("#do_login")).toEqual(null);

  // assert profile page is present
  expect(document.querySelector("#page #profile_page")).not.toEqual(null);
  expect(document.querySelector("#profile_page #title")).not.toEqual(null);
}

// in src/LoginPage.js at the end of render() function:
render: function() {
  // ...

  loginButton.addEventListener("click", LoginPage.onLogin);
},

onLogin: function () {
  container.innerHTML = "";
  ProfilePage.render();
}

// in src/ProfilePage.js
var ProfilePage = {
  render: function () {
    var profileContainer = document.createElement("div");
    profileContainer.id = "profile_page";
    container.appendChild(profileContainer);

    var title = document.createElement("h1");
    title.id = "title";
    profileContainer.appendChild(title);
  }
};
</code></pre>

<p>At last, we can implement the last step - <code>And I see my name as the title of the profile page</code>. A good guess for the step name would be <code>thenISeeTextAt("#title", name)</code>. The function will simply select element <code>#title</code> and verify its <code>element.textContent</code>. As expected, it fails with the error <code>Expected '' to equal 'John Smith'</code> and we should fix that within the <code>ProfilePage.render()</code> function by assigning <code>title.textContent</code> to the <code>Users.currentUser().name</code>. This fails because we didn&rsquo;t define <code>Users.currentUser()</code> function and this is simple to do for our current test - just return the first user. After that all our tests pass. The code will look like this:</p>

<pre><code class="javascript">// in spec/LoginFeatureSpec.js
thenISeeTextAt("#title", name);

// in spec/FeatureSteps.js
function thenISeeTextAt(selector, text) {
  var element = document.querySelector(selector);
  expect(element.textContent).toEqual(text);
}

// in src/ProfilePage.js
title.textContent = Users.currentUser().name;

// in src/Users.js
currentUser: function () {
    return this.users[0];
}
</code></pre>

<p>We have finally, implemented our first feature test. That was quite some work. Also, the functionality of <code>Users</code> module is way incomplete - we need to write more tests to cover different cases. That is how our test code and production code looks like:</p>

<pre><code class="javascript">// spec/LoginFeatureSpec.js
describe("Login Feature", function () {

    it("allows to login with correct credentials", function () {
        // ARRANGE
        var email = "john@example.org";
        var password = "welcome";
        var name = "John Smith";
        givenUserExists(email, password, name);
        givenIAmAtTheLoginPage();

        // ACT
        whenIEnterInTheField("#email", email);
        whenIEnterInTheField("#password", password);
        whenIClickOn("#do_login");

        // ASSERT
        thenISeeTheProfilePage();
        thenISeeTextAt("#title", name);
    });

    xdescribe("when user has different credentials", function () {
        it("does not allow to login with wrong credentials", function () {

        });
    });

    xdescribe("when there are more than one user", function () {
        it("allows to login with correct credentials", function () {

        });
    });

});
</code></pre>

<pre><code class="javascript">// spec/FeatureSteps.js
function givenUserExists(email, password, name) {
    expect(Users.exists(email, password)).toEqual(false);

    Users.add(email, password, name);

    expect(Users.exists(email, password)).toEqual(true);
    expect(Users.nameOf(email)).toEqual(name);
}

function givenIAmAtTheLoginPage() {
    var container = document.querySelector("#page");
    expect(container).not.toEqual(null);
    expect(container.innerHTML).toEqual("");

    LoginPage.render();

    var emailInput = container.querySelector("#email");
    expect(emailInput.tagName).toEqual("INPUT");
    expect(emailInput.type).toEqual("email");

    var passwordInput = container.querySelector("#password");
    expect(passwordInput.tagName).toEqual("INPUT");
    expect(passwordInput.type).toEqual("password");

    var loginButton = container.querySelector("#do_login");
    expect(loginButton.tagName).toEqual("BUTTON");
    expect(loginButton.textContent).toEqual("Login");
}

function whenIEnterInTheField(selector, value) {
    var element = document.querySelector(selector);
    expect(element).not.toEqual(null);
    expect(element.value).toEqual("");

    element.value = value;

    var elementAfterChange = document.querySelector(selector);
    expect(element.value).toEqual(value);
}

function whenIClickOn(selector) {
    var element = document.querySelector(selector);
    expect(element).not.toEqual(null);

    element.click();
}

function thenISeeTheProfilePage() {
    // assert login page is gone
    expect(document.querySelector("#email")).toEqual(null);
    expect(document.querySelector("#password")).toEqual(null);
    expect(document.querySelector("#do_login")).toEqual(null);

    // assert profile page is present
    expect(document.querySelector("#page #profile_page")).not.toEqual(null);
    expect(document.querySelector("#profile_page #title")).not.toEqual(null);
}

function thenISeeTextAt(selector, text) {
    var element = document.querySelector(selector);
    expect(element.textContent).toEqual(text);
}
</code></pre>

<pre><code class="javascript">// src/Users.js
var Users = {
    users: [],

    exists: function (email, password) {
        return this.users.length &gt; 0;
    },

    add: function (email, password, name) {
        this.users.push({
            email: email,
            password: password,
            name: name
        });
    },

    nameOf: function (email) {
        return this.users[0].name;
    },

    currentUser: function () {
        return this.users[0];
    }
};
</code></pre>

<pre><code class="javascript">// src/LoginPage.js
var container = document.querySelector("#page");

var LoginPage = {
    render: function () {
        var emailInput = document.createElement("input");
        emailInput.id = "email";
        emailInput.type = "email";
        container.appendChild(emailInput);

        var passwordInput = document.createElement("input");
        passwordInput.id = "password";
        passwordInput.type = "password";
        container.appendChild(passwordInput);

        var loginButton = document.createElement("button");
        loginButton.id = "do_login";
        loginButton.textContent = "Login";
        container.appendChild(loginButton);

        loginButton.addEventListener("click", LoginPage.onLogin);
    },

    onLogin: function () {
        container.innerHTML = "";
        ProfilePage.render();
    }
};
</code></pre>

<pre><code class="javascript">// src/ProfilePage.js
var ProfilePage = {
    render: function () {
        var profileContainer = document.createElement("div");
        profileContainer.id = "profile_page";
        container.appendChild(profileContainer);

        var title = document.createElement("h1");
        title.id = "title";
        title.textContent = Users.currentUser().name;
        profileContainer.appendChild(title);
    }
};
</code></pre>

<p>Now we could add <code>&lt;div id="page"&gt;</code> to our <code>index.html</code>, and load our <code>src/*</code> scripts after it, and add <code>&lt;script&gt;Users.add("john@example.org", "welcome", "John Smith"); LoginPage.render();&lt;/script&gt;</code> at the end to start our application. Enjoy the application that implements one happy path of our feature (we still have quite a few different paths to cover). Also, it might be a good idea to style the application slightly better, than plain inputs and buttons, but we are not going to cover that in these series. This single feature test takes a lot of time to write because it is the first feature test in the empty application. Essentially, it has driven a lot of different architectural decisions, which don&rsquo;t necessary need to be done the way they were done in this article. Writing a second test for the same feature is much easier and third one, and all consecutive are also easier.</p>

<h3>Exercises</h3>

<ol>
<li>Remove <code>x</code> prefix from the <code>xdescribe</code> tests and implement them using techniques described in this article - write a user story scenario, translate it to the test code and make sure to fix all the test failures one feature step at a time.</li>
<li>Discover more interesting edge cases. Make the tests for them and make them all pass.</li>
<li>Write sign-up feature&rsquo;s user story and implement it with feature tests.</li>
</ol>


<h2>Bottom Line</h2>

<p>Today we have learned how to write tests for the whole application that imitate real user interaction. We have seen how, test-driving the functionality can help discovering new user story scenarios. Essentially, every time we write simple, but not so correct code that makes our test pass, we need to think what would be the scenario to prove that code wrong and add that scenario on our to-do list, which is represented by pending tests, which have only their descriptions.</p>

<p>In the next article of the series, we will dig deeper on what exactly we did today, what it means to Test-Drive the code, what are the laws, rules, tips and tricks of Test-Driven Development. Next article of the series assumes, that login and sign-up features are fully test-driven and implemented. We will be implementing a brand new feature of our application.</p>

<h2>Thanks</h2>

<p>Thank you for reading, my dear reader. If you liked it, please share this article on social networks and follow me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you have any questions or feedback for me, don’t hesitate to reach me out on Twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Legacy Code Using Explorative Test-Driven Development Technique]]></title>
    <link href="http://www.tddfellow.com/blog/2016/12/05/understanding-legacy-code-using-explorative-test-driven-development-technique/"/>
    <updated>2016-12-05T23:23:36+01:00</updated>
    <id>http://www.tddfellow.com/blog/2016/12/05/understanding-legacy-code-using-explorative-test-driven-development-technique</id>
    <content type="html"><![CDATA[<p>Today we are going to learn how to eliminate the fear of changing legacy code. We will learn how to confidently and in small iterations understand the legacy code better while increasing the test coverage in the process. While code examples are in Ruby programming language, the technique applied is language-agnostic.</p>

<!-- more -->


<p>For this article, we will need to define what Legacy Code means.</p>

<h2>Legacy Code</h2>

<p>Legacy code is challenging to understand when reading. Such code has no or close to no tests. Also, any legacy code brings the value to the business and customers.</p>

<p>Let&rsquo;s give an outline of what we will be going through today:</p>

<ul>
<li>We will define &ldquo;Knowledge&rdquo; and &ldquo;Mutation&rdquo; concepts in the context of the production code.</li>
<li>We will take a look into the relation between the production system and its test suite. While the connection from test suite to the production system is simple, the reverse connection is subtle and have some unusual and unexpected properties.</li>
<li>We will dismantle different test coverage metrics and outline the most valuable and useful one.</li>
<li>We will explore existing technique called Mutational Testing, that is simple to apply to the untested code to increase its test coverage.</li>
<li>We will introduce the technique called Explorative Test-Driven Development, that is an improvement of Mutational Testing method, which allows us to increase understanding of the legacy code in small steps - confidently and incrementally.</li>
<li>We will look at the example legacy code and apply Explorative TDD to it.</li>
<li>We will see the opportunities to use Explorative TDD technique outside the context of the Legacy Code.</li>
</ul>


<p>Shall we get the ball rolling?</p>

<h2>Knowledge in Production Code</h2>

<p>&ldquo;Knowledge in Production Code&rdquo; is any small bit of functionality that represents any part of the business rule or underlying infrastructure rule. Example bits of knowledge in production code:</p>

<ul>
<li>a variable assignment (or binding): <code>a_variable = ...</code>,</li>
<li>the presence of the <code>if</code> statement: <code>if ... end</code>,</li>
<li>an <code>if</code> condition: <code>if has_certain_property()</code>,</li>
<li>an <code>if</code> body: <code>if ...  do_something_interesting  end</code>,</li>
<li>the presence of the <code>else</code> clause: <code>if ... else ... end</code>,</li>
<li>an <code>else</code> body: <code>if ... else  do_something_different  end</code>,</li>
<li>function (or method) call: <code>a_function(arguments)</code>, <code>receiver.a_method(arguments)</code>,</li>
<li>every argument of the function (or method) call (including receiver),</li>
<li>a constant: <code>42</code>,</li>
<li>the fact that function (or method) returns early: <code>if ...  return 42  end</code>,</li>
<li>what the function (or method) returns,</li>
<li>the presence of the iteration: <code>...each do |x| ... end</code>,</li>
<li>what we iterate through: <code>list.each do ...</code>,</li>
<li>and how we are iterating: <code>...each do |x|  do_something_with(x)  end</code>,</li>
<li>and so on.</li>
</ul>


<p>I think the idea &ldquo;Knowledge in Production Code&rdquo; should be more or less precise. More interesting is what we can do with knowledge in our system: we can re-organize knowledge differently keeping all the behaviors of the system - everyone calls this Refactoring nowadays; or do the opposite: change bits of knowledge without modifying the structure of the code - we will call one such change a Mutation:</p>

<h2>Mutation</h2>

<p>Mutation - granular change of the knowledge in the system that changes the behavior of the application. Let&rsquo;s take a look at the simple example:</p>

<pre><code class="ruby">if cell_is_alive
  do_this
else
  do_some_other_thing
end
</code></pre>

<p>This code is maybe a part of some cell organism simulation (like Game Of Life or similar). Let&rsquo;s see which different mutations can be applied here:</p>

<ul>
<li>change the <code>if</code> condition always to be <code>true</code>: <code>if true ...</code>,</li>
<li>change the <code>if</code> condition always to be <code>false</code>: <code>if false ...</code>,</li>
<li>invert the <code>if</code> condition: <code>if !cell_is_alive</code>,</li>
<li>commenting out the <code>if</code> body: <code># do_this</code>,</li>
<li>commenting out the <code>else</code> body: <code># do_some_other_thing</code>.</li>
</ul>


<p>With that done, let&rsquo;s take a look at how production code and its test suite relate to each other.</p>

<h2>Code and Test Suite Relationship</h2>

<p>So, how does the test suite affect production code? First, it makes sure the production code is correct. Also, good test suite enables quick and ruthless refactoring by eliminating (or minimizing) the risks of breaking it. Well-crafted test suite gives us the power and courage to introduce changes. Also, test code always couples to the production code it is testing in one way or another.</p>

<p>Okay, how does the production system affect its test suite? As tests couple to the production code they test, the changes in production system may cause ripple effects on its test suite. Practically speaking, a mutation should always lead to a test failure if the test suite is good enough because its test suite should verify every tiny bit of knowledge in the production code (except, maybe, some configuration).</p>

<p>Such knowledge change is an act of assertion about the presence of the test. When information is covered by test suite well, there should be a test failure. If, after the introduction of the mutation, there is no test failure, this is a failed assertion about test presence or correctness. So one might say:</p>

<blockquote><p>Knowledge Change is a Test for the Test</p></blockquote>

<p>That is a fascinating idea since it implies we can use production code can as a test suite for its test suite, which may enable TDD-like iterative development of the test suite that does not exist.</p>

<p>So far, we have covered the idea of knowledge in the production code, explored ways of modifying this information in a way that changes the behavior - we call it a mutation, and also we explored the mirror-like relation between production code and its test suite. We have still much ground to cover, let&rsquo;s dive in:</p>

<h2>Most Useful Coverage Metric</h2>

<p>There is a few well-known test coverage metrics that are being used quite often by software engineering teams, such as:</p>

<ul>
<li>Line coverage, and</li>
<li>Branch coverage.</li>
</ul>


<p>There is another one, called Path coverage - it is about coverage of all possible code paths in the system, which quickly becomes impractical as the application size grows because of the exponential growth of the amount of these different code paths.</p>

<p>Line coverage and Branch coverage (also, path coverage) all share one major problem - covered line/branch/path does not mean test suite verifies it - only executes it. Great example: remove all the assertions from your tests and the coverage metric will stay the same.</p>

<p>So, what if we could introduce all possible and sane mutations to our code and count how much of them cause test failure? - We will get the knowledge coverage metric. Another name for it is Test Semantic Stability, and it can range from 0% to 100%. Even 100% line/path coverage can easily yield 0% Test Semantic Stability. This metric proves that code is, indeed well-tested and verified (although, it does not say anything about tests&#8217; design and cleanliness): make one assertion incorrect, or not precise enough and the metric will go down by a few mutations.</p>

<p>That makes Test Semantic Stability the most useful coverage metric.</p>

<p>So, how do we check if our test(s) cover well some bit of knowledge in the system? We break it! - Introduce a tiny granular breaking change to that bit of knowledge. The test suite should fail. If it does not - information is not covered well enough. That leads us to the technique that allows us to keep Semantic Test Stability up high:</p>

<h2>Mutational Testing</h2>

<ol>
<li>Narrow the scope of work to a single granular piece of knowledge.</li>
<li>Break this knowledge (introduce simple granular breaking change - mutation).</li>
<li>Make sure there is a test suite failure.</li>
<li>Restore the knowledge to its original state (CTRL+Z, ideally).</li>
</ol>


<p>Let&rsquo;s see it in action:</p>

<pre><code class="ruby">if cell_is_alive
  do_this
else
  do_some_other_thing
end
</code></pre>

<p>First, we need to narrow our scope to a single bit of knowledge. For example, the <code>if</code> condition: <code>if cell_is_alive</code>. Then we need to introduce the mutation <code>if true,</code> and we need to make sure that there is a test failure. Let&rsquo;s run the test suite:</p>

<pre><code>$ rake test
....

Finished in 0.02343 seconds (files took 0.11584 seconds to load)
4 examples, 0 failures
</code></pre>

<p>Oh no! It did not fail anywhere! That means that we have a &ldquo;failing test&rdquo; for our test suite. In this case, we need to add the test for the negative case:</p>

<pre><code class="ruby">cell_is_alive = false
expect(did_some_other_thing).to eq(true)
</code></pre>

<p>When we run the test suite:</p>

<pre><code>$ rake test
....F

Finished in 0.02343 seconds (files took 0.11584 seconds to load)
5 examples, 1 failure
</code></pre>

<p>It fails! Great - that means that our test for the test suite is passing now. As the last step of this mutational testing iteration we have to return the code to its original state:</p>

<pre><code class="ruby">if cell_is_alive
  do_this
else
  do_some_other_thing
end
</code></pre>

<p>After doing this, our tests should pass!:</p>

<pre><code>$ rake test
.....

Finished in 0.02343 seconds (files took 0.11584 seconds to load)
5 examples, 0 failures
</code></pre>

<p>They do. That concludes one iteration of the mutational testing. Usually, to accomplish any useful behavior we would like to combine many bits of knowledge. If we want to understand better how the system works, we need to focus on groups of bits of knowledge. This is what Explorative TDD technique is about:</p>

<h2>Explorative Test-Driven Development</h2>

<p>The technique used to increase our understanding of the Legacy Code while enhancing its Test Semantic Stability (the most useful coverage metric). The process roughly looks like that:</p>

<ol>
<li>Narrow scope to some manageable knowledge and isolate it (manageable knowledge = method/function/class/module).</li>
<li>Read, try to understand, pick a granular piece of knowledge, and make an assumption to which behavior it contributes and how.</li>
<li>Write a test to verify this assumption.</li>
<li>Make sure test passes (by altering the assumption or fixing production code (bugs)). PS: be careful with bugs, since they might be weird behaviors that are bringing someone tremendous value. When finding one of these, consult with stakeholders if that is a bug or a feature.</li>
<li>Apply Mutational Testing to each related granular piece of knowledge to verify that the understanding (and the test) is correct (this may introduce more tests).</li>
<li>Go back to 2</li>
</ol>


<p>At this point, a nice example would help understand that technique:</p>

<h2>Step-by-Step Example</h2>

<p>Let&rsquo;s imagine that we have some legacy system, that is a social network and allows for users to receive notifications on things that happened. You need to change slightly what &ldquo;Followed&rdquo; notification means. The code looks like this, and it does not have any tests:</p>

<pre><code class="ruby">class User
  def notifications
    notifications = Database
      .where("notifications") do |x|
        (x[1][0] == "followed_notification" &amp;&amp; x[1][2] == id.to_s) ||
        (x[1][0] == "favorited_notification" &amp;&amp; StatusUpdate.find(x[1][2].to_i).owner_id == id) ||
        (x[1][0] == "replied_notification" &amp;&amp; StatusUpdate.find(x[1][2].to_i).owner_id == id) ||
        (x[1][0] == "reposted_notification" &amp;&amp; StatusUpdate.find(x[1][2].to_i).owner_id == id)
      end.map do |row|
        id, values = row
        kind = values[0]

        if kind == "followed_notification"
          {
            kind: kind,
            follower: User.find(values[1].to_i),
            user: User.find(values[2].to_i),
          }
        elsif kind == "favorited_notification"
          {
            kind: kind,
            favoriter: User.find(values[1].to_i),
            status_update: StatusUpdate.find(values[2].to_i),
          }
        elsif kind == "replied_notification"
          {
            kind: kind,
            sender: User.find(values[1].to_i),
            status_update: StatusUpdate.find(values[2].to_i),
            reply: StatusUpdate.find(values[3].to_i),
          }
        elsif kind == "reposted_notification"
          {
            kind: kind,
            reposter: User.find(values[1].to_i),
            status_update: StatusUpdate.find(values[2].to_i),
          }
        end
      end

    Analytics.tag({name: "fetch_notifications", count: notifications.count})
    notifications
  end
end
</code></pre>

<h3>Narrow &amp; Isolate</h3>

<p>The first step is to isolate this code and make it testable. For this we need to find a low-risk way to refactor all dependencies that this code has:</p>

<ul>
<li><code>Database.where</code>,</li>
<li><code>StatusUpdate.find</code>,</li>
<li><code>User.find</code>, and</li>
<li><code>Analytics.tag</code>.</li>
</ul>


<p>We can promote these things to the following roles:</p>

<ul>
<li><code>Database.where</code> => <code>@table_reader.where</code>,</li>
<li><code>StatusUpdate.find</code> => <code>@status_update_finder.where</code>,</li>
<li><code>User.find</code> => <code>@user_finder.find</code>, and</li>
<li><code>Analytics.tag</code> => <code>@event_tagger.tag</code>.</li>
</ul>


<p>We should be able to have these default to their original values and also allow to substitute different implementation from the test. Also, it is helpful to pull out this method into the clean environment, where accessing a dependency, without us substituting it - is not possible, for example in a separate code-base, so that we can write a test &ldquo;it works&rdquo; and see what fails. The first failure is, of course, all our referenced classes are missing. Let&rsquo;s define all of them without any implementation and make them fail at runtime if we ever call them from our testing environment:</p>

<pre><code class="ruby">class Database
  def self.where(table_name)
    fail "Database:nope"
  end
end

class Analytics
  def self.tag(event)
    fail "Analytics:nope"
  end
end

class StatusUpdate
  def self.find(id)
    fail "StatusUpdate:nope"
  end
end

class User
  # .. def notifications ..

  def self.find(id)
    fail "User:nope"
  end
end
</code></pre>

<p>In our tests, we need to implement our substitutes. For now, they all should be just simple double/stubs:</p>

<pre><code class="ruby">class FakeTableReader
  def where(table_name, &amp;filter)
    [[nil, ["favorited_notification"]]]
  end
end

class FakeEventTagger
  def tag(event)

  end
end

class FakeUserFinder
  def find(id)
    User.new
  end
end

class FakeStatusUpdateFinder
  def find(id)
    StatusUpdate.new
  end
end
</code></pre>

<p>Then, we should write the simplest test, that sets up the stage and substitutes all the collaborators and runs the function under the test (no assertion, we are just verifying that we indeed replaced everything right):</p>

<pre><code class="ruby">it "works" do
  fake_table_reader = FakeTableReader.new
  fake_event_tagger = FakeEventTagger.new
  fake_user_finder = FakeUserFinder.new
  fake_status_update_finder = FakeStatusUpdateFinder.new

  user = User.new
             .with_table_reader(fake_table_reader)
             .with_event_tagger(fake_event_tagger)
             .with_user_finder(fake_user_finder)
             .with_status_update_finder(fake_status_update_finder)

  user.notifications
end
</code></pre>

<p>Since we have not defined all the <code>with_*</code> methods yet, let&rsquo;s define them now and also define getters for particular instance variables (properties):</p>

<pre><code class="ruby">class User
  # ...

  def table_reader
    @table_reader ||= Database
  end

  def event_tagger
    @event_tagger ||= Analytics
  end

  def user_finder
    @user_finder || User
  end

  def status_update_finder
    @status_update_finder || StatusUpdate
  end

  def with_table_reader(table_reader)
    @table_reader = table_reader
    self
  end

  def with_event_tagger(event_tagger)
    @event_tagger = event_tagger
    self
  end

  def with_user_finder(user_finder)
    @user_finder = user_finder
    self
  end

  def with_status_update_finder(status_update_finder)
    @status_update_finder = status_update_finder
    self
  end
end
</code></pre>

<p>If we run our test, it should fail with <code>RuntimeError: Database:nope</code> in here:</p>

<pre><code class="ruby">def notifications
  notifications = Database            # &lt;&lt;&lt;&lt;&lt;&lt;
    .where("notifications") do |x|
</code></pre>

<p>To fix that, we will need to replace <code>Database</code> with <code>table_reader</code> getter. That will correct the current error, and we will get the next one: <code>RuntimeError User:nope</code>. Following all these failures and replacing direct dependencies with getters we will finally get a Green Bar (passing the test). Our function under the test will look like that:</p>

<pre><code class="ruby">class User
  def notifications
    notifications = table_reader
      .where("notifications") do |x|
        (x[1][0] == "followed_notification" &amp;&amp; x[1][2] == id.to_s) ||
            (x[1][0] == "favorited_notification" &amp;&amp; status_update_finder.find(x[1][2].to_i).owner_id == id) ||
            (x[1][0] == "replied_notification" &amp;&amp; status_update_finder.find(x[1][2].to_i).owner_id == id) ||
            (x[1][0] == "reposted_notification" &amp;&amp; status_update_finder.find(x[1][2].to_i).owner_id == id)
      end.map do |row|
        id, values = row
        kind = values[0]

        if kind == "followed_notification"
          {
              kind: kind,
              follower: user_finder.find(values[1].to_i),
              user: user_finder.find(values[2].to_i),
          }
        elsif kind == "favorited_notification"
          {
              kind: kind,
              favoriter: user_finder.find(values[1].to_i),
              status_update: status_update_finder.find(values[2].to_i),
          }
        elsif kind == "replied_notification"
          {
              kind: kind,
              sender: user_finder.find(values[1].to_i),
              status_update: status_update_finder.find(values[2].to_i),
              reply: status_update_finder.find(values[3].to_i),
          }
        elsif kind == "reposted_notification"
          {
              kind: kind,
              reposter: user_finder.find(values[1].to_i),
              status_update: status_update_finder.find(values[2].to_i),
          }
        end
      end

    event_tagger.tag({name: "fetch_notifications", count: notifications.count})
    notifications
  end

  # ...
end
</code></pre>

<p>Structure and logic of the function did not change at all, but now all the dependencies are injectable and can be used to test it nicely. That concludes the first step - narrow &amp; isolate. Now it is time to select a group of knowledge bits that we would like to cover with tests. Since we want to change how <code>followed_notification</code> is behaving, we might as well start checking there.</p>

<p><div class="v2-subscribe--inline">
  




  


<div class="mc_embed_signup">
  <form action="//tddfellow.us14.list-manage.com/subscribe/post?u=535a10a8c0274c9a7ebac4f34&amp;id=7f9f94015a" method="post" class="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <div class="mc_embed_signup_scroll">
      <h3>Want more articles like this delivered to your inbox?</h3>
      <div class="mc-field-group">
        <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
        <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_535a10a8c0274c9a7ebac4f34_7f9f94015a" tabindex="-1" value=""></div>
        <input type="email" value="" name="EMAIL" class="required email mce-EMAIL" placeholder="Enter your email">
        <input type="submit" value="Subscribe" name="subscribe" class="button mc-embedded-subscribe">
      </div>
      <div class="">
        <em>(we respect your privacy, unsubscribe at any time)</em>
      </div>
    </div>
  </form>
</div>


</div>
</p>

<h3>Trying to Understand &amp; Writing 1st Test</h3>

<p>The group of knowledge bits that are related to <code>followed_notification</code> looks like this:</p>

<pre><code class="ruby">    notifications = table_reader
      .where("notifications") do |x|
        (x[1][0] == "followed_notification" &amp;&amp; x[1][2] == id.to_s) ||
        # ...
      end.map do |row|
        id, values = row
        kind = values[0]

        if kind == "followed_notification"
          {
              kind: kind,
              follower: user_finder.find(values[1].to_i),
              user: user_finder.find(values[2].to_i),
          }
        elsif #...
          # ...
        end
      end

    # ...
    notifications
</code></pre>

<p>Now we want to write a test. At the first thought, something like:</p>

<pre><code class="ruby">it "obtains followed notifications for the user" do
  # first create a user with all fakes (extracted to a helper method)
  user = create_user_with_fakes

  # then instruct our table reader fake to return prepared data
  fake_table_reader
      .insert("notifications",
              [1001, ["followed_notification", 2001, 3001]])

  # and expect that we have exactly one notification
  expect(user.notifications.count).to eq(1)
end

def create_user_with_fakes
  User.new(567)
      .with_table_reader(fake_table_reader)
      .with_event_tagger(fake_event_tagger)
      .with_user_finder(fake_user_finder)
      .with_status_update_finder(fake_status_update_finder)
end

class FakeTableReader
  def insert(table_name, row)
    tables(table_name) &lt;&lt; row
  end

  def tables(table_name)
    @tables ||= {}
    @tables[table_name] ||= []
  end

  def where(table_name, &amp;filter)
    tables(table_name).select(&amp;filter)
  end
end
</code></pre>

<h3>Making It Pass</h3>

<p>This test fails right away - we don&rsquo;t have any notifications. This is strange. Let&rsquo;s take a closer look on the filtering that we are doing:</p>

<pre><code class="ruby">(x[1][0] == "followed_notification" &amp;&amp; x[1][2] == id.to_s) ||
</code></pre>

<p>I believe, we have satisfied the first part of this condition, but not the second one. The user id is not the same as the 3rd element of this row. Let&rsquo;s make them same:</p>

<pre><code class="ruby">fake_table_reader
    .insert("notifications",
            [1001, ["followed_notification", 2001, 567]])
                                               # ^ here ^
</code></pre>

<p>This fails again! This code just keeps proving our assumptions wrong. I think we need to take a careful look at that <code>it.to_s</code>. <code>.to_s</code> is a conversion to string, so the foreign key is stored as a string (who could have thought?). Let&rsquo;s try to make it work:</p>

<pre><code class="ruby">fake_table_reader
    .insert("notifications",
            [1001, ["followed_notification", 2001, "567"]])
                                                # ^ here ^
</code></pre>

<h3>Applying Mutational Testing</h3>

<p>If we run our tests, they pass! Great, now we know that this function is capable of obtaining some followed notifications. Of course, our coverage right now is super small. Let&rsquo;s apply mutational testing to it. We should start from the condition:</p>

<pre><code class="ruby">(x[1][0] == "followed_notification" &amp;&amp; x[1][2] == id.to_s) ||
</code></pre>

<p>First, let&rsquo;s replace the whole thing with <code>false</code>:</p>

<pre><code class="ruby">false ||
</code></pre>

<p>The test fails - mutant does not survive - our tests are covering for this mutation. Let&rsquo;s try another one: replace the whole thing with <code>true</code>:</p>

<pre><code class="ruby">true ||
</code></pre>

<p>Our tests pass - mutant survives - this is a failing test for our tests. In this case, it is reasonable to write a new test for a case, when the full filtering expression should yield <code>false</code> - when we have notifications of an invalid kind:</p>

<pre><code class="ruby">it "ignores notifications of an invalid kind" do
  user = create_user_with_fakes

  fake_table_reader
      .insert("notifications",
              [1001, ["invalid", 2001, "567"]])

  expect(user.notifications.count).to eq(0)
end
</code></pre>

<p>As a result, we should not get any notifications. After running, we see that our test fail. Great! This mutant no longer survives. Let&rsquo;s see if our tests will pass when we undo the mutation:</p>

<pre><code class="ruby">(x[1][0] == "followed_notification" &amp;&amp; x[1][2] == id.to_s) ||
</code></pre>

<p>And they all pass! Next mutation is inverting the whole condition:</p>

<pre><code class="ruby">! (x[1][0] == "followed_notification" &amp;&amp; x[1][2] == id.to_s) ||
</code></pre>

<p>All our tests are RED. Which means that this mutant does not survive and the test for our test is green. Now, we should dig deeper into the parts of the condition itself:</p>

<ul>
<li><code>x[1][0] == "followed_notification"</code>: replacing with <code>true</code>, <code>false</code>, and inverting it; also, changing numeric and string constants; These all changes did not produce any surviving mutants, so we do not need to introduce new tests.</li>
<li><code>x[1][2] == id.to_s</code>: replacing with <code>true</code>, <code>false</code> and inverting it; also, changing numeric constants.</li>
</ul>


<p>Replacing <code>x[1][2] == id.to_s</code> with <code>true</code>, apparently, leaves all our tests passing - a mutant that survives - a failing test for our test suite. It is time to add this test - when we have notifications of some different user:</p>

<pre><code class="ruby">it "ignores notifications of different user" do
  user = create_user_with_fakes

  fake_table_reader
      .insert("notifications",
              [1001, ["followed_notification", 2001, "other user"]])
                                                   # ^   here   ^

  expect(user.notifications.count).to eq(0)
end
</code></pre>

<p>As you can see, having a record with the different user id (in this case, even nonsensical user id) makes our test fail, which means that this mutant no longer survives. Let&rsquo;s see if undoing the mutation will turn our tests GREEN:</p>

<pre><code class="ruby">(... &amp;&amp; x[1][2] == id.to_s) ||
</code></pre>

<p>All our tests pass again. I think we have finished testing the condition in the filter. I would not touch the conditions that are related to different kinds of notifications, as we want to introduce changes only to &ldquo;Followed&rdquo; notifications. So we can dig further into the logic of our group of knowledge bits:</p>

<pre><code class="ruby">id, values = row
kind = values[0]

if kind == "followed_notification"
  {
      kind: kind,
      follower: user_finder.find(values[1].to_i),
      user: user_finder.find(values[2].to_i),
  }
elsif #...
  # ...
end
</code></pre>

<p>So, we can see that we split the row into its <code>id</code> and all the other values of the notification record. Apparently, the first value is responsible for the kind, where we are switching on it to construct correct object (in this case just a lump of data - hash map). So let&rsquo;s try to mutate the numeric constant in <code>kind = values[0]</code>:</p>

<pre><code class="ruby">kind = values[1]
          #  ^^^
</code></pre>

<p>All our tests still pass. That is a failing test for our test suite. We ought to write a new test now. Where we should verify that it constructs correct lumps of data:</p>

<pre><code class="ruby">it "constructs correct followed notification" do
  user = create_user_with_fakes

  fake_table_reader
      .insert("notifications",
              [1001, ["followed_notification", 2001, "567"]])

  expect(user.notifications[0][:kind]).to eq("followed_notification")
end
</code></pre>

<p>This test fails, because our <code>user.notifications[0]</code> Is <code>nil</code>, because none of <code>if</code> or <code>elsif</code> matched the <code>kind</code> variable and in Ruby, by default any function returns a <code>nil</code> value. This failing test means that we no longer have surviving mutant and let&rsquo;s see if undoing that mutation will make our tests pass:</p>

<pre><code class="ruby">kind = values[0]
          #  ^^^
</code></pre>

<p>It does, all our tests are green now. We should continue like this until we understand code enough and have enough confidence in our tests so that we can make our desired change to the system. When we think we have finished, we should integrate isolated code back to the legacy system, leaving all the fakes and injection capabilities in place. We were separating this code only to make sure, that we are not calling any dependencies on accident (while they just work silently). While integrating it back we, of course, get rid of <code>fail "NAME:nope"</code> implementations of collaborators. With such approach, integrating the code back should be as simple as copy-pasting the test suite code and production code (function under the test, and injecting facilities) without copying always-failing collaborators.</p>

<p>We will have to wrap up the example, and if you, my reader, would like to continue applying Explorative TDD to this code, you can find the code here: <a href="https://github.com/waterlink/explorative-tdd-blog-post">https://github.com/waterlink/explorative-tdd-blog-post</a> (specifically, <code>spec/user_spec.rb</code>). The function originates from this example project: <a href="https://github.com/waterlink/lemon">https://github.com/waterlink/lemon</a></p>

<h2>Can Explorative TDD Help Me Outside of Legacy Code?</h2>

<p>The answer is yes! I use Explorative TDD (as well as mutational testing) in following cases:</p>

<ul>
<li>During big refactorings, such as Extract class/module/package. The technique helps you quickly understand which tests have to be moved as well to the new test suite (only if you want to transfer them).</li>
<li>When refactoring tests. The technique helps you to verify if your tests are still working as they are intended to and if they are still semantically stable (they catch a majority of mutants).</li>
<li>To measure rigidity of test-to-code coupling. If a single mutation leads to half of your test suite failing (even irrelevant tests) - tests need refactoring.</li>
</ul>


<h2>Bottom Line</h2>

<p>Today we have learned about concepts like &ldquo;Knowledge in production code&rdquo; and &ldquo;Mutation.&rdquo; Also, we learned what Test Semantic Stability is the best code coverage metric. We have seen Mutational Testing and Explorative TDD techniques at work. We could start applying these techniques (after some practice) to stop fearing the legacy code and just handle it as some tedious routine operation.</p>

<h2>Thanks</h2>

<p>Thank you for reading, my dear reader. If you liked it, please share this article on social networks and follow me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you have any questions or feedback for me, don’t hesitate to reach me out on Twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Build Your Own Testing Framework. Part 5]]></title>
    <link href="http://www.tddfellow.com/blog/2016/11/13/build-your-own-testing-framework-part-5/"/>
    <updated>2016-11-13T12:50:51+01:00</updated>
    <id>http://www.tddfellow.com/blog/2016/11/13/build-your-own-testing-framework-part-5</id>
    <content type="html"><![CDATA[<p>Welcome back to the new issue of &ldquo;Build Your Own Testing Framework&rdquo; series! Did you notice, that out testing framework quits on the first failure? It probably should run all tests, collect all failures and present them nicely. This is what we are going to accomplish today:</p>

<ul>
<li>Make sure all tests run even when there is a failure.</li>
<li>Make sure exit code is correct.</li>
</ul>


<!-- more -->


<p>This article is the fifth one of the series “Build Your Own Testing Framework” so make sure to stick around for next parts! Find all posts of these series can <a href="/blog/categories/build-your-own-testing-framework/">here</a>.</p>

<p>Shall we get started?</p>

<h2>Catch and report a test failure</h2>

<p>Our test suite should no longer bubble up any exceptions. We can achieve that by making an appropriate assertion. And also we should verify that other tests execute after the failure:</p>

<pre><code class="javascript">runTestSuite(function FailureTest(t) {
    this.testItDoesNotBubbleUpExceptions = function () {
        var aSpy = t.spy();

        t.assertNotThrow(function () {
            runTestSuite(function (t) {
                this.testFailure = function () {
                    t.assertTrue(false);
                };

                this.testSomething = aSpy;
            });
        });

        aSpy.assertCalled();
    };
});
</code></pre>

<p>As expected, this fails with an appropriate error <code>Error: Expected not to throw error, but thrown 'Expected to be true, but got false'</code> indicating that we are bubbling up all errors at the moment. Also, notice how the execution of the whole test suite stops at that point, and it just exits the program with error code <code>1</code>. A simple <code>try .. catch</code> block will fix the issue:</p>

<pre><code class="javascript">// in runTestSuite function
    for (var testName in testSuitePrototype) {
        if (testName.match(/^test/)) {
            reporter.reportTest(testName);
            var testSuite = createTestSuite(testSuiteConstructor);

            try {
                testSuite[testName]();
            } catch (error) {
                // do nothing, for now
            }
        }
    }
</code></pre>

<p>All tests now run successfully. This code is starting to become unreadable, so it is a good point to refactor. We will:</p>

<ul>
<li>Extract whole <code>try .. catch</code> as a function <code>runTest</code>. Its current responsibility is only to run the test and ignore any failure;</li>
<li>Extract contents of <code>if</code> statement that matches the test name as a function <code>handleTest</code>. Its responsibility is to report the test, create a fresh testSuite and kick off <code>runTest</code>;</li>
<li>Extract the whole <code>for</code> statement as <code>runAllTests</code>.</li>
</ul>


<p>Here is the final snippet of code:</p>

<pre><code class="javascript">function runTest(testSuite, testName) {
    try {
        testSuite[testName]();
    } catch (error) {
        // do nothing, for now
    }
}

function handleTest(reporter, testName, testSuiteConstructor) {
    reporter.reportTest(testName);
    runTest(createTestSuite(testSuiteConstructor), testName);
}

function runAllTests(reporter, testSuitePrototype, testSuiteConstructor) {
    for (var testName in testSuitePrototype) {
        if (testName.match(/^test/)) {
            handleTest(reporter, testName, testSuiteConstructor);
        }
    }
}

function runTestSuite(testSuiteConstructor, options) {
    options = options || {};
    var reporter = options.reporter || new SimpleReporter();

    var testSuitePrototype = createTestSuite(testSuiteConstructor);

    reporter.reportTestSuite(
        getTestSuiteName(testSuiteConstructor, testSuitePrototype)
    );

    runAllTests(reporter, testSuitePrototype, testSuiteConstructor);
}
</code></pre>

<h2>Exit with code 1</h2>

<p>Now, when at least one test fails in a suite of tests, the whole suite should fail (after running the rest of its tests). And the indicator of such failure should be an exit code of the process. Let&rsquo;s write a test:</p>

<pre><code class="javascript">runTestSuite(function FailureTest(t) {
    // ...

    this.testItExitsWithProcessCodeOne = function () {
        var processSpy = new ProcessSpy();

        runTestSuite(function (t) {
            this.testFailure = function () {
                t.assertTrue(false);
            };
        }, {process: processSpy});

        t.assertEqual(1, processSpy.hasExitedWithCode);
    };
});
</code></pre>

<p>As you might guess, we will need another object. It will be responsible for interaction with our process, i.e.: something that we can ask to &ldquo;exit with code 1.&rdquo; Because we can not ask our process to exit within the test run, we will have to create a spy. And we shall test-drive its functionality. There is something interesting that we should worry about before that - our test suite is passing currently.. but it shouldn&rsquo;t be!</p>

<p>Let&rsquo;s step back and think what just happened: clearly, we are writing the test, that can not possibly pass because we do not have <code>ProcessSpy</code> yet. So we are expecting a failure - we are expecting a thrown exception. That expectation is an important part of test-driven development: at all times we expect a very specific failure or we expect our tests to pass; if we do not receive a failure when expected and receive an unexpected failure, we should stop right there and think which part of our thinking and our assumptions is incorrect.</p>

<p><div class="v2-subscribe--inline">
  
  
  
  
  

<div class="mc_embed_signup">
  <form action="//tddfellow.us14.list-manage.com/subscribe/post?u=535a10a8c0274c9a7ebac4f34&amp;id=6b61a409a5" method="post" class="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <div class="mc_embed_signup_scroll">
      <h3>Would You Like to Watch a Screencast with Me Implementing This?</h3>
      <div class="mc-field-group">
        <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
        <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_535a10a8c0274c9a7ebac4f34_6b61a409a5" tabindex="-1" value=""></div>
        <input type="email" value="" name="EMAIL" class="required email mce-EMAIL" placeholder="Enter your email">
        <input type="submit" value="Claim video" name="subscribe" class="button mc-embedded-subscribe">
      </div>
      <div class="">
        <em>(we respect your privacy, unsubscribe at any time)</em>
      </div>
    </div>
  </form>
</div>

</div>
</p>

<p>Right now, tests do not fail, because we are ignoring all exceptions in our <code>try .. catch</code> that we introduced a couple of minutes ago. If we want to see failures again, let&rsquo;s modify <code>catch</code> block to just log all errors it receives:</p>

<pre><code class="javascript">function runTest(testSuite, testName) {
    try {
        testSuite[testName]();
    } catch (error) {
        console.log(error);
    }
}
</code></pre>

<p>Now our test suite outputs an expected error: <code>ReferenceError: ProcessSpy is not defined</code>. Also, it outputs some other failures that happen in our nested <code>runTestSuite</code> calls - we should fix them by providing <code>silenceFailures</code> option for nested <code>runTestSuite</code> call. We can focus now on the <code>ProcessSpy</code> failure and test-drive it:</p>

<pre><code class="javascript">runTestSuite(function ProcessSpy_BehaviorTest(t) {
    var processSpy = new ProcessSpy();
});
// =&gt; ReferenceError: ProcessSpy is not defined

function ProcessSpy() {}
// =&gt; PASS

    this.testHasExitedWithCode_initiallyIsNull = function () {
        t.assertEqual(null, processSpy.hasExitedWithCode);
    };
// =&gt; Error: Expected to equal null, but got: undefined

function ProcessSpy() {
    this.hasExitedWithCode = null;
}
// =&gt; PASS

    this.testHasExitedWithCode_isZero_afterExitZeroCall = function () {
        processSpy.exit(0);
        t.assertEqual(0, processSpy.hasExitedWithCode);
    };
// =&gt; TypeError: processSpy.exit is not a function

// in ProcessSpy
    this.exit = function (code) {
        this.hasExitedWithCode = 0;
    };
// =&gt; PASS

    this.testHasExitedWithCode_isOne_afterExitOneCall = function () {
        processSpy.exit(1);
        t.assertEqual(1, processSpy.hasExitedWithCode);
    };
// =&gt; Error: Expected to equal 1, but got: 0

// in ProcessSpy
    this.exit = function (code) {
        this.hasExitedWithCode = code;
        // changed 0 to code      ^here^
    };
</code></pre>

<p>I think we have finished test-driving the functionality of <code>ProcessSpy</code>. It is time to get back to our failing test for a failure resulting in an exit with code 1. When we run this test suite, we are getting the following error message: <code>Error: Expected to equal 1, but got: null</code>.&lsquo; To pass this test, we will need to store the fact that we had a failure somewhere and at the end of the test suite run we can trigger exit with code 1 or 0, respectively. We could pass around a <code>status</code> object with boolean property <code>status.failed</code> and set it to <code>true</code> in our <code>catch</code> block:</p>

<pre><code class="javascript">    } catch (error) {
        if (!silenceFailures) console.log(error);
        status.failed = true;
    }
</code></pre>

<p>And at the end of <code>runTestSuite</code> function we could call <code>process.exit(1)</code> if <code>status.failed</code> was <code>true</code>:</p>

<pre><code class="javascript">function runTestSuite(testSuiteConstructor, options) {
    // ...

    if (status.failed) {
        process.exit(1);
    }
}
</code></pre>

<p>While this works (as in &ldquo;tests pass after providing <code>fakeProcess</code> where needed for nested failing <code>runTestSuite</code> calls&rdquo;) state changes in this code are starting to be hard to follow and function signatures remind me of some horror movie:</p>

<pre><code class="javascript">function getTestSuiteName(testSuiteConstructor, testSuitePrototype)
function runTest(testSuite, testName, silenceFailures, status)
function handleTest(reporter, testName, testSuiteConstructor, silenceFailures, status)
function runAllTests(reporter, testSuitePrototype, testSuiteConstructor, silenceFailures, status)
</code></pre>

<p>These signatures smell like objects are hiding there in these functions. Let&rsquo;s find them!</p>

<h2>Quest for hidden objects</h2>

<p>First, let&rsquo;s extract the method object from the function <code>runTestSuite</code>. We will give it a name <code>TestSuiteRunContext</code>:</p>

<pre><code class="javascript">function TestSuiteRunContext(testSuiteConstructor, options) {
    options = options || {};
    var reporter = options.reporter || new SimpleReporter();
    var process = options.process || global.process;
    var silenceFailures = options.silenceFailures || false;

    var status = {failed: false};

    var testSuitePrototype = createTestSuite(testSuiteConstructor);

    this.invoke = function () {
        reporter.reportTestSuite(
            getTestSuiteName(testSuiteConstructor, testSuitePrototype)
        );

        runAllTests(
            reporter,
            testSuitePrototype,
            testSuiteConstructor,
            silenceFailures,
            status
        );

        if (status.failed) {
            process.exit(1);
        }
    };
}

function runTestSuite(testSuiteConstructor, options) {
    new TestSuiteRunContext(testSuiteConstructor, options).invoke();
}
</code></pre>

<p>Now, if we were to move function <code>runAllTests</code> inside of this class, we would not need all these arguments (and all other functions we call):</p>

<pre><code class="javascript">    this.invoke = function () {
        reportTestSuite();
        runAllTests();
        finishTestRun();
    };

    function reportTestSuite() {
        reporter.reportTestSuite(getTestSuiteName());
    }

    function getTestSuiteName() {
        if (typeof(createTestSuite().getTestSuiteName) !== "function") {
            return testSuiteConstructor.name;
        }

        return createTestSuite().getTestSuiteName();
    }

    function createTestSuite() {
        return new testSuiteConstructor(assertions);
    }

    function runAllTests() {
        for (var testName in createTestSuite()) {
            if (testName.match(/^test/)) {
                handleTest(testName);
            }
        }
    }

    function handleTest(testName) {
        reportTest(testName);
        runTest(createTestSuite(), testName);
    }

    function reportTest(testName) {
        reporter.reportTest(testName);
    }

    function runTest(testSuite, testName) {
        try {
            testSuite[testName]();
        } catch (error) {
            if (!silenceFailures) console.log(error);
            status.failed = true;
        }
    }

    function finishTestRun() {
        if (status.failed) {
            process.exit(1);
        }
    }
</code></pre>

<p>It already looks very nice. The only thing that I do not like about this object yet is that it has stateful properties and stateless properties. I like to have my objects separated by this concern. Let&rsquo;s extract <code>status</code> mutable property as a proper <code>TestSuiteRunStatus</code> object:</p>

<pre><code class="javascript">function TestSuiteRunStatus() {
    var failed = false;

    this.markAsFailed = function () {
        failed = true;
    };

    this.hasFailed = function () {
        return failed;
    };
}

function TestSuiteRunContext(testSuiteConstructor, options) {
  // ...
  var status = new TestSuiteRunStatus();

  // ...
  function runTest(testSuite, testName) {
        try {
            testSuite[testName]();
        } catch (error) {
            if (!silenceFailures) console.log(error);
            status.markAsFailed();
        }
    }

    function finishTestRun() {
        if (status.hasFailed()) {
            process.exit(1);
        }
    }
}
</code></pre>

<p>I think we have finished the refactoring. Now we should verify that test suite exits with the code 0 when everything passes:</p>

<pre><code class="javascript">    this.testItExitsWithProcessCodeZero_onSuccess = function () {
        runTestSuite(function (t) {
            this.testFailure = function () {
                t.assertTrue(true);
            };
        }, {process: processSpy, silenceFailures: true});

        t.assertEqual(0, processSpy.hasExitedWithCode);
    };
// =&gt; Error: Expected to equal 0, but got: null

    function finishTestRun() {
        if (status.hasFailed()) return process.exit(1);
        process.exit(0);
    }
// =&gt; PASS
</code></pre>

<h2>Bottom Line</h2>

<p>I think we have finished implementing exit code reporting. The code can be found here: <a href="https://github.com/waterlink/BuildYourOwnTestingFrameworkPart5">https://github.com/waterlink/BuildYourOwnTestingFrameworkPart5</a></p>

<p>There is still a lot to go through. In a few next episodes we will:</p>

<ul>
<li>Report OK and FAIL for each test;</li>
<li>Output carefully formatted failures to the STDERR;</li>
<li>Enable our testing framework to run multiple test suite files at once;</li>
<li>Enable our testing framework to run in a browser (it is javascript after all).</li>
</ul>


<p>Stay tuned!</p>

<h2>Thanks</h2>

<p>Thank you for reading, my dear reader. If you liked it, please share this article on social networks and follow me on Twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you have any questions or feedback for me, don’t hesitate to reach me out on Twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Do More With Baby-Steps TDD]]></title>
    <link href="http://www.tddfellow.com/blog/2016/10/19/do-more-with-baby-steps-tdd/"/>
    <updated>2016-10-19T23:15:12+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/10/19/do-more-with-baby-steps-tdd</id>
    <content type="html"><![CDATA[<p>Hello everyone! I&rsquo;m usually advocating for the Baby-Steps Test-Driven Development with Triangulation. On the first encounter, this technique seems very verbose and everybody wonders how can it possibly work and why I am very productive with it. Let me tell you about that. First, let&rsquo;s quickly recap both techniques:</p>

<!--more-->


<h2>Baby-Steps TDD</h2>

<p>In Baby-Steps TDD the basic strategy is to get to the green state ASAP. If you can pass all tests with <code>return 42</code>, you should! While the benefit of the approach is not directly obvious exploring the alternative shows its value. One possible alternative is to write a bunch of tests for the software and then make them all pass. This results in a lot of changes made to the software under the test while tests are failing (are in red state). This provides very slow feedback and high risks because with every decision in the code complexity grows exponentially and problems are hard to find when you only know that software worked 1 hour ago and there is one mistake in a whole 1 hour worth of work. The same effect can be seen if the most complex test is written first so that it forces the engineer to implement the whole solution or big part of it in one go.</p>

<p>Baby-Steps TDD mitigates the issue by ensuring everything worked one or two minutes ago. At least to the extent the software is specified by currently written tests. So if something does not work as expected it is most probably a mistake in these last 2-3 lines of code that we have written. And we can even discard them entirely with &ldquo;undo&rdquo; command and start over from the green state without losing much work and saving a whole lot of time debugging.</p>

<p>Baby-Steps TDD provides faster feedback and fewer risks for the cost of a bit more overall effort. Let&rsquo;s take a look into the triangulation technique:</p>

<p><div class="v2-subscribe--inline">
  





<div class="mc_embed_signup">
  <form action="//tddfellow.us14.list-manage.com/subscribe/post?u=535a10a8c0274c9a7ebac4f34&amp;id=7f9f94015a" method="post" class="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <div class="mc_embed_signup_scroll">
      <h3>Want more articles like this delivered to your inbox?</h3>
      <div class="mc-field-group">
        <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
        <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_535a10a8c0274c9a7ebac4f34_7f9f94015a" tabindex="-1" value=""></div>
        <input type="email" value="" name="EMAIL" class="required email mce-EMAIL" placeholder="Enter your email">
        <input type="submit" value="Subscribe" name="subscribe" class="button mc-embedded-subscribe">
      </div>
      <div class="">
        <em>(we respect your privacy, unsubscribe at any time)</em>
      </div>
    </div>
  </form>
</div>


</div>
</p>

<h2>Triangulation Technique</h2>

<p>In essence, Triangulation Technique takes ideas of Baby-Steps TDD further and reduces step size even further. For example, when usually with Baby-Steps TDD you would need one test to introduce the correct <code>if</code> statement, with Triangulation Technique and Baby-Steps TDD combined you would use multiple tests for this:</p>

<ul>
<li>The first test for the most degenerated case which requires one to write a simple <code>return CONSTANT</code> statement to pass:</li>
</ul>


<pre><code class="javascript">return 1
</code></pre>

<ul>
<li>The second test for the same case where the result will be different which requires one to promote <code>CONSTANT</code> to some sort of calculation (variable, formula or function call):</li>
</ul>


<pre><code class="javascript">return n
</code></pre>

<ul>
<li>The third test for the other case which requires one to write a specific <code>if (argument == SPECIFIC_VALUE)</code> with another <code>return ANOTHER_CONSTANT</code>:</li>
</ul>


<pre><code class="javascript">if (n == 7)
  return 42

return n
</code></pre>

<ul>
<li>The fourth test for the same case where the result will be different which requires one to promote <code>ANOTHER_CONSTANT</code> to some sort of calculation (variable, formula or function call):</li>
</ul>


<pre><code class="javascript">if (n == 7)
  return m * 6

return n
</code></pre>

<ul>
<li>The fifth test for the same case where the condition has to be different which requires one to promote specific condition to the proper one:</li>
</ul>


<pre><code class="javascript">if (n &gt;= 7)
  return m * 6

return n
</code></pre>

<p>In normal Baby-Steps TDD that would probably have been only 2 or 3 test cases. With Triangulation it is 5 and to make every one of them pass requires a simple transformation of the production code.</p>

<p>Now let&rsquo;s see why these techniques combined make me more productive.</p>

<h2>Willpower Depletion</h2>

<p>Did you know that every decision you make costs you some willpower? For example: choosing what to wear in the morning, refusing to eat this tasty cake or to make a design choice in your code. This phenomenon is known as Ego Depletion (<a href="https://en.wikipedia.org/wiki/Ego_depletion">see in wiki</a>) and it has an experimental evidence. According to this phenomenon self-control and willpower both draw upon a limited pool of mental resources and it can be used up. Usually, these resources are recovered greatly during good night&rsquo;s sleep or slightly after consuming food. Cost per each made decision differs also and even for the same kind of decision can depend on various factors:</p>

<ul>
<li>perceived complexity of the problem,</li>
<li>mood, physical state and perceived fatigue of the person (tired, angry, confused, happy, energized, etc.),</li>
<li>required effort to make and execute the decision,</li>
<li>blood glucose levels.</li>
</ul>


<p>Baby-Steps TDD combined with Triangulation technique optimize for &ldquo;perceived complexity of the problem&rdquo; so that every decision is nearly obvious to make and the effort required to make it and execute on it is stupidly small. While this increases the amount of decisions that I need to make it also decreases the complexity and willpower cost of each decision to the point, where after completing the same amount of work I still have plenty of energy and willpower to make any other decisions at work and outside of it.</p>

<p>It is worth noting that these techniques need to be practiced quite a bit to enable this effect - with such incremental design it is important to <a href="/blog/2016/08/30/getting-stuck-while-doing-tdd-part-1-example/">avoid getting stuck</a>. Definitely, try it out and see if it works for you!</p>

<h2>Thanks</h2>

<p>Thank you for reading, my dear reader. If you liked it, please share this article on social networks and follow me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you have any questions or feedback for me, don&rsquo;t hesitate to reach me out on Twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<h2>Acknowledgements</h2>

<p>Thanks to David Völkel for the great presentation about Baby-Steps TDD. Slides can be found <a href="http://www.slideshare.net/davidvoelkel/baby-steps-tdd-approaches">here</a>.</p>

<p>Thanks to Stephen Guise for the great book &ldquo;Mini Habits&rdquo; that has opened my eyes to the reasons why I like these techniques so much and why I love designing software in tiny increments.</p>

<p><a target="_blank"  href="https://www.amazon.com/gp/product/1494882272/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1494882272&linkCode=as2&tag=tddfellow-20&linkId=acc11b87f4487fb0e318cc49d8d8302d"><img border="0" src="//ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&MarketPlace=US&ASIN=1494882272&ServiceVersion=20070822&ID=AsinImage&WS=1&Format=_SL250_&tag=tddfellow-20" ></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Build Your Own Testing Framework. Part 4]]></title>
    <link href="http://www.tddfellow.com/blog/2016/09/17/build-your-own-testing-framework-part-4/"/>
    <updated>2016-09-17T10:00:32+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/09/17/build-your-own-testing-framework-part-4</id>
    <content type="html"><![CDATA[<p>Welcome back to the new issue of &ldquo;Build Your Own Testing Framework&rdquo; series! As you might have noticed, currently, our testing framework only outputs failures and nothing else. It is impossible to know if it actually runs any tests when they all pass because there is no output. Today we will implement a simple reporter for our testing framework. It will report the name of the test suite and names of the tests that are being executed, for example:</p>

<pre><code>SpyTest
    testIsNotCalledInitially
    testAssertNotCalledFailsWhenWasCalled
    testIsCalledAfterBeingCalled
    testAssertCalledFailsWhenWasNotCalled
</code></pre>

<p>This article is the fourth one of the series &ldquo;Build Your Own Testing Framework&rdquo;, so make sure to stick around for next parts! All articles of these series can be found <a href="/blog/categories/build-your-own-testing-framework/">here</a>.</p>

<p>Shall we get started?</p>

<!--more-->


<h2>Render the name of the test suite</h2>

<p>So where should the name of the test suite come from? Probably it should be a test suite class name. Currently, all of them are anonymous classes and therefore don&rsquo;t have a name:</p>

<pre><code class="javascript">runTestSuite(function () {
  //         ^          ^
  //       - no name here -
  // ...
});
</code></pre>

<p>We would like all test suites to have that name, for example:</p>

<pre><code class="javascript">runTestSuite(function SpyTest() {
  //                 ^       ^
  //            - here is the name -
  // ...
});
</code></pre>

<p>We should write a test for this case:</p>

<ol>
<li>Create a test suite with the name</li>
<li>Run the test suite with function <code>runTestSuite</code></li>
<li>Assert that the test suite name is reported</li>
</ol>


<p>Let&rsquo;s try to write a test in a <code>RunTestSuiteTest.js</code> test suite for that:</p>

<pre><code class="javascript">this.testItOutputsNameOfTheTest = function () {
  runTestSuite(function TestSuiteName(t) {});

  // TODO: assert that the test suite name is reported
};
</code></pre>

<p>Now it is problematic: how are we going to assert that something is reported? Should we replace <code>console.log(message)</code> or <code>process.stdout.write(message)</code> with our own implementation, so that we can test it?:</p>

<pre><code class="javascript">var logged = "";
var oldConsoleLog = console.log;

console.log = function (message) {
  logged = logged + message + "\n";
};
</code></pre>

<p>And then we should be able to assert with: <code>t.assertTrue(logged.indexOf("TestSuiteName") &gt;= 0)</code>. Finally we will need to restore the old <code>console.log</code> function:</p>

<pre><code class="javascript">this.testItOutputsNameOfTheTest = function () {
  var logged = "";
  var oldConsoleLog = console.log;

  console.log = function (message) {
    logged = logged + message + "\n";
  };

  runTestSuite(function TestSuiteName(t) {});

  t.assertTrue(logged.indexOf("TestSuiteName" &gt;= 0));

  console.log = oldConsoleLog;
};
</code></pre>

<p>While this code works, it has multitude of problems:</p>

<ul>
<li>If the test fails then <code>oldConsoleLog</code> function is not restored;</li>
<li>It has too much setup (which we could extract as a function);</li>
<li>It has teardown (which would be nice to avoid if we could);</li>
<li>It is hard to read because from 8 lines of code only 2 are delivering the core intent;</li>
<li>And it is testing how exactly test suite name is being reported, which is basically a View-like concern.</li>
</ul>


<p>And fixing the last problem will actually fix everything else because this problem causes others. We can fix it by introducing some sort of <code>Reporter</code> type, that can respond to <code>reportTestSuite(name)</code> message:</p>

<pre><code class="javascript">this.testItOutputsNameOfTheTest = function () {
  runTestSuite(function TestSuiteName(t) {
  }, {reporter: reporter});

  t.assertTrue(reporter.hasReportedTestSuite("TestSuiteName"));
  // or even better:
  reporter.assertHasReportedTestSuite("TestSuiteName");
};
</code></pre>

<p><code>reporter</code> in this case is some sort of test double. And what are they? - Find out here: <a href="/blog/2016/09/18/introducing-test-doubles/">Introducing Test Doubles</a>.</p>

<h2>Implementing the reporter spy</h2>

<p>So our <code>reporter</code> object in the test seems terribly like a Spy Double to me, let&rsquo;s test-drive it:</p>

<pre><code class="javascript">// test/ReporterSpyTest.js
var runTestSuite = require("../src/TestingFramework");
var ReporterSpy = require("./ReporterSpy");

runTestSuite(function ReporterSpy_BehaviorTest(t) {
  var reporter = new ReporterSpy(t);

  // Let's write our first test:
  this.testAssertHasReportedTestSuite_whenFailing = function () {
    t.assertThrow(
      "Expected test suite 'HelloWorld' to be reported",
      function () {
        reporter.assertHasReportedTestSuite("HelloWorld");
      }
    );
  };
});

// Error: Cannot find module './ReporterSpy'

// Create file test/ReporterSpy.js
</code></pre>

<p>Now we are getting the following error:</p>

<pre><code>//     var reporter = new ReporterSpy(t);
//                    ^
//
// TypeError: ReporterSpy is not a function
</code></pre>

<p>We need to create ReporterSpy object now:</p>

<pre><code class="javascript">module.exports = function ReporterSpy(assertions) {

};
</code></pre>

<p>Now we are getting:</p>

<pre><code>// Error: Expected to equal
//   Expected test suite 'HelloWorld' to be reported,
// but got:
//   reporter.assertHasReportedTestSuite is not a function
</code></pre>

<p>Now we need to create a function <code>assertHasReportedTestSuite(name)</code> for out <code>ReporterSpy</code>:</p>

<pre><code class="javascript">this.assertHasReportedTestSuite = function (expectedName) {
  assertions.assertTrue(
    false,
    "Expected test suite 'HelloWorld' to be reported"
  );
};
</code></pre>

<p>Next we need to make sure, that <code>expectedName</code> is actually present in the error message by triangulating with different name:</p>

<pre><code class="javascript">this.testAssertHasReportedTestSuite_whenFailing_withOtherName = function () {
  t.assertThrow("Expected test suite 'OtherTestSuite' to be reported", function () {
    reporter.assertHasReportedTestSuite("OtherTestSuite");
  });
};

// Error: Expected to equal
//   Expected test suite 'OtherTestSuite' to be reported,
// but got:
//   Expected test suite 'HelloWorld' to be reported

// And we need to change the respective string:
"Expected test suite '" + expectedName + "' to be reported"
</code></pre>

<p>Then we need to make sure that we do succeed when the message is received:</p>

<pre><code class="javascript">this.testAssertHasReportedTestSuite_whenSucceeding = function () {
  t.assertNotThrow(function () {
    reporter.reportTestSuite("HelloWorld");
    reporter.assertHasReportedTestSuite("HelloWorld");
  });
};

// Error:
//   Expected not to throw error,
// but thrown
//   'reporter.reportTestSuite is not a function'

// So we need to define this function in ReporterSpy:
this.reportTestSuite = function (name) {

};

// Error:
//   Expected not to throw error,
// but thrown
//   'Expected test suite 'HelloWorld' to be reported'

// Now we need to provide the simplest implementation we can,
// we can do that by introducing the boolean variable:

module.exports = function ReporterSpy(assertions) {
  // initially nothing is reported
  var hasReported = false;

  this.assertHasReportedTestSuite = function (expectedName) {
    assertions.assertTrue(
      // we should fail only when nothing was reported
      hasReported,
      "Expected test suite '" + expectedName + "' to be reported"
    );
  };

  this.reportTestSuite = function (name) {
    // and we mark it as reported when we do receive the message
    hasReported = true;
  };
};
</code></pre>

<p>And all our tests pass. Now, when the wrong name is getting reported we should still fail:</p>

<pre><code class="javascript">this.testAssertHasReportedTestSuite_whenReporting_andFailing = function () {
  t.assertThrow("Expected test suite 'HelloWorld' to be reported", function () {
    reporter.reportTestSuite("OtherTestSuite");
    reporter.assertHasReportedTestSuite("HelloWorld");
  });
};

// Error: Expected to throw an error,
// but nothing was thrown

// Now we need to actually store the name of reported test suite:

module.exports = function ReporterSpy(assertions) {
  // initially, we didn't receive any reports
  var testSuiteName = null;

  this.assertHasReportedTestSuite = function (expectedName) {
    assertions.assertTrue(
      // we fail only if received testSuiteName is not right
      testSuiteName === "HelloWorld",
      "Expected test suite '" + expectedName + "' to be reported"
    );
  };

  this.reportTestSuite = function (name) {
    // and we need to store the reported name
    testSuiteName = name;
  };
};
</code></pre>

<p>And all tests pass again. Although, we should notice this weird condition:</p>

<pre><code class="javascript">testSuiteName === "HelloWorld"
</code></pre>

<p>Looks like our current production code is not generic enough, it will work well only with the <code>expectedName</code> equal to <code>"HelloWorld"</code>. Let&rsquo;s fix that by triangulating over this parameter:</p>

<pre><code class="javascript">this.testAssertHasReportedTestSuite_whenReporting_andFailingWithDifferentName = function () {
  t.assertThrow("Expected test suite 'OtherTestSuite' to be reported", function () {
    reporter.reportTestSuite("HelloWorld");
    reporter.assertHasReportedTestSuite("OtherTestSuite");
  });
};

// Error: Expected to throw an error,
// but nothing was thrown

// And we should fix it by actually using the `expectedName`:

assertions.assertTrue(
  testSuiteName === expectedName,
  //               ^ fixed here ^
  "Expected test suite '" + expectedName + "' to be reported"
);
</code></pre>

<p>And all the tests pass. Now we can get back to our failing test for the <code>runTestSuite</code>:</p>

<h2>Implementing rendering of the name of the test suite</h2>

<pre><code class="javascript">this.testItOutputsNameOfTheTest = function () {
  runTestSuite(function TestSuiteName(t) {
  }, {reporter: reporter});

  reporter.assertHasReportedTestSuite("TestSuiteName");
};
</code></pre>

<p>To implement this, first we will need to accept <code>options</code> parameter with sane defaults:</p>

<pre><code class="javascript">function runTestSuite(testSuiteConstructor, options) {
  options = options || {};
  var reporter = options.reporter || new SimpleReporter();

  // ...
}

// We have to implement this, otherwise our test suite will fail
function SimpleReporter() {
    this.reportTestSuite = function (name) {
        process.stdout.write("\n" + name + "\n");
    };
}
</code></pre>

<p>After making the failing test pass and triangulating over the name of the test suite:</p>

<pre><code class="javascript">function runTestSuite(testSuiteConstructor, options) {
  options = options || {};
  var reporter = options.reporter || new SimpleReporter();

  reporter.reportTestSuite(testSuiteConstructor.name)

  // ...
}
</code></pre>

<p>And all tests pass now. Unfortunately, this is the output that we see now:</p>

<pre><code></code></pre>

<p>Yeah, empty lines. This is because <code>(function () {}).name</code> is equal to <code>""</code>. We need to give proper names to all our anonymous constructors for the test suites:</p>

<pre><code class="javascript">runTestSuite(function RunTestSuiteTest(t) { ... });
runTestSuite(function AssertEqualTest(t) { ... });
// .. and so on ..
</code></pre>

<p>And now we should see the correct output:</p>

<pre><code>AssertEqualTest

AssertNotEqualTest

AssertNotThrowTest

AssertThrowTest

AssertTrueTest

FizzBuzzKataTest

.. and so on ..
</code></pre>

<p>Great, now we would like to render the name of the executed test:</p>

<h2>Render the name of the executed test</h2>

<pre><code class="javascript">this.testItOutputsNameOfTheTest = function () {
  runTestSuite(function TestSuiteName(t) {
    this.testSomeTestName = function () {};
    this.testSomeOtherTestName = function () {};
  }, {reporter: reporter});

  reporter.assertHasReportedTestSuite("TestSuiteName");
  reporter.assertHasReportedTest("testSomeTestName");
  reporter.assertHasReportedTest("testSomeOtherTestName");
};
</code></pre>

<p>Of course this fails, because we need to implement <code>assertHasReportedTest(name)</code> now for our <code>ReporterSpy</code>. Let&rsquo;s test-drive it:</p>

<pre><code class="javascript">// test/ReporterSpyTest.js
this.testAssertHasReportedTest_whenFailing = function () {
  t.assertThrow("Expected test 'testName' to be reported", function () {
    reporter.assertHasReportedTest("testName");
  });
};

// Error: Expected to equal
//   Expected test 'testName' to be reported,
// but got:
//   reporter.assertHasReportedTest is not a function

// We need to define assertHasReportedTest(name) method:
this.assertHasReportedTest = function (expectedName) {

};

// Error: Expected to throw an error,
// but nothing was thrown

// We need to make it throw the expected error:
this.assertHasReportedTest = function (expectedName) {
  assertions.assertTrue(
    false,
    "Expected test 'testName' to be reported"
  );
};

// And the test passes. Message hard-codes `testName` -
// we should triangulate over it:

this.testAssertHasReportedTest_whenFailing_withDifferentName = function () {
  t.assertThrow("Expected test 'testDifferentName' to be reported", function () {
    reporter.assertHasReportedTest("testDifferentName");
  });
};

// Error: Expected to equal
//   Expected test 'testDifferentName' to be reported,
// but got:
//   Expected test 'testName' to be reported

// And to fix it:
"Expected test '" + expectedName + "' to be reported"

// Next test will force us to implement simple reportTest function:
this.testAssertHasReportedTest_whenSucceeding = function () {
  t.assertNotThrow(function () {
    reporter.reportTest("testName");
    reporter.assertHasReportedTest("testName");
  });
};

// Error: reporter.reportTest is not a function

// After fixing this and triangulating a bit, we get:

module.exports = function ReporterSpy(assertions) {
  var testName = null;
  // ...
  this.assertHasReportedTest = function (expectedName) {
    assertions.assertTrue(
      testName === expectedName,
      "Expected test '" + expectedName + "' to be reported"
    );
  };
  this.reportTest = function (name) {
    testName = name;
  };
}

// Finally we need ability to report multiple tests:

this.testAssertHasReportedTest_whenSucceeding_withMultipleReports = function () {
  t.assertNotThrow(function () {
    reporter.reportTest("testName");
    reporter.reportTest("testOtherName");
    reporter.assertHasReportedTest("testName");
  });
};

// Error: Expected not to throw error,
// but thrown 'Expected test 'testName' to be reported'

// And to implement this:
module.exports = function ReporterSpy(assertions) {
  // we will store all reported names,
  // initially no names are reported
  var testNames = [];
  // ...
  this.assertHasReportedTest = function (expectedName) {
    assertions.assertTrue(
      // check if expectedName was reported
      testNames.indexOf(expectedName) &gt;= 0,
      "Expected test '" + expectedName + "' to be reported"
    );
  };
  this.reportTest = function (name) {
    // store the reported test name
    testNames.push(name);
  };
}
</code></pre>

<p>Unfortunately, this does not pass our tests, because this test fails now:</p>

<pre><code class="javascript">this.testAssertHasReportedTest_whenReporting_andFailing = function () {
  t.assertThrow("Expected test 'testName' to be reported", function () {
    reporter.reportTest("testOtherName");
    reporter.assertHasReportedTest("testName");
  });
};
</code></pre>

<p>After an investigation, it becomes clear, that this happens because we can not re-use <code>reporter</code> variable defined at the higher level since all tests share the same <code>testSuite</code> object at the moment. We will have to move the creation of the <code>reporter</code> variable inside of each test:</p>

<pre><code class="javascript">this.testAssertHasReportedTest_whenReporting_andFailing = function () {
  var reporter = new ReporterSpy(t);
  // ...
};

this.testAssertHasReportedTest_whenReporting_andFailing_withOtherName = function () {
  var reporter = new ReporterSpy(t);
  // ...
};

// .. and so on ..
</code></pre>

<p>And this makes all our tests pass.</p>

<h2>Stateless tests</h2>

<p>This is quite a noticeable problem, that our users can be frustrated with, so we probably should make it easy on them and allow such variables to be fresh for every test. This can be achieved quite easy if we were to create a new <code>testSuite</code> for each test. Let&rsquo;s write a simple test to show the problem:</p>

<pre><code class="javascript">// test/StatelessTest.js
var runTestSuite = require("../src/TestingFramework");

runTestSuite(function StatelessTest(t) {
  var answer = 41;

  this.testItCanMutateVariable_andImmediatelyUseNewValue = function () {
    answer++;
    t.assertEqual(42, answer);
  };

  this.testItCanMutateVariableAgain_andGetTheSameResult = function () {
    answer++;
    t.assertEqual(42, answer);
  };
  // this fails as expected:
  // Error: Expected to equal 42, but got: 43
});
</code></pre>

<p>And now let&rsquo;s implement it by creating the <code>testSuite</code> for every test:</p>

<pre><code class="javascript">function runTestSuite(testSuiteConstructor, options) {
  options = options || {};
  var reporter = options.reporter || new SimpleReporter();

    reporter.reportTestSuite(testSuiteConstructor.name);

    var testSuitePrototype = createTestSuite(testSuiteConstructor);
    // ^ we change this from `testSuite` to `testSuitePrototype`  ^

  for (var testName in testSuitePrototype) {
    if (testName.match(/^test/)) {
      var testSuite = createTestSuite(testSuiteConstructor);
            // ^   and we create our testSuite every time here   ^
      testSuite[testName]();
    // ^  and run test on it ^
    }
  }
}

function createTestSuite(testSuiteConstructor) {
    return new testSuiteConstructor(assertions);
}
</code></pre>

<p>After doing this, we can move <code>var reporter = new ReporterSpy(t);</code> to the top level of the <code>ReporterSpyTest</code> suite again. And all the tests pass.</p>

<h2>Implementation of the rendering of the test name</h2>

<p>Finally, we need to make sure that the test suite, that we have written before will pass:</p>

<pre><code class="javascript">this.testItOutputsNameOfTheTest = function () {
    runTestSuite(function TestSuiteName(t) {
        this.testSomeTestName = function () {};
        this.testSomeOtherTestName = function () {};
    }, {reporter: reporter});

    reporter.assertHasReportedTestSuite("TestSuiteName");
    reporter.assertHasReportedTest("testSomeTestName");
    reporter.assertHasReportedTest("testSomeOtherTestName");
};
</code></pre>

<p>As expected it fails with <code>Error: Expected test 'testSomeTestName' to be reported</code>. After fixing it and applying triangulation once, we would end up with the following implementation:</p>

<pre><code class="javascript">// src/TestingFramework.js in runTestSuite function:
for (var testName in testSuitePrototype) {
    if (testName.match(/^test/)) {

        reporter.reportTest(testName);
// ^  here is our implementation  ^

        var testSuite = createTestSuite(testSuiteConstructor);
        testSuite[testName]();
    }
}

function SimpleReporter() {
    // ...
    // and we should not forget to implement it for real reporter
  this.reportTest = function (name) {
    process.stdout.write("\t" + name + "\n");
  };
}
</code></pre>

<p>Now, it seems that both <code>ReporterSpy</code> and <code>SimpleReporter</code> are implementing the same Duck type - <code>Reporter</code>. What Duck Type is? - find out here: <a href="/blog/2016/09/18/meet-duck-type/">Meet Duck Type</a>.</p>

<h2>Contract testing all Reporter duck types</h2>

<p>So we should test all our ducks that their public API don&rsquo;t get out of sync:</p>

<pre><code class="javascript">var TestingFramework = require("../src/TestingFramework");
var runTestSuite = TestingFramework;
var SimpleReporter = TestingFramework.SimpleReporter;

var ReporterSpy = require("./ReporterSpy");

const IMPLEMENTATIONS = [
    SimpleReporter,
    ReporterSpy
];

IMPLEMENTATIONS.forEach(function (ReporterImplementation) {
  runTestSuite(function (t) {
    var reporter = new ReporterImplementation();

    this.testDefines_reportTestSuite = function () {
      var reportTestSuite = reporter.reportTestSuite;
      t.assertEqual("function", typeof(reportTestSuite));
      t.assertEqual(1, reportTestSuite.length);
    };

    this.testDefines_reportTest = function () {
      var reportTest = reporter.reportTest;
      t.assertEqual("function", typeof(reportTest));
      t.assertEqual(1, reportTest.length);
    }
  });
});
</code></pre>

<p>All the tests pass. Unfortunately, the output regarding this test suite looks weird:</p>

<pre><code>
    testDefines_reportTestSuite
    testDefines_reportTest


    testDefines_reportTestSuite
    testDefines_reportTest
</code></pre>

<p>The test suite name is empty. I think we need an ability to define a custom and dynamic test suite name:</p>

<h2>Custom name for the test suite</h2>

<p>We can achieve this by allowing any test suite to define special hook method, that will return its custom name, like <code>testSuite.getTestSuiteName()</code>. Let&rsquo;s write a test for this:</p>

<pre><code class="javascript">this.testItCanHaveCustomNameOfTheTestSuite = function () {
  runTestSuite(function (t) {
    this.getTestSuiteName = function () {
      return "CustomNameOfTheTestSuite";
    };
  }, {reporter: reporter});

  reporter.assertHasReportedTestSuite("CustomNameOfTheTestSuite");
};
</code></pre>

<p>After implementing it and triangulating over the name once the code looks like this:</p>

<pre><code class="javascript">function runTestSuite(testSuiteConstructor, options) {
  options = options || {};
  var reporter = options.reporter || new SimpleReporter();

  var testSuitePrototype = createTestSuite(testSuiteConstructor);

  reporter.reportTestSuite(
    getTestSuiteName(testSuiteConstructor, testSuitePrototype)
// ^ this is the function that we introduced here to make it pass ^
  );

    for (var testName in testSuitePrototype) { ... }
}

function getTestSuiteName(testSuiteConstructor, testSuitePrototype) {
    if (typeof(testSuitePrototype.getTestSuiteName) !== "function") {
        return testSuiteConstructor.name;
    }

    return testSuitePrototype.getTestSuiteName();
}
</code></pre>

<p>Now, if we were to use this feature in our duck type tests:</p>

<pre><code class="javascript">IMPLEMENTATIONS.forEach(function (ReporterImplementation) {
  runTestSuite(function (t) {
    this.getTestSuiteName = function () {
      return ReporterImplementation.name + "_ReporterTest";
    };

    // ...
});
</code></pre>

<p>Then we are getting the proper output:</p>

<pre><code>SimpleReporter_ReporterTest
    testDefines_reportTestSuite
    testDefines_reportTest

ReporterSpy_ReporterTest
    testDefines_reportTestSuite
    testDefines_reportTest
</code></pre>

<h2>Bottom Line</h2>

<p>I think we are done with implementing our first simple reporter. Now we can see that the tests are actually executing and passing. The code can be found here: <a href="https://github.com/waterlink/BuildYourOwnTestingFrameworkPart4">https://github.com/waterlink/BuildYourOwnTestingFrameworkPart4</a></p>

<p>There is still a lot to go through. In a few next episodes we will:</p>

<ul>
<li>Make sure that first failure does not cause test suite to stop running;</li>
<li>Make sure the exit code is right;</li>
<li>Report OK and FAIL;</li>
<li>Output carefully formatted failures to the STDERR.</li>
</ul>


<p>Stay tuned!</p>

<h2>Thanks</h2>

<p>Thank you for reading, my dear reader. If you liked it, please share this article on social networks and follow me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you have any questions or feedback for me, don&rsquo;t hesitate to reach me out on Twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>
]]></content>
  </entry>
  
</feed>
