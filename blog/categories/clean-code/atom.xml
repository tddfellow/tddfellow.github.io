<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Clean-code | That TDD Fellow | Tech Blog | Screencasts]]></title>
  <link href="http://www.tddfellow.com/blog/categories/clean-code/atom.xml" rel="self"/>
  <link href="http://www.tddfellow.com/"/>
  <updated>2016-09-29T18:04:55+02:00</updated>
  <id>http://www.tddfellow.com/</id>
  <author>
    <name><![CDATA[Oleksii Fedorov (waterlink)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Eliminating 'if' Statements: Legacy Endpoint Primer]]></title>
    <link href="http://www.tddfellow.com/blog/2016/08/20/eliminating-if-statements-legacy-endpoint-primer/"/>
    <updated>2016-08-20T11:59:37+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/08/20/eliminating-if-statements-legacy-endpoint-primer</id>
    <content type="html"><![CDATA[<p><code>if</code> statements tend to duplicate throughout the code base. This may lead to subtle mistakes and bugs. One way to avoid that problem is to eliminate <code>if</code> statement completely. Today we are going to take a look at one example of such elimination. Code examples today will be in Kotlin.</p>

<h2>Problem at hand</h2>

<ul>
<li>Our API has an endpoint for issuing some sort of <code>verification token</code> given <code>device id</code> and <code>phone number</code> of the user&rsquo;s mobile device.</li>
<li>We need to integrate these <code>verification tokens</code> with 3rd party API.</li>
<li>The format of <code>verification token</code> is fairly standardized.</li>
<li>After initial research, it turned out that <code>issuer</code> field of <code>verification token</code> has to be URL of the API that has issued that token and 3rd party API in question validates this fact.</li>
<li>Currently, <code>issuer</code> field gets generated as <code>com.tddfellow</code>. According to this standard, it has to be <code>https://tddfellow.com</code>.</li>
<li>Additionally, we have to support old versions of mobile clients for next 6 months, that are validating <code>issuer</code> to be <code>com.tddfellow</code>, we can not change them as they are already installed on users&#8217; mobile devices.</li>
</ul>


<p>Solution: bump the version of our API from <code>v1</code> to <code>v2</code> and use <code>v1</code> for integration with old mobile clients and use <code>v2</code> for integration with 3rd party API and all new clients.</p>

<h2>Current Relevant Code</h2>

<p>Main program, containing routing information:</p>

<pre><code class="kotlin">// Main.kt

fun main(args: Array&lt;String&gt;) {
    val secureTokenSource = SimpleSecureTokenSource()
    val verificationTokenGateway = DummyVerificationTokenGateway()

    val issueVerificationTokenUseCase = UseCase(secureTokenSource, verificationTokenGateway)
    val issueVerificationTokenEndpoint = Endpoint(issueVerificationTokenUseCase)

    Spark.get("/api/v1/issueVerificationToken") { request, response -&gt;
        issueVerificationTokenEndpoint.issueVerificationToken(
                deviceId = request.queryParams("deviceId"),
                phoneNumber = request.queryParams("phoneNumber")
        )
    }
}
</code></pre>

<p>Endpoint that issues verification token:</p>

<pre><code class="kotlin">// ApiEndpoints/IssueVerificationToken/Endpoint.kt

class Endpoint(private val useCase: UseCase) {

    fun issueVerificationToken(deviceId: String, phoneNumber: String): IssueVerificationTokenEndpointResponse {
        val issueVerificationToken = useCase.issueVerificationToken(deviceId, phoneNumber)

        return IssueVerificationTokenEndpointResponse(
                issuer = issueVerificationToken.issuer,
                token = issueVerificationToken.secureToken
        )
    }

}
</code></pre>

<p>And the UseCase itself:</p>

<pre><code class="kotlin">// IssueVerificationToken/UseCase.kt

open class UseCase(private val secureTokenSource: SecureTokenSource,
                   private val verificationTokenGateway: VerificationTokenGateway) {

    open fun issueVerificationToken(deviceId: String, phoneNumber: String): VerificationToken {
        val verificationToken = VerificationToken(
                issuer = "com.tddfellow",
                deviceId = deviceId,
                phoneNumber = phoneNumber,
                secureToken = secureTokenSource.generateToken()
        )

        verificationTokenGateway.persist(verificationToken)
        return verificationToken
    }

}
</code></pre>

<p>Code can be found <a href="https://github.com/waterlink/LegacyEndpointPrimer/">here</a>.</p>

<h2>Solution With Awkward <code>if</code> Statement</h2>

<p>Easiest solution using passed in <code>apiVersion</code> from the <code>Main</code> program and switch on it being old or new in the use case to determine which issuer to generate:</p>

<pre><code class="kotlin">// Main.kt

Spark.get("/api/v1/issueVerificationToken") { request, response -&gt;
    issueVerificationTokenEndpoint.issueVerificationToken(
            deviceId = request.queryParams("deviceId"),
            phoneNumber = request.queryParams("phoneNumber"),

            // here we are passing "old" version to the endpoint
            apiVersion = "v1"
    )
}

Spark.get("/api/v2/issueVerificationToken") { request, response -&gt;
    issueVerificationTokenEndpoint.issueVerificationToken(
            deviceId = request.queryParams("deviceId"),
            phoneNumber = request.queryParams("phoneNumber"),

            // here we are passing "new" version to the endpoint
            apiVersion = "v2"
    )
}
</code></pre>

<p>And the endpoint just passes this value through to the use case:</p>

<pre><code class="kotlin">// ApiEndpoints/IssueVerificationToken/Endpoint.kt

fun issueVerificationToken(deviceId: String,
                           phoneNumber: String,
                           apiVersion: String): IssueVerificationTokenEndpointResponse {

    val issueVerificationToken = useCase.issueVerificationToken(
            deviceId = deviceId,
            phoneNumber = phoneNumber,

            // here we are passing API version through
            apiVersion = apiVersion
    )

    return IssueVerificationTokenEndpointResponse(
            issuer = issueVerificationToken.issuer,
            token = issueVerificationToken.secureToken
    )
}
</code></pre>

<p>And finally the <code>if</code> statement in the use case:</p>

<pre><code class="kotlin">// IssueVerificationToken/UseCase.kt

private val OLD_ISSUER = "com.tddfellow"
private val NEW_ISSUER = "https://tddfellow.com"
private val OLD_API_VERSION = "v1"

fun issueVerificationToken(deviceId: String, phoneNumber: String, apiVersion: String): VerificationToken {
    val verificationToken = VerificationToken(
            issuer = getIssuerFor(apiVersion),
            deviceId = deviceId,
            phoneNumber = phoneNumber,
            secureToken = secureTokenSource.generateToken()
    )

    verificationTokenGateway.persist(verificationToken)
    return verificationToken
}

private fun getIssuerFor(apiVersion: String): String {
    if (apiVersion.equals(OLD_API_VERSION)) {
        return OLD_ISSUER
    }
    return NEW_ISSUER
}
</code></pre>

<p>The full code change available <a href="https://github.com/waterlink/LegacyEndpointPrimer/pull/1">here (via open Pull Request)</a>.</p>

<p>This solution has quite a few problems:</p>

<ul>
<li><code>if</code> statement smells a bit</li>
<li>use case probably should not have any knowledge of <code>apiVersion</code>, since APIs is not our domain, it is just a delivery mechanism</li>
</ul>


<p>If we were to pass some object, like <code>TokenIssuer</code>, it would probably be more appropriate to have use case know of it. Let&rsquo;s try to refactor:</p>

<h2>Refactoring <code>if</code> Statement Using Polymorphism</h2>

<p>First, let&rsquo;s start passing in the token issuer in the routing:</p>

<pre><code class="kotlin">// Main.kt

Spark.get("/api/v1/issueVerificationToken") { request, response -&gt;
    issueVerificationTokenEndpoint.issueVerificationToken(
            deviceId = request.queryParams("deviceId"),
            phoneNumber = request.queryParams("phoneNumber"),

            // here we pass a specific object now for old token issuer:
            tokenIssuer = OldTokenIssuer()
    )
}

Spark.get("/api/v2/issueVerificationToken") { request, response -&gt;
    issueVerificationTokenEndpoint.issueVerificationToken(
            deviceId = request.queryParams("deviceId"),
            phoneNumber = request.queryParams("phoneNumber"),

            // here we pass an object that returns URL according to the standard
            tokenIssuer = UrlTokenIssuer()
    )
}
</code></pre>

<p>And this is how <code>TokenIssuer</code> and its derivatives are looking like:</p>

<pre><code class="kotlin">// IssueVerificationToken/TokenIssuer.kt

interface TokenIssuer {

    fun getName(): String

}
</code></pre>

<pre><code class="kotlin">// IssueVerificationToken/OldTokenIssuer.kt

class OldTokenIssuer : TokenIssuer {

    override fun getName() = "com.tddfellow"

}
</code></pre>

<pre><code class="kotlin">// IssueVerificationToken/UrlTokenIssuer.kt

class UrlTokenIssuer : TokenIssuer {

    override fun getName() = "https://tddfellow.com"

}
</code></pre>

<p>As you might guess, endpoint just passes this object through to the use case. And the use case itself just calls <code>getName()</code> on it when generating issuer:</p>

<pre><code class="kotlin">// IssueVerificationToken/UseCase.kt

fun issueVerificationToken(deviceId: String, phoneNumber: String, tokenIssuer: TokenIssuer): VerificationToken {
    val verificationToken = VerificationToken(

            // here is how much simpler it becomes
            issuer = tokenIssuer.getName(),

            deviceId = deviceId,
            phoneNumber = phoneNumber,
            secureToken = secureTokenSource.generateToken()
    )

    verificationTokenGateway.persist(verificationToken)
    return verificationToken
}
</code></pre>

<p>Full code change can be seen <a href="https://github.com/waterlink/LegacyEndpointPrimer/pull/2">here (in the Pull Request)</a>.</p>

<h2>Bottom Line</h2>

<p>This code may be refactored further so that even <code>Endpoint</code> class will not have to know about <code>tokenIssuer</code> and pass it through. I will leave that as an exercise to you, my dear reader.</p>

<p>You would not want to miss next articles on this tech blog, we still have a lot to talk about:</p>

<ul>
<li>Continuous Integration and Continuous Delivery - importance of not impeding others,</li>
<li>Open-Closed Principle - changing behavior by adding new code,</li>
<li>Triangulation technique in Test-Driven Development - overlooking this technique might cause one fail at doing TDD,</li>
<li>Mutational Testing, &ldquo;Build Your Own Testing Framework&rdquo; series, Test-Driven Development screencasts and so much more!</li>
</ul>


<h2>Thanks!</h2>

<p>Thank you for reading, my dear reader. If you liked it, please share this article on social networks and follow me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you have any questions or feedback for me, don&rsquo;t hesitate to reach me out on Twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Parallel Change Refactoring]]></title>
    <link href="http://www.tddfellow.com/blog/2016/07/31/parallel-change-refactoring/"/>
    <updated>2016-07-31T09:57:31+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/07/31/parallel-change-refactoring</id>
    <content type="html"><![CDATA[<p>Parallel Change is the refactoring technique, that allows implementing backward-incompatible changes to an API in a safe manner. It consists of 3 steps:</p>

<ul>
<li>Expand - add new functionality as an extension of the interface (e.g.: add new methods), instead of editing signatures of existing interfaces</li>
<li>Migrate - mark (or log a warning) existing interface as deprecated and give time to the clients of the interface to migrate to the new interface. This might be as simple as changing your own code-base one client of this interface at a time in case when you do not have 3rd party clients of these interfaces</li>
<li>Contract - once all clients have migrated remove old interfaces</li>
</ul>


<p>This technique is tremendously useful when you have 3rd party clients for your API (open-source library, SaaS with REST API, etc). Also, it is as useful for normal application development because it allows such breaking changes to never break your test suite. It allows deploying your code in the middle of the refactoring, in fact, every few minutes (Continuous Integration + Continuous Deployment).</p>

<p>This article contains code examples in a pseudo-code.</p>

<h2><code>UserSearch</code></h2>

<p>Let&rsquo;s imagine, that we have some class, that is used to search <code>User</code> by id:</p>

<pre><code class="swift">class UserSearch {
  func search(id : UserId): [User] {
    // .. we somehow use the database gateway here to search ..
  }
}
</code></pre>

<p>Now, new requirement comes in and it seems, that we need to be able to search by e-mail too, so we have to add more functionality here:</p>

<pre><code class="swift">class UserSearch {
  // ...

  func search_by_email(email : Email): [User] {
    // .. we somehow use the database gateway here to search ..
  }
}
</code></pre>

<p>Later, new requirement comes in and now we need to be able to search by the nickname too. So we follow the pattern:</p>

<pre><code class="swift">class UserSearch {
  // ...

  func search_by_nickname(nickname : Nickname): [User] {
    // .. we somehow use the database gateway here to search ..
  }
}
</code></pre>

<p>This is great and all, but we clearly can see, how this class violates Open-Closed Principle: every time there is a new thing to search the user by, we will have to alter this class. This is not good. One of the possible solutions might be closing this class against this kind of change by introducing polymorphic <code>Query</code>:</p>

<pre><code class="swift">class UserSearch {
  // all other search_* methods were removed

  func search(query : Query): [User] {
    // .. we somehow use the database gateway here to search
  }
}
</code></pre>

<p>After doing that, if we run our test suite, it will be failing, probably, even with compile errors. This is not good because now we have to go through every failure and fix it, this will prevent us from continuously integrating for quite some time (half an hour, or a couple of days, depending on the impact of this change). And this has high chances of resulting in merge conflicts, that will impede work of others on our team.</p>

<p>Instead, let&rsquo;s apply the parallel change.</p>

<h2>Applying Parallel Change</h2>

<h3>Expand</h3>

<p>First, we need to introduce brand new method of our class (of course with unit-tests), without touching anything else:</p>

<pre><code class="swift">class UserSearch {
  // ...

  func search_by_query(query : Query): [User] {
    // .. we somehow use the database gateway here to search
  }
}
</code></pre>

<p>At this point, we are going to deploy this new code.</p>

<h3>Migrate</h3>

<p>Second, we need to add a deprecation warning to old interface, and, in fact, old functions can be rewritten via new one:</p>

<pre><code class="swift">class UserSearch {
  func search(id : UserId): [User] {
    warn("`UserSearch.search` is deprecated. Use `UserSearch.search_by_query` instead")
    search_by_query(UserIdQuery(id))
  }

  func search_by_email(email : Email): [User] {
    warn("`UserSearch.search_by_email` is deprecated. Use `UserSearch.search_by_query` instead")
    search_by_query(UserEmailQuery(email))
  }

  func search_by_nickname(nickname : Nickname): [User] {
    warn("`UserSearch.search_by_nickname` is deprecated. Use `UserSearch.search_by_query` instead")
    search_by_query(UserNicknameQuery(nickname))
  }

  // ...
}
</code></pre>

<p>At this point, we are going to deploy this new code.</p>

<p>Next, we need to:</p>

<ul>
<li>inform all clients of our system about this deprecation and give them time-frame to migrate, or</li>
<li>if all clients of <code>UserSearch</code> are under our control, we need to change all calls to use new interface:</li>
</ul>


<pre><code class="swift">// was: `user_search.search(user_id)`
user_search.search_by_query(UserIdQuery(user_id))
</code></pre>

<p>After every line of change like that (big system probably has a multitude of these) we are going to deploy.</p>

<pre><code class="swift">// was: `user_search.search_by_email(user_email)`
user_search.search_by_query(UserEmailQuery(user_email))
</code></pre>

<p>After every line of change like that we are going to deploy.</p>

<pre><code class="swift">// was: `user_search.search_by_nickname(user_nickname)`
user_search.search_by_query(UserNicknameQuery(user_nickname))
</code></pre>

<p>Of course, after each line we are going to deploy.</p>

<h3>Contract</h3>

<p>Once all our tests pass and there is no single deprecation warning from <code>UserSession</code>, or the time-frame we have given to our 3rd party clients is finished, we can remove old functionality by simply removing deprecated methods (and their unit-tests), and what we will have left is:</p>

<pre><code class="swift">class UserSearch {
  func search_by_query(query : Query): [User] {
    // .. we somehow use the database gateway here to search
  }
}
</code></pre>

<p>Of course, we can deploy our system now.</p>

<h2>Bottom Line</h2>

<p>Notice, how following this technique avoids even a single compile error or test suite failure. And if failure happens, the last small code change (probably one line) was wrong, you just <code>CTRL+Z</code> it to get back to GREEN state.</p>

<p>Was that refactoring necessary? Oh yeah it was, because in next few weeks, there were new requirements that would have forced us to add 2 new <code>search_by_*</code> methods to <code>UserSearch</code> class - instead, we just created new derivatives of <code>Query</code> interface/protocol and used them in the places where they are needed. This way we were able to change how <code>UserSearch</code> class works without modifying its source code, by only adding new code. This is a great win.</p>

<p>You would not want to miss next articles on this tech blog, we still have a lot to talk about:</p>

<ul>
<li>Continuous Integration and Continuous Delivery - importance of not impeding others,</li>
<li>Open-Closed Principle - changing behavior by adding new code,</li>
<li>Triangulation technique in Test-Driven Development - overlooking this technique might cause one fail at doing TDD,</li>
<li>Mutational Testing, &ldquo;Build Your Own Testing Framework&rdquo; series and so much more!</li>
</ul>


<p>Stay tuned!</p>

<h2>Thanks!</h2>

<p>Thank you for reading, my dear reader. If you liked it, please share this article on social networks and follow me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you have any questions or feedback for me, don&rsquo;t hesitate to reach me out on Twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why I Don't Use Mocking Frameworks Anymore]]></title>
    <link href="http://www.tddfellow.com/blog/2016/06/21/why-i-dont-use-mocking-frameworks-anymore/"/>
    <updated>2016-06-21T08:04:10+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/06/21/why-i-dont-use-mocking-frameworks-anymore</id>
    <content type="html"><![CDATA[<p>Some time ago, I have discovered, that using your own custom test double classes, instead of a test framework makes my test code more readable and maintainable. Here is an example (pseudo-code):</p>

<pre><code class="javascript">function test_password_revealer_when_toggled_reveals_password() {
  passwordController = MockPasswordController.new()
  passwordRevealer = PasswordRevealer.new(passwordController)

  passwordRevealer.toggle()

  expect(passwordController.isRevealed()).toBeTrue()
}
</code></pre>

<p>The same test with mocking framework would look this way:</p>

<pre><code class="javascript">function test_password_revealer_when_toggled_reveals_password() {
  passwordController = MockFramework.Mock.new("PasswordController")
  passwordRevealer = PasswordRevealer.new(passwordController)

  spy = spyOn(passwordController.reveal())

  passwordRevealer.toggle()

  expect(spy.haveBeenCalled()).toBeTrue()
}
</code></pre>

<p>If you take a closer look at the last example, and, specifically at these 2 lines:</p>

<pre><code class="javascript">spy = spyOn(passwordController.reveal())

expect(spy.haveBeenCalled()).toBeTrue()
</code></pre>

<p>They use a language, that is not relevant to the domain, therefore, they make the test less readable.</p>

<p>Additionally, they have knowledge of which exactly method <code>PasswordRevealer#toggle()</code> should call on <code>passwordController</code>. If we were to rename <code>reveal</code> method, all tests for <code>PasswordRevealer</code> would fail.
The same thing would happen if we were to extract methods/functions/objects out of the <code>PasswordRevealer</code>.</p>

<p>Of course, creating such test doubles yourself will involve some boilerplate code - this is a trade-off. Example:</p>

<pre><code class="javascript">class MockPasswordController() {
  this.state = "hidden"

  this.reveal() {
    this.state = "revealed"
  }

  this.hide() {
    this.state = "hidden"
  }

  this.isRevealed() {
    return this.state == "revealed"
  }
}
</code></pre>

<p>Making this trade-off, will simplify the case when we were to change the name: we would change the name at 3 places:</p>

<ul>
<li>in test double class,</li>
<li>in caller class,</li>
<li>in &ldquo;real&rdquo; implementation class.</li>
</ul>


<p>Whereas with a mocking framework, we would have to hunt for all failing tests, and usually, it means hundreds of failing tests.</p>

<h2>Thank you!</h2>

<p>If you, my dear reader, have any thoughts, questions or arguments about the topic, feel free to reach out to me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you liked my ideas, follow me on twitter, and, even better, provide me with your honest feedback, so that I can improve.</p>
]]></content>
  </entry>
  
</feed>
