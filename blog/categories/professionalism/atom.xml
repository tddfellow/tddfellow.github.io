<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Professionalism | That TDD Fellow | Tech Blog | Screencasts]]></title>
  <link href="http://www.tddfellow.com/blog/categories/professionalism/atom.xml" rel="self"/>
  <link href="http://www.tddfellow.com/"/>
  <updated>2016-06-19T19:54:16+02:00</updated>
  <id>http://www.tddfellow.com/</id>
  <author>
    <name><![CDATA[Oleksii Fedorov (waterlink)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[TDD as an Enabling Practice or How to Be Faster With TDD]]></title>
    <link href="http://www.tddfellow.com/blog/2016/06/13/tdd-as-an-enabling-practice-or-how-to-be-faster-with-tdd/"/>
    <updated>2016-06-13T07:52:56+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/06/13/tdd-as-an-enabling-practice-or-how-to-be-faster-with-tdd</id>
    <content type="html"><![CDATA[<p>Recently I had a lot of conversations with so many different programmers, with different backgrounds, contexts of work and opinions. What stroke me the most, is that majority feel that TDD is slower than simple automated testing, i.e., <code>TestFirst</code> is slower than <code>TestAfter</code>.</p>

<p>While digging deeper in their context of work, I could only agree with them: &ldquo;True, in that context it will be about 50% slower&rdquo;.</p>

<p>Most of the time, though, the context is somewhat looking like this:</p>

<ul>
<li>We have some company <code>ACME</code>, that does some sort of Agile Software Development (probably Scrum);</li>
<li>The company <code>ACME</code> focuses only on the business parts of Agile Software Development;</li>
<li>The company <code>ACME</code> tried to introduce TDD as a development practice;</li>
<li>Everything took much longer to be done.</li>
</ul>


<h2>Enabling practice</h2>

<p>Now, let us dive into the development practices of Agile Software Development: development practices are usually coming from Extreme Programming (XP). In XP there are 2 terms: <code>EnablingPractice</code> and <code>ExploitativePractice</code>.</p>

<p>Exploitative practice gives direct benefit to the team, e.g.: speed boost and quicker feedback from users and stakeholders.</p>

<p>Enabling practice is required for certain other exploitative practice(s) to work.</p>

<p>A good example of exploitative practice is Continuous Delivery. It requires Continuous Integration, Pair-Programming, and Testing to be in place. These 3 are enabling practices.</p>

<h2>Removing slow practices</h2>

<p>Additionally to allowing usage of practices, that make a team go faster and deliver at the higher quality level, enabling practices allow removal of practices, that make a team go slower. For example, Pair-Programming together with TDD allows removal of code review. On most of the teams (especially, of bigger size), this makes for an instant productivity boost.</p>

<p>Pair-Programming, TDD and Continuous Integration, additionally to enabling the team to do Continuous Delivery, also allows replacing feature-branch VCS flow with a trunk-based flow. This allows for smaller iterations and faster user feedback.</p>

<h2>Pair-Programming Done Right</h2>

<p>It is worth noting, that removal of code review and introducing of Continuous Delivery is only possible, if Pair-Programming is done right:</p>

<ul>
<li>in no case, two beginners should be working in the pair;</li>
<li>beginners should work together with advanced beginners/competents and proficients/experts;</li>
<li>advanced beginners/competents should split their time in half between working with beginners and working with proficient/experts.</li>
</ul>


<p>Terminology <code>Beginner</code>, <code>AdvancedBeginner</code>, <code>Competent</code>, <code>Proficient</code> and <code>Expert</code> is from Dreyfus Skill Acquisition Model.</p>

<p>That allows for a good trust and mentorship models in your team(s). It enables quick growth and knowledge sharing for every member of the team.</p>

<p>There is another enabling practice which speeds up the knowledge sharing, it is Pair Rotation, that should be done from 1 to 2 times per day, so that for small and middle-sized teams, the bigger the feature is, the higher chance, that everyone on the team have participated in its development, and therefore have enough knowledge about it.</p>

<p>Additionally, Pair Rotation allows for Code Detachment and removal of Code Silos. This in turn, together with TDD, enables Ruthless Refactoring, because you are not afraid:</p>

<ul>
<li>to break the code, thanks to TDD,</li>
<li>to upset an owner of the Code Silo, because there is no owner, thanks to Pair Rotation.</li>
</ul>


<h2>Bottomline</h2>

<p>I think I can go on like this forever, but I believe the idea should be clear. I will be following up with more articles in details on each technique in the future. Stay tuned!</p>

<h2>Thank you for reading!</h2>

<p>If you, my dear reader, have any thoughts, questions or arguments about the topic, feel free to reach out to me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you liked my ideas, follow me on twitter, and, even better, provide me with your honest feedback, so that I can improve.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why Are You Slow?]]></title>
    <link href="http://www.tddfellow.com/blog/2016/02/05/why-are-you-slow/"/>
    <updated>2016-02-05T17:09:47+01:00</updated>
    <id>http://www.tddfellow.com/blog/2016/02/05/why-are-you-slow</id>
    <content type="html"><![CDATA[<blockquote><p>We are slow because we have the worst codebase!</p></blockquote>

<h2>So why don&rsquo;t you clean it?</h2>

<blockquote><p>Because we have to go fast!</p></blockquote>

<p>I will let you figure out logical inconsistency there.</p>

<p>Ask yourself a question: how much times in your career you were slowed down by
a horrible, dirty, untested code? It doesn&rsquo;t matter who have written it,
usually, it is already there and already a fact you have to deal with.</p>

<p>If your answer was: &ldquo;Once.. or twice..&rdquo; (and your career is sufficiently long)
- you can freely stop reading this post and simply be a happy developer.</p>

<p>I was slowed down by bad code horrible amount of times. I come to be sick of
it. I don&rsquo;t want to be slow, because I am trying to go fast. I want my tool to
be clean, I want my creations to be manageable, and I don&rsquo;t want to fear the
code, I have created, or anyone else have created. And I want to go fast while
enjoying it!</p>

<p>Trust me, I met lots of developers during my career. Not as much as heroes of
our industry have met, but <strong>enough</strong> to be able to tell you, that <strong>every
single</strong> one of them, who has any reasonable length of the career, had same
problems.</p>

<p>And that is totally not normal. Do you understand, that from the outside world,
we, as an industry, are perceived as very non-professional, because of that?
Business even came to a conclusion, that they can&rsquo;t trust us to deliver working
software - and that is how QA role was born.</p>

<p>I will ask again.</p>

<h2>So why don&rsquo;t you clean it?</h2>

<blockquote><p>My company pays me for features, not for &lt;<em>insert your statement here</em>></p></blockquote>

<p>That is very common response. And, in essence, it is the truth.</p>

<p>OK, now, let&rsquo;s think. As time passes by, after certain threshold on every
codebase, that is not clean, adding next feature costs more time, even if the
features are of roughly the same size. After 1 year of such development,
features can literally become 2-4 times more expensive. Couple of years in, and
it, practically, becomes impossible to develop anything except &ldquo;Change the
color of this button&rdquo; (or provide your own example).</p>

<h2>What does that mean?</h2>

<p>One would say: &ldquo;Features become more expensive over time&rdquo;. Business usually
sees it as: &ldquo;Arrgh, our programmers slower and slower with each month&rdquo;. So from
the business perspective, after <strong>perceived</strong> effectiveness of developers drops
by 2-4 times, why would business be willing to pay these developers the same
salary? You should be afraid of this question.</p>

<h2>Now imagine land of unicorns!</h2>

<p>Now imagine, that you started a bit slower in the beginning (like 8% slower),
but you have kept your effectiveness over time either at roughly same level, or
even have increased it over time. How hard do you think it would be to ask for
a raise, after 2 years of loyal work?</p>

<p>Not hard at all. And probably business will be doing just great (if the
business idea itself was sustainable to begin with, of course), and will be
capable of satisfying the request.</p>

<h2>Why such a thing happens?</h2>

<p>Because at the moment we are not perceived as professionals, nor as experts of
our field. We are perceived as just some coding monkeys, who you always need to
ask: &ldquo;Can this be delivered on Friday&rdquo; with intimidating tone. And we gladly
reply through our teeth: &ldquo;I will try&rdquo;, meaning &ldquo;Just go already&rdquo;; ending up on
Friday evening with: &ldquo;I tried&rdquo; - &ldquo;You have tried not enough!&rdquo;.</p>

<h2>Clean your code already!</h2>

<p>Believe me, investing 15-45 minutes every single day into increasing test code
coverage and some little refactorings will not make you any slower (you
probably already very slow, so that it will not make any perceivable
difference). Rather, over time, you (and your fellow programmers) will start to
actually being bit-by-bit faster, as long as your application (or applications)
get cleaner and cleaner.</p>

<p>It goes without saying, that you should be using proper XP (pair-programming
and TDD) techniques, while writing any new piece of code (read: new class,
module, library, package, etc.). Because it will be extremely easy to unit-test
it with near-100% test coverage. Believe me, that is easy and fun.</p>

<p>Refactoring and covering old and messy parts of an application is not fun,
though. You have to face the truth. Consider it as a chore, like the one you do
to your apartment, when you clean it on a regular basis. And as we all know,
the more you wait to clean an apartment, the harder it would be to do it. And
the function is not linear..</p>

<p>If you have a really big legacy application, you are probably in doing that
sort of thing for 2-3 years, before you can proudly call this application clean
again.</p>

<p>There is one important trick though: prioritize cleaning of parts of
application, that change often. If some part changes once half a year, you
should probably clean it once half a year too.</p>

<h2>You are hired for your expertise!</h2>

<p>Believe me, you do have all the knowledge, required to make it.</p>

<p>The only thing that stops you is your inability to say &ldquo;No&rdquo;, when &ldquo;No&rdquo; is the
correct answer from your experience and expertise point of view.</p>

<h2>Parallel example</h2>

<p>Do you know that surgeon, before any surgery, washes his hands. You not just
know, it is your expectation! In some countries if he doesn&rsquo;t, he can easily
end up in jail.</p>

<h3>Do you know, how surgeon washes his hands?</h3>

<p>He rubs each finger from 4 different sides 10 times. That is stated in Doctors&#8217;
code of ethics. And they have to follow it, since it has power of law.</p>

<p>Why 10 times? Wouldn&rsquo;t 7 be enough, or maybe 14 should be a minimum? It doesn&rsquo;t
matter. It is a discipline, that is to be followed to the letter, and there are
no exceptions.</p>

<p>Well, he probably can rub 11 times, without getting in jail..</p>

<p>Nobody will ever ask surgeon, why he does it. Everyone expects him to do it.</p>

<h2>Back to our universe</h2>

<p>You are surgeons!</p>

<p>You are surgeons, that operate on a heart of the business.</p>

<p>With your wrong move, with your mistake, the whole business can go out of
business overnight.</p>

<p>With your wrong move, with your mistake, thousands of people can die (if you
are in certain domains).</p>

<p>So why increasing a chance of your own mistakes (and everybody else on a team)
by not cleaning the code?</p>

<p>Even if you are not in such critical domain, you are part of industry, and you
should be a great professional, just to be an example for others, who might end
up working in such crucial business domain in the future.</p>

<p>And I know, you can pull it off. And you do know it yourself.</p>

<p>So now go, and be professional, be professional for everyone around you.</p>

<h2>Thanks!</h2>

<p>This article might be a bit too rough - I believe that is the truth we face
now, as an industry. And let us be the ones fixing it!</p>

<p>I recommend reading this: <a href="http://acm.org/about/se-code">Software Engineering Code of Ethics</a>
by ACM organization (originally, created in 1999, why are we all still not
using it?!).</p>
]]></content>
  </entry>
  
</feed>
