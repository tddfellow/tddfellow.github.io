<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Xunit | That TDD Fellow | Tech Blog | Screencasts]]></title>
  <link href="http://www.tddfellow.com/blog/categories/xunit/atom.xml" rel="self"/>
  <link href="http://www.tddfellow.com/"/>
  <updated>2016-09-29T18:04:55+02:00</updated>
  <id>http://www.tddfellow.com/</id>
  <author>
    <name><![CDATA[Oleksii Fedorov (waterlink)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Build Your Own Testing Framework. Part 4]]></title>
    <link href="http://www.tddfellow.com/blog/2016/09/17/build-your-own-testing-framework-part-4/"/>
    <updated>2016-09-17T10:00:32+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/09/17/build-your-own-testing-framework-part-4</id>
    <content type="html"><![CDATA[<p>Welcome back to the new issue of &ldquo;Build Your Own Testing Framework&rdquo; series! As you might have noticed, currently, our testing framework only outputs failures and nothing else. It is impossible to know if it actually runs any tests when they all pass because there is no output. Today we will implement a simple reporter for our testing framework. It will report the name of the test suite and names of the tests that are being executed, for example:</p>

<pre><code>SpyTest
    testIsNotCalledInitially
    testAssertNotCalledFailsWhenWasCalled
    testIsCalledAfterBeingCalled
    testAssertCalledFailsWhenWasNotCalled
</code></pre>

<p>This article is the fourth one of the series &ldquo;Build Your Own Testing Framework&rdquo;, so make sure to stick around for next parts! All articles of these series can be found <a href="/blog/categories/build-your-own-testing-framework/">here</a>.</p>

<p>Shall we get started?</p>

<h2>Render the name of the test suite</h2>

<p>So where should the name of the test suite come from? Probably it should be a test suite class name. Currently, all of them are anonymous classes and therefore don&rsquo;t have a name:</p>

<pre><code class="javascript">runTestSuite(function () {
  //         ^          ^
  //       - no name here -
  // ...
});
</code></pre>

<p>We would like all test suites to have that name, for example:</p>

<pre><code class="javascript">runTestSuite(function SpyTest() {
  //                 ^       ^
  //            - here is the name -
  // ...
});
</code></pre>

<p>We should write a test for this case:</p>

<ol>
<li>Create a test suite with the name</li>
<li>Run the test suite with function <code>runTestSuite</code></li>
<li>Assert that the test suite name is reported</li>
</ol>


<p>Let&rsquo;s try to write a test in a <code>RunTestSuiteTest.js</code> test suite for that:</p>

<pre><code class="javascript">this.testItOutputsNameOfTheTest = function () {
  runTestSuite(function TestSuiteName(t) {});

  // TODO: assert that the test suite name is reported
};
</code></pre>

<p>Now it is problematic: how are we going to assert that something is reported? Should we replace <code>console.log(message)</code> or <code>process.stdout.write(message)</code> with our own implementation, so that we can test it?:</p>

<pre><code class="javascript">var logged = "";
var oldConsoleLog = console.log;

console.log = function (message) {
  logged = logged + message + "\n";
};
</code></pre>

<p>And then we should be able to assert with: <code>t.assertTrue(logged.indexOf("TestSuiteName") &gt;= 0)</code>. Finally we will need to restore the old <code>console.log</code> function:</p>

<pre><code class="javascript">this.testItOutputsNameOfTheTest = function () {
  var logged = "";
  var oldConsoleLog = console.log;

  console.log = function (message) {
    logged = logged + message + "\n";
  };

  runTestSuite(function TestSuiteName(t) {});

  t.assertTrue(logged.indexOf("TestSuiteName" &gt;= 0));

  console.log = oldConsoleLog;
};
</code></pre>

<p>While this code works, it has multitude of problems:</p>

<ul>
<li>If the test fails then <code>oldConsoleLog</code> function is not restored;</li>
<li>It has too much setup (which we could extract as a function);</li>
<li>It has teardown (which would be nice to avoid if we could);</li>
<li>It is hard to read because from 8 lines of code only 2 are delivering the core intent;</li>
<li>And it is testing how exactly test suite name is being reported, which is basically a View-like concern.</li>
</ul>


<p>And fixing the last problem will actually fix everything else because this problem causes others. We can fix it by introducing some sort of <code>Reporter</code> type, that can respond to <code>reportTestSuite(name)</code> message:</p>

<pre><code class="javascript">this.testItOutputsNameOfTheTest = function () {
  runTestSuite(function TestSuiteName(t) {
  }, {reporter: reporter});

  t.assertTrue(reporter.hasReportedTestSuite("TestSuiteName"));
  // or even better:
  reporter.assertHasReportedTestSuite("TestSuiteName");
};
</code></pre>

<p><code>reporter</code> in this case is some sort of test double. And what are they? - Find out here: <a href="/blog/2016/09/18/introducing-test-doubles/">Introducing Test Doubles</a>.</p>

<h2>Implementing the reporter spy</h2>

<p>So our <code>reporter</code> object in the test seems terribly like a Spy Double to me, let&rsquo;s test-drive it:</p>

<pre><code class="javascript">// test/ReporterSpyTest.js
var runTestSuite = require("../src/TestingFramework");
var ReporterSpy = require("./ReporterSpy");

runTestSuite(function ReporterSpy_BehaviorTest(t) {
  var reporter = new ReporterSpy(t);

  // Let's write our first test:
  this.testAssertHasReportedTestSuite_whenFailing = function () {
    t.assertThrow(
      "Expected test suite 'HelloWorld' to be reported",
      function () {
        reporter.assertHasReportedTestSuite("HelloWorld");
      }
    );
  };
});

// Error: Cannot find module './ReporterSpy'

// Create file test/ReporterSpy.js
</code></pre>

<p>Now we are getting the following error:</p>

<pre><code>//     var reporter = new ReporterSpy(t);
//                    ^
//
// TypeError: ReporterSpy is not a function
</code></pre>

<p>We need to create ReporterSpy object now:</p>

<pre><code class="javascript">module.exports = function ReporterSpy(assertions) {

};
</code></pre>

<p>Now we are getting:</p>

<pre><code>// Error: Expected to equal
//   Expected test suite 'HelloWorld' to be reported,
// but got:
//   reporter.assertHasReportedTestSuite is not a function
</code></pre>

<p>Now we need to create a function <code>assertHasReportedTestSuite(name)</code> for out <code>ReporterSpy</code>:</p>

<pre><code class="javascript">this.assertHasReportedTestSuite = function (expectedName) {
  assertions.assertTrue(
    false,
    "Expected test suite 'HelloWorld' to be reported"
  );
};
</code></pre>

<p>Next we need to make sure, that <code>expectedName</code> is actually present in the error message by triangulating with different name:</p>

<pre><code class="javascript">this.testAssertHasReportedTestSuite_whenFailing_withOtherName = function () {
  t.assertThrow("Expected test suite 'OtherTestSuite' to be reported", function () {
    reporter.assertHasReportedTestSuite("OtherTestSuite");
  });
};

// Error: Expected to equal
//   Expected test suite 'OtherTestSuite' to be reported,
// but got:
//   Expected test suite 'HelloWorld' to be reported

// And we need to change the respective string:
"Expected test suite '" + expectedName + "' to be reported"
</code></pre>

<p>Then we need to make sure that we do succeed when the message is received:</p>

<pre><code class="javascript">this.testAssertHasReportedTestSuite_whenSucceeding = function () {
  t.assertNotThrow(function () {
    reporter.reportTestSuite("HelloWorld");
    reporter.assertHasReportedTestSuite("HelloWorld");
  });
};

// Error:
//   Expected not to throw error,
// but thrown
//   'reporter.reportTestSuite is not a function'

// So we need to define this function in ReporterSpy:
this.reportTestSuite = function (name) {

};

// Error:
//   Expected not to throw error,
// but thrown
//   'Expected test suite 'HelloWorld' to be reported'

// Now we need to provide the simplest implementation we can,
// we can do that by introducing the boolean variable:

module.exports = function ReporterSpy(assertions) {
  // initially nothing is reported
  var hasReported = false;

  this.assertHasReportedTestSuite = function (expectedName) {
    assertions.assertTrue(
      // we should fail only when nothing was reported
      hasReported,
      "Expected test suite '" + expectedName + "' to be reported"
    );
  };

  this.reportTestSuite = function (name) {
    // and we mark it as reported when we do receive the message
    hasReported = true;
  };
};
</code></pre>

<p>And all our tests pass. Now, when the wrong name is getting reported we should still fail:</p>

<pre><code class="javascript">this.testAssertHasReportedTestSuite_whenReporting_andFailing = function () {
  t.assertThrow("Expected test suite 'HelloWorld' to be reported", function () {
    reporter.reportTestSuite("OtherTestSuite");
    reporter.assertHasReportedTestSuite("HelloWorld");
  });
};

// Error: Expected to throw an error,
// but nothing was thrown

// Now we need to actually store the name of reported test suite:

module.exports = function ReporterSpy(assertions) {
  // initially, we didn't receive any reports
  var testSuiteName = null;

  this.assertHasReportedTestSuite = function (expectedName) {
    assertions.assertTrue(
      // we fail only if received testSuiteName is not right
      testSuiteName === "HelloWorld",
      "Expected test suite '" + expectedName + "' to be reported"
    );
  };

  this.reportTestSuite = function (name) {
    // and we need to store the reported name
    testSuiteName = name;
  };
};
</code></pre>

<p>And all tests pass again. Although, we should notice this weird condition:</p>

<pre><code class="javascript">testSuiteName === "HelloWorld"
</code></pre>

<p>Looks like our current production code is not generic enough, it will work well only with the <code>expectedName</code> equal to <code>"HelloWorld"</code>. Let&rsquo;s fix that by triangulating over this parameter:</p>

<pre><code class="javascript">this.testAssertHasReportedTestSuite_whenReporting_andFailingWithDifferentName = function () {
  t.assertThrow("Expected test suite 'OtherTestSuite' to be reported", function () {
    reporter.reportTestSuite("HelloWorld");
    reporter.assertHasReportedTestSuite("OtherTestSuite");
  });
};

// Error: Expected to throw an error,
// but nothing was thrown

// And we should fix it by actually using the `expectedName`:

assertions.assertTrue(
  testSuiteName === expectedName,
  //               ^ fixed here ^
  "Expected test suite '" + expectedName + "' to be reported"
);
</code></pre>

<p>And all the tests pass. Now we can get back to our failing test for the <code>runTestSuite</code>:</p>

<h2>Implementing rendering of the name of the test suite</h2>

<pre><code class="javascript">this.testItOutputsNameOfTheTest = function () {
  runTestSuite(function TestSuiteName(t) {
  }, {reporter: reporter});

  reporter.assertHasReportedTestSuite("TestSuiteName");
};
</code></pre>

<p>To implement this, first we will need to accept <code>options</code> parameter with sane defaults:</p>

<pre><code class="javascript">function runTestSuite(testSuiteConstructor, options) {
  options = options || {};
  var reporter = options.reporter || new SimpleReporter();

  // ...
}

// We have to implement this, otherwise our test suite will fail
function SimpleReporter() {
    this.reportTestSuite = function (name) {
        process.stdout.write("\n" + name + "\n");
    };
}
</code></pre>

<p>After making the failing test pass and triangulating over the name of the test suite:</p>

<pre><code class="javascript">function runTestSuite(testSuiteConstructor, options) {
  options = options || {};
  var reporter = options.reporter || new SimpleReporter();

  reporter.reportTestSuite(testSuiteConstructor.name)

  // ...
}
</code></pre>

<p>And all tests pass now. Unfortunately, this is the output that we see now:</p>

<pre><code></code></pre>

<p>Yeah, empty lines. This is because <code>(function () {}).name</code> is equal to <code>""</code>. We need to give proper names to all our anonymous constructors for the test suites:</p>

<pre><code class="javascript">runTestSuite(function RunTestSuiteTest(t) { ... });
runTestSuite(function AssertEqualTest(t) { ... });
// .. and so on ..
</code></pre>

<p>And now we should see the correct output:</p>

<pre><code>AssertEqualTest

AssertNotEqualTest

AssertNotThrowTest

AssertThrowTest

AssertTrueTest

FizzBuzzKataTest

.. and so on ..
</code></pre>

<p>Great, now we would like to render the name of the executed test:</p>

<h2>Render the name of the executed test</h2>

<pre><code class="javascript">this.testItOutputsNameOfTheTest = function () {
  runTestSuite(function TestSuiteName(t) {
    this.testSomeTestName = function () {};
    this.testSomeOtherTestName = function () {};
  }, {reporter: reporter});

  reporter.assertHasReportedTestSuite("TestSuiteName");
  reporter.assertHasReportedTest("testSomeTestName");
  reporter.assertHasReportedTest("testSomeOtherTestName");
};
</code></pre>

<p>Of course this fails, because we need to implement <code>assertHasReportedTest(name)</code> now for our <code>ReporterSpy</code>. Let&rsquo;s test-drive it:</p>

<pre><code class="javascript">// test/ReporterSpyTest.js
this.testAssertHasReportedTest_whenFailing = function () {
  t.assertThrow("Expected test 'testName' to be reported", function () {
    reporter.assertHasReportedTest("testName");
  });
};

// Error: Expected to equal
//   Expected test 'testName' to be reported,
// but got:
//   reporter.assertHasReportedTest is not a function

// We need to define assertHasReportedTest(name) method:
this.assertHasReportedTest = function (expectedName) {

};

// Error: Expected to throw an error,
// but nothing was thrown

// We need to make it throw the expected error:
this.assertHasReportedTest = function (expectedName) {
  assertions.assertTrue(
    false,
    "Expected test 'testName' to be reported"
  );
};

// And the test passes. Message hard-codes `testName` -
// we should triangulate over it:

this.testAssertHasReportedTest_whenFailing_withDifferentName = function () {
  t.assertThrow("Expected test 'testDifferentName' to be reported", function () {
    reporter.assertHasReportedTest("testDifferentName");
  });
};

// Error: Expected to equal
//   Expected test 'testDifferentName' to be reported,
// but got:
//   Expected test 'testName' to be reported

// And to fix it:
"Expected test '" + expectedName + "' to be reported"

// Next test will force us to implement simple reportTest function:
this.testAssertHasReportedTest_whenSucceeding = function () {
  t.assertNotThrow(function () {
    reporter.reportTest("testName");
    reporter.assertHasReportedTest("testName");
  });
};

// Error: reporter.reportTest is not a function

// After fixing this and triangulating a bit, we get:

module.exports = function ReporterSpy(assertions) {
  var testName = null;
  // ...
  this.assertHasReportedTest = function (expectedName) {
    assertions.assertTrue(
      testName === expectedName,
      "Expected test '" + expectedName + "' to be reported"
    );
  };
  this.reportTest = function (name) {
    testName = name;
  };
}

// Finally we need ability to report multiple tests:

this.testAssertHasReportedTest_whenSucceeding_withMultipleReports = function () {
  t.assertNotThrow(function () {
    reporter.reportTest("testName");
    reporter.reportTest("testOtherName");
    reporter.assertHasReportedTest("testName");
  });
};

// Error: Expected not to throw error,
// but thrown 'Expected test 'testName' to be reported'

// And to implement this:
module.exports = function ReporterSpy(assertions) {
  // we will store all reported names,
  // initially no names are reported
  var testNames = [];
  // ...
  this.assertHasReportedTest = function (expectedName) {
    assertions.assertTrue(
      // check if expectedName was reported
      testNames.indexOf(expectedName) &gt;= 0,
      "Expected test '" + expectedName + "' to be reported"
    );
  };
  this.reportTest = function (name) {
    // store the reported test name
    testNames.push(name);
  };
}
</code></pre>

<p>Unfortunately, this does not pass our tests, because this test fails now:</p>

<pre><code class="javascript">this.testAssertHasReportedTest_whenReporting_andFailing = function () {
  t.assertThrow("Expected test 'testName' to be reported", function () {
    reporter.reportTest("testOtherName");
    reporter.assertHasReportedTest("testName");
  });
};
</code></pre>

<p>After an investigation, it becomes clear, that this happens because we can not re-use <code>reporter</code> variable defined at the higher level since all tests share the same <code>testSuite</code> object at the moment. We will have to move the creation of the <code>reporter</code> variable inside of each test:</p>

<pre><code class="javascript">this.testAssertHasReportedTest_whenReporting_andFailing = function () {
  var reporter = new ReporterSpy(t);
  // ...
};

this.testAssertHasReportedTest_whenReporting_andFailing_withOtherName = function () {
  var reporter = new ReporterSpy(t);
  // ...
};

// .. and so on ..
</code></pre>

<p>And this makes all our tests pass.</p>

<h2>Stateless tests</h2>

<p>This is quite a noticeable problem, that our users can be frustrated with, so we probably should make it easy on them and allow such variables to be fresh for every test. This can be achieved quite easy if we were to create a new <code>testSuite</code> for each test. Let&rsquo;s write a simple test to show the problem:</p>

<pre><code class="javascript">// test/StatelessTest.js
var runTestSuite = require("../src/TestingFramework");

runTestSuite(function StatelessTest(t) {
  var answer = 41;

  this.testItCanMutateVariable_andImmediatelyUseNewValue = function () {
    answer++;
    t.assertEqual(42, answer);
  };

  this.testItCanMutateVariableAgain_andGetTheSameResult = function () {
    answer++;
    t.assertEqual(42, answer);
  };
  // this fails as expected:
  // Error: Expected to equal 42, but got: 43
});
</code></pre>

<p>And now let&rsquo;s implement it by creating the <code>testSuite</code> for every test:</p>

<pre><code class="javascript">function runTestSuite(testSuiteConstructor, options) {
  options = options || {};
  var reporter = options.reporter || new SimpleReporter();

    reporter.reportTestSuite(testSuiteConstructor.name);

    var testSuitePrototype = createTestSuite(testSuiteConstructor);
    // ^ we change this from `testSuite` to `testSuitePrototype`  ^

  for (var testName in testSuitePrototype) {
    if (testName.match(/^test/)) {
      var testSuite = createTestSuite(testSuiteConstructor);
            // ^   and we create our testSuite every time here   ^
      testSuite[testName]();
    // ^  and run test on it ^
    }
  }
}

function createTestSuite(testSuiteConstructor) {
    return new testSuiteConstructor(assertions);
}
</code></pre>

<p>After doing this, we can move <code>var reporter = new ReporterSpy(t);</code> to the top level of the <code>ReporterSpyTest</code> suite again. And all the tests pass.</p>

<h2>Implementation of the rendering of the test name</h2>

<p>Finally, we need to make sure that the test suite, that we have written before will pass:</p>

<pre><code class="javascript">this.testItOutputsNameOfTheTest = function () {
    runTestSuite(function TestSuiteName(t) {
        this.testSomeTestName = function () {};
        this.testSomeOtherTestName = function () {};
    }, {reporter: reporter});

    reporter.assertHasReportedTestSuite("TestSuiteName");
    reporter.assertHasReportedTest("testSomeTestName");
    reporter.assertHasReportedTest("testSomeOtherTestName");
};
</code></pre>

<p>As expected it fails with <code>Error: Expected test 'testSomeTestName' to be reported</code>. After fixing it and applying triangulation once, we would end up with the following implementation:</p>

<pre><code class="javascript">// src/TestingFramework.js in runTestSuite function:
for (var testName in testSuitePrototype) {
    if (testName.match(/^test/)) {

        reporter.reportTest(testName);
// ^  here is our implementation  ^

        var testSuite = createTestSuite(testSuiteConstructor);
        testSuite[testName]();
    }
}

function SimpleReporter() {
    // ...
    // and we should not forget to implement it for real reporter
  this.reportTest = function (name) {
    process.stdout.write("\t" + name + "\n");
  };
}
</code></pre>

<p>Now, it seems that both <code>ReporterSpy</code> and <code>SimpleReporter</code> are implementing the same Duck type - <code>Reporter</code>. What Duck Type is? - find out here: <a href="/blog/2016/09/18/meet-duck-type/">Meet Duck Type</a>.</p>

<h2>Contract testing all Reporter duck types</h2>

<p>So we should test all our ducks that their public API don&rsquo;t get out of sync:</p>

<pre><code class="javascript">var TestingFramework = require("../src/TestingFramework");
var runTestSuite = TestingFramework;
var SimpleReporter = TestingFramework.SimpleReporter;

var ReporterSpy = require("./ReporterSpy");

const IMPLEMENTATIONS = [
    SimpleReporter,
    ReporterSpy
];

IMPLEMENTATIONS.forEach(function (ReporterImplementation) {
  runTestSuite(function (t) {
    var reporter = new ReporterImplementation();

    this.testDefines_reportTestSuite = function () {
      var reportTestSuite = reporter.reportTestSuite;
      t.assertEqual("function", typeof(reportTestSuite));
      t.assertEqual(1, reportTestSuite.length);
    };

    this.testDefines_reportTest = function () {
      var reportTest = reporter.reportTest;
      t.assertEqual("function", typeof(reportTest));
      t.assertEqual(1, reportTest.length);
    }
  });
});
</code></pre>

<p>All the tests pass. Unfortunately, the output regarding this test suite looks weird:</p>

<pre><code>
    testDefines_reportTestSuite
    testDefines_reportTest


    testDefines_reportTestSuite
    testDefines_reportTest
</code></pre>

<p>The test suite name is empty. I think we need an ability to define a custom and dynamic test suite name:</p>

<h2>Custom name for the test suite</h2>

<p>We can achieve this by allowing any test suite to define special hook method, that will return its custom name, like <code>testSuite.getTestSuiteName()</code>. Let&rsquo;s write a test for this:</p>

<pre><code class="javascript">this.testItCanHaveCustomNameOfTheTestSuite = function () {
  runTestSuite(function (t) {
    this.getTestSuiteName = function () {
      return "CustomNameOfTheTestSuite";
    };
  }, {reporter: reporter});

  reporter.assertHasReportedTestSuite("CustomNameOfTheTestSuite");
};
</code></pre>

<p>After implementing it and triangulating over the name once the code looks like this:</p>

<pre><code class="javascript">function runTestSuite(testSuiteConstructor, options) {
  options = options || {};
  var reporter = options.reporter || new SimpleReporter();

  var testSuitePrototype = createTestSuite(testSuiteConstructor);

  reporter.reportTestSuite(
    getTestSuiteName(testSuiteConstructor, testSuitePrototype)
// ^ this is the function that we introduced here to make it pass ^
  );

    for (var testName in testSuitePrototype) { ... }
}

function getTestSuiteName(testSuiteConstructor, testSuitePrototype) {
    if (typeof(testSuitePrototype.getTestSuiteName) !== "function") {
        return testSuiteConstructor.name;
    }

    return testSuitePrototype.getTestSuiteName();
}
</code></pre>

<p>Now, if we were to use this feature in our duck type tests:</p>

<pre><code class="javascript">IMPLEMENTATIONS.forEach(function (ReporterImplementation) {
  runTestSuite(function (t) {
    this.getTestSuiteName = function () {
      return ReporterImplementation.name + "_ReporterTest";
    };

    // ...
});
</code></pre>

<p>Then we are getting the proper output:</p>

<pre><code>SimpleReporter_ReporterTest
    testDefines_reportTestSuite
    testDefines_reportTest

ReporterSpy_ReporterTest
    testDefines_reportTestSuite
    testDefines_reportTest
</code></pre>

<h2>Bottom Line</h2>

<p>I think we are done with implementing our first simple reporter. Now we can see that the tests are actually executing and passing. The code can be found here: <a href="https://github.com/waterlink/BuildYourOwnTestingFrameworkPart4">https://github.com/waterlink/BuildYourOwnTestingFrameworkPart4</a></p>

<p>There is still a lot to go through. In a few next episodes we will:</p>

<ul>
<li>Make sure that first failure does not cause test suite to stop running;</li>
<li>Make sure the exit code is right;</li>
<li>Report OK and FAIL;</li>
<li>Output carefully formatted failures to the STDERR.</li>
</ul>


<p>Stay tuned!</p>

<h2>Thanks</h2>

<p>Thank you for reading, my dear reader. If you liked it, please share this article on social networks and follow me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you have any questions or feedback for me, don&rsquo;t hesitate to reach me out on Twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Build Your Own Testing Framework. Part 3]]></title>
    <link href="http://www.tddfellow.com/blog/2016/08/14/build-your-own-testing-framework-part-3/"/>
    <updated>2016-08-14T13:55:17+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/08/14/build-your-own-testing-framework-part-3</id>
    <content type="html"><![CDATA[<p>Welcome back to the new issue of &ldquo;Build Your Own Testing Framework&rdquo; series! Today we are going to unit-test <code>runTestSuite</code> function of our testing framework. Currently, only its happy path is implicitly tested via every test of the system. Additionally, this function&rsquo;s unhappy paths are, in fact, untestable at the moment.</p>

<p>This article is the third one of the series &ldquo;Build Your Own Testing Framework&rdquo;, so make sure to stick around for next parts! All articles of these series can be found <a href="/blog/categories/build-your-own-testing-framework/">here</a>.</p>

<p>Shall we get started?</p>

<h2>Testing existing code</h2>

<p>Let&rsquo;s take another look at the <code>runTestSuite</code> function:</p>

<pre><code class="javascript">function runTestSuite(testSuiteConstructor) {
    var testSuite = new testSuiteConstructor(assertions);

    for (var testName in testSuite) {
        if (testName.match(/^test/)) {
            testSuite[testName]();
        }
    }
}
</code></pre>

<p>This function currently:</p>

<ol>
<li>Creates a new test suite from the passed in function-constructor.</li>
<li>Finds every method that starts with the string <code>test</code>.</li>
<li>And calls every such method.</li>
</ol>


<h3>Test that it calls at least one test method</h3>

<pre><code class="javascript">var runTestSuite = require("../src/TestingFramework");

runTestSuite(function (t) {
    this.testItCallsOneTestMethod = function () {
        var called = false;

        runTestSuite(function (t) {
            this.testSomeInterestingFunction = function () {
                called = true;
            };
        });

        t.assertTrue(called);
    };
});
</code></pre>

<p>And this test passes. To be sure, that we are actually testing anything, let&rsquo;s make sure that <code>testSomeInterestingFunction</code> is not being called:</p>

<pre><code class="javascript">if (testName.match(/^test/) &amp;&amp;
    testName != "testSomeInterestingFunction") {
//  ^   make sure our method is not called  ^
    testSuite[testName]();
}
</code></pre>

<p>This fails as expected: <code>Error: Expected to be true, but got false</code>. Undoing this mutation causes the test to pass again. This is good, since we have seen this test fail when we expect it to fail. This proves the semantic stability of our test.</p>

<p>So, what will happen if we replace the whole <code>if</code> condition with <code>true</code>?</p>

<pre><code class="javascript">if (true) {
    testSuite[testName]();
}
</code></pre>

<p>As expected, all tests will pass. Seems that we need to add a new test here:</p>

<h3>Test that it does not call non-test methods</h3>

<pre><code class="javascript">this.testItDoesNotCallMethodThatDoesNotStartWithTestPrefix = function () {
    var called = false;

    runTestSuite(function (t) {
        this.someFunction = function () {
            called = true;
        };
    });

    t.assertTrue(!called);
};
</code></pre>

<p>And this fails as expected. This makes our test suite semantically stable against this sort of mutation. Undoing the mutation should make the test suite pass. And it does.</p>

<p>There is another surviving mutant that I can come up with:</p>

<pre><code class="javascript">for (var testName in testSuite) {
    if (testName.match(/^test/)) {
        testSuite[testName]();
    }
    break; // &lt;- surviving mutant
}
</code></pre>

<p>This means, that only first function will only ever run. Since all our tests are currently verifying that only one function is called or not we will need another test to defeat this mutant:</p>

<h3>Test that it calls all provided test methods</h3>

<pre><code class="javascript">this.testItCallsAllTestMethods = function () {
    var calledOne = false;
    var calledTwo = false;
    var calledThree = false;

    runTestSuite(function (t) {
        this.testFunctionOne = function () {
            calledOne = true;
        };

        this.testFunctionTwo = function () {
            calledTwo = true;
        };

        this.testFunctionThree = function () {
            calledThree = true;
        };
    });

    t.assertTrue(calledOne);
    t.assertTrue(calledTwo);
    t.assertTrue(calledThree);
};
</code></pre>

<p>Careful here: <code>testItCallsAllTestMethods</code> has to be the first test in the test suite for it to be ever called with the current mutation. As expected this test fails and undoing the mutation makes it pass.</p>

<p><code>testItCallsAllTestMethods</code> is superior to the <code>testItCallsOneTestMethod</code>, so we can remove the latter.</p>

<p>The amount of duplication in this code does not make me happy. Seems like we are missing the ability to verify if a certain function was called or not. Let&rsquo;s try to extract this abstraction:</p>

<pre><code class="javascript">function spy() {
    function that() {
        that.called = true;
    }

    that.called = false;

    return that;
};
</code></pre>

<p>And then the usage would look like that:</p>

<pre><code class="javascript">this.testItCallsAllTestMethods = function () {
    var spyOne = spy();
    var spyTwo = spy();
    var spyThree = spy();

    runTestSuite(function (t) {
        this.testFunctionOne = spyOne;
        this.testFunctionTwo = spyTwo;
        this.testFunctionThree = spyThree;
    });

    t.assertTrue(spyOne.called);
    t.assertTrue(spyTwo.called);
    t.assertTrue(spyThree.called);
};

this.testItDoesNotCallMethodThatDoesNotStartWithTestPrefix = function () {
    var aSpy = spy();

    runTestSuite(function (t) {
        this.someFunction = aSpy;
    });

    t.assertTrue(!aSpy.called);
};
</code></pre>

<h2>Testing <code>assertions.spy()</code></h2>

<p>It seems, that having <code>t.spy()</code> available for the users of our testing framework might be very useful! Let&rsquo;s test-drive it:</p>

<pre><code class="javascript">// Initially, it should not be called
this.testIsNotCalledInitially = function () {
    t.assertTrue(!t.spy().called);
};

// TypeError: t.spy is not a function

// Implementation in `assertions object`:
spy: function () {
    return {
        called: false
    }
}

// Let's check that it can be called as a function
this.testItCanBeCalledAsFunction = function () {
    t.spy()();
};

// TypeError: t.spy(...) is not a function

// Simplest implementation:
spy: function () {
    return function () {};
}

// Let's check that after being called it has correct `.called` value
this.testIsCalledAfterBeingCalled = function () {
    var aSpy = t.spy();
    aSpy();
    t.assertTrue(aSpy.called);
};

// Error: Expected to be true, but got false

// And final implementation:
spy: function () {
    return function that() {
        that.called = true;
    };
}
</code></pre>

<p>Test <code>testItCanBeCalledAsFunction</code> is inferior to <code>testIsCalledAfterBeingCalled</code>, so we can remove it.</p>

<p>To make the assertion more fluent we might want to have <code>aSpy.assertCalled()</code> and <code>aSpy.assertNotCalled()</code>:</p>

<pre><code class="javascript">// Let's replace our first test's `assertTrue(!...)` with `.assertNotCalled()`
this.testIsNotCalledInitially = function () {
    t.spy().assertNotCalled();
};

// TypeError: t.spy(...).assertNotCalled is not a function

// And the stupid implementation:
spy: function () {
    function that() {
        that.called = true;
    }

    that.assertNotCalled = function () {};

    return that;
}

// This needs some triangulation:
this.testAssertNotCalledFailsWhenWasCalled = function () {
    var aSpy = t.spy();
    aSpy();

    t.assertThrow("Expected not to be called", function () {
        aSpy.assertNotCalled();
    });
};

// Error: Expected to throw an error, but nothing was thrown

// And to make it pass:
that.assertNotCalled = function () {
    assertions.assertTrue(!that.called, "Expected not to be called");
};
</code></pre>

<p>Let&rsquo;s do the same with the other test:</p>

<pre><code class="javascript">// Replace `assertTrue` in the second test with `assertCalled`:
this.testIsCalledAfterBeingCalled = function () {
    var aSpy = t.spy();
    aSpy();
    aSpy.assertCalled();
};

// TypeError: aSpy.assertCalled is not a function

// And the stupid implementation:
that.assertCalled = function () {};

// Let's triangulate it a bit:
this.testAssertCalledFailsWhenWasNotCalled = function () {
    t.assertThrow("Expected to be called", function () {
        t.spy().assertCalled();
    });
};

// Error: Expected to throw an error, but nothing was thrown

// And the implementation:
that.assertCalled = function () {
    assertions.assertTrue(that.called, "Expected to be called");
};
</code></pre>

<p>And the full implementation of <code>spy()</code> function:</p>

<pre><code class="javascript">spy: function () {
    function that() {
        that.called = true;
    }

    that.assertNotCalled = function () {
        assertions.assertTrue(!that.called, "Expected not to be called");
    };

    that.assertCalled = function () {
        assertions.assertTrue(that.called, "Expected to be called");
    };

    return that;
}
</code></pre>

<h2>Bottom Line</h2>

<p>Today we have tested all the existing behavior of the <code>runTestSuite</code> function. That has driven us to implement very simple spies for our testing framework.</p>

<p>We have successfully applied manual Mutational Testing to the existing functionality to derive Semantically Stable tests for it. We did some Triangulation too today. Generally speaking, in TDD Triangulation technique is something that is used on a daily basis, when TDD is practiced properly. Future articles will expand on Triangulation, Mutational Testing, and Semantic Stability in more detail, so stay tuned!</p>

<p>There are only a few problems left, that bother me:</p>

<ul>
<li>We often do <code>t.assertTrue(!condition)</code>, seems that we lack <code>t.assertFalse(condition)</code> assertion.</li>
<li>We often call functions without any assertions to do an implicit assertion, that the call is not throwing any exception. This can be confusing: it is better to make that assertion explicitly - seems like we need <code>t.assertNotThrow</code>.</li>
<li>Seems that it is useful to have <code>NOT</code> version of every assertion. Even though we don&rsquo;t need <code>t.assertNotEqual</code> right now, from my experience with testing it is often very useful.</li>
</ul>


<p>Creating these assertions I will leave as an exercise to the reader. From now on, we will assume they are implemented and we will use them where appropriate. Code is available on GitHub: <a href="https://github.com/waterlink/BuildYourOwnTestingFrameworkPart3">https://github.com/waterlink/BuildYourOwnTestingFrameworkPart3</a></p>

<p>Next time we will add more requirements for our <code>runTestSuite</code> function, such as:</p>

<ul>
<li>Continue running tests after the first failure.</li>
<li>Report successfully passed tests.</li>
<li>Report failures.</li>
<li>Report test run stats (counts of successful and failed tests).</li>
<li>Avoid shared state between tests of the same test suite.</li>
</ul>


<p>Stay tuned!</p>

<h2>Thanks!</h2>

<p>Thank you for reading, my dear reader. If you liked it, please share this article on social networks and follow me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you have any questions or feedback for me, don&rsquo;t hesitate to reach me out on Twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Build Your Own Testing Framework. Part 2]]></title>
    <link href="http://www.tddfellow.com/blog/2016/07/23/build-your-own-testing-framework-part-2/"/>
    <updated>2016-07-23T14:52:42+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/07/23/build-your-own-testing-framework-part-2</id>
    <content type="html"><![CDATA[<p>Today we are going to unit-test existing functionality of our own testing framework, that we have test-driven with <code>FizzBuzzKata</code> in <a href="/blog/2016/07/15/build-your-own-testing-framework/">the previous part</a>.</p>

<p>This needs to be done, since currently only happy paths are implicitly tested via <code>FizzBuzzKata</code> test suite, i.e.: when all the tests pass. The following unhappy paths are not tested at the moment:</p>

<ul>
<li>when <code>assertTrue</code> fails, it throws an error,</li>
<li>when <code>assertEqual</code> fails, it throws an error,</li>
<li>when the test fails, it renders the error and fails the whole test suite run, i.e.: non-zero exit code.</li>
</ul>


<p>This article is the second one of the series &ldquo;Build Your Own Testing Framework&rdquo;, so make sure to stick around for next parts! All articles of these series can be found here: <a href="http://www.tddfellow.com/blog/categories/build-your-own-testing-framework/.">http://www.tddfellow.com/blog/categories/build-your-own-testing-framework/.</a></p>

<p>Shall we get the ball rolling?</p>

<h2>Testing <code>assertTrue(condition, message)</code></h2>

<p>Let&rsquo;s create a test suite for <code>assertTrue</code> with the first test for the case, when <code>assertTrue</code> succeeds:</p>

<pre><code class="javascript">// test/AssertTrueTest.js
var runTestSuite = require("../src/TestingFramework");

runTestSuite(function (t) {
    this.testSuccess = function () {
        t.assertTrue(true);
    };
});
</code></pre>

<p>If we run this test suite, it should not fail:</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js

Process finished with exit code 0
</code></pre>

<p>Let&rsquo;s check if that test actually is testing anything by trying to break the implementation of <code>assertTrue</code>:</p>

<pre><code class="javascript">// src/TestingFramework.js

assertTrue: function (condition, message) {
    if (condition) {    // &lt;- this condition was inverted
        throw new Error(...);
    }
},
</code></pre>

<p>And if we run it, we get the expected error:</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js
/path/to/project/src/TestingFramework.js:4
            throw new Error(message || "Expected to be true, but got false");
            ^

Error: Expected to be true, but got false
    .. stack trace ..

Process finished with exit code 1
</code></pre>

<p>OK, it fails as expected, now we should undo our breaking change in the implementation and run the test suite again and it should pass:</p>

<pre><code class="javascript">// src/TestingFramework.js

assertTrue: function (condition, message) {
    if (!condition) {    // &lt;- the breaking change here have been undone
        throw new Error(...);
    }
},
</code></pre>

<pre><code>/usr/local/bin/node AssertTrueTest.js

Process finished with exit code 0
</code></pre>

<p>Now, let&rsquo;s write a new test for the case, when <code>assertTrue</code> fails:</p>

<pre><code class="javascript">// test/AssertTrueTest.js

this.testFailure = function () {
    try {
        t.assertTrue(false);
    } catch (error) {
        t.assertEqual("Expected to be true, but got false", error.message);
    }
};
</code></pre>

<p>And if we run the test suite, it passes. If I was confident in the previous test, that I know why it didn&rsquo;t fail, here I feel a bit uncomfortable about writing these 5 lines of test code and never seeing them fail. So let&rsquo;s break the code once again!</p>

<pre><code class="javascript">// src/TestingFramework.js

assertTrue: function (condition, message) {
    if (!condition) {
        throw new Error(message || "oops");   // &lt;- we have changed error message here
    }
},
</code></pre>

<p>And if we run tests, we get an expected failure:</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js
/path/to/project/src/TestingFramework.js:4
            throw new Error(message || "oops");
            ^

Error: Expected to equal Expected to be true, but got false, but got: oops
    .. stack trace ..

Process finished with exit code 1
</code></pre>

<p>And if we undo our breaking change in the implementation the test should pass:</p>

<pre><code class="javascript">// src/TestingFramework.js

assertTrue: function (condition, message) {
    if (!condition) {
        throw new Error(message || "Expected to be true, but got false");
        //                         ^ we have restored correct message ^
    }
},
</code></pre>

<pre><code>/usr/local/bin/node AssertTrueTest.js

Process finished with exit code 0
</code></pre>

<p>And the last test for <code>assertTrue</code> to test the custom failure message:</p>

<pre><code class="javascript">// test/AssertTrueTest.js

this.testCustomFailureMessage = function () {
    try {
        t.assertTrue(false, "it is not true!");
    } catch (error) {
        t.assertEqual("it is not true!", error.message);
    }
};
</code></pre>

<p>If we run the test suite, it passes:</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js

Process finished with exit code 0
</code></pre>

<p>Even that I am confident enough, that this <code>try { ... } catch (..) { ... }</code> construction does the right thing, let&rsquo;s be diligent about it and break the implementation of that functionality and see this test fail:</p>

<pre><code class="javascript">// src/TestingFramework.js

assertTrue: function (condition, message) {
    if (!condition) {
        throw new Error("Expected to be true, but got false");
        //              ^ 'message || ' was removed here   ^
    }
},
</code></pre>

<p>If we run the test suite:</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js
/path/to/project/src/TestingFramework.js:4
            throw new Error("Expected to be true, but got false");
            ^

Error: Expected to be true, but got false
    .. stack trace ..

Process finished with exit code 1
</code></pre>

<p>It fails, but this change breaks <code>assertEqual</code> too so that we don&rsquo;t see any meaningful error message now. We can figure out if that is an expected failure or not by inspecting the stack trace:</p>

<pre><code>Error: Expected to be true, but got false
    at Object.assertions.assertTrue (/path/to/project/src/TestingFramework.js:4:19)
    at Object.assertions.assertEqual (/path/to/project/src/TestingFramework.js:9:14)
    at testCustomFailureMessage (/path/to/project/test/AssertTrueTest.js:20:15)
    at runTestSuite (/path/to/project/src/TestingFramework.js:21:32)
    at Object.&lt;anonymous&gt; (/path/to/project/test/AssertTrueTest.js:3:1)
    at Module._compile (module.js:409:26)
    at Object.Module._extensions..js (module.js:416:10)
    at Module.load (module.js:343:32)
    at Function.Module._load (module.js:300:12)
    at Function.Module.runMain (module.js:441:10)
</code></pre>

<p>and precisely this line is the most interesting one:</p>

<pre><code>at testCustomFailureMessage (/path/to/project/test/AssertTrueTest.js:20:15)
</code></pre>

<p>If we open the code at this stack trace frame, we will see:</p>

<pre><code class="javascript">t.assertEqual("it is not true!", error.message);
</code></pre>

<p>Great, this is exactly what we expected. Undoing the breaking change and running the test suite again:</p>

<pre><code class="javascript">// src/TestingFramework.js

assertTrue: function (condition, message) {
    if (!condition) {
        throw new Error(message || "Expected to be true, but got false");
        //              ^ 'message || ' was inserted here again       ^
    }
},
</code></pre>

<pre><code>/usr/local/bin/node AssertTrueTest.js

Process finished with exit code 0
</code></pre>

<p>Interestingly enough, I know how to break the code now and all the tests will pass:</p>

<p>First, let&rsquo;s extract local variable in <code>assertTrue</code>:</p>

<pre><code class="javascript">// src/TestingFramework.js

assertTrue: function (condition, message) {
    var errorMessage = message || "Expected to be true, but got false";

    if (!condition) {
        throw new Error(errorMessage);
    }
},
</code></pre>

<p>And that still passes its tests:</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js

Process finished with exit code 0
</code></pre>

<p>Now let&rsquo;s expand <code>message ||</code> into the proper <code>if</code> statement:</p>

<pre><code class="javascript">var errorMessage = "Expected to be true, but got false";

if (message) {
    errorMessage = message;
}
</code></pre>

<p>And that still passes its tests:</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js

Process finished with exit code 0
</code></pre>

<p>Now, what if I were to replace <code>errorMessage = message;</code> with <code>errorMessage = "it is not true!";</code> inside of the <code>if</code> statement:</p>

<pre><code class="javascript">if (message) {
    errorMessage = "it is not true!";
}
</code></pre>

<p>The test still passes!</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js

Process finished with exit code 0
</code></pre>

<p>This is rather interesting. It seems, that we will have to make sure, that <code>message</code> parameter actually gets passed to <code>new Error(...)</code>. We can do that by applying the Triangulation technique focusing on <code>message</code> parameter:</p>

<pre><code class="javascript">// test/AssertTrueTest.js

this.testCustomFailureMessage_withOtherMessage = function () {
    try {
        t.assertTrue(false, "should be true");
    } catch (error) {
        t.assertEqual("should be true", error.message);
    }
};
</code></pre>

<p>And if we run the test suite, we get our expected failure:</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js
/path/to/project/src/TestingFramework.js:10
            throw new Error(errorMessage);
            ^

Error: it is not true!
    ...
    at testCustomFailureMessage_withOtherMessage (/path/to/project/test/AssertTrueTest.js:28:15)
    ...

Process finished with exit code 1
</code></pre>

<p>And if we look at the stack trace frame, it points us to the correct line of code:</p>

<pre><code class="javascript">t.assertEqual("should be true", error.message);
</code></pre>

<p>And we can now fix the test by fixing the implementation:</p>

<pre><code class="javascript">// src/TestingFramework.js

// inside of `assertTrue` function:
if (message) {
    errorMessage = message;   // &lt;- here we actually have to use 'message' now
}
</code></pre>

<p>And when we run the test suite, it passes:</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js

Process finished with exit code 0
</code></pre>

<p>I think we have all required tests for <code>assertTrue</code> now. This is great! And have you spotted the duplication already?</p>

<h2>Refactoring <code>AssertTrueTest</code></h2>

<p>The duplication that is present here is our <code>try { ... } catch (..) { ... }</code> construct. Let&rsquo;s make it a completely duplicate code by extracting couple of local variables:</p>

<pre><code class="javascript">// first, let's extract the Action Under the Test variable:
var action = function () { t.assertTrue(false); };

try {
    action();
} catch (error) {
    t.assertEqual("Expected to be true, but got false", error.message);
}

// next, let's extract the Expected Error Message:
var expectedMessage = "Expected to be true, but got false";

try {
    action();
} catch (error) {
    t.assertEqual(expectedMessage, error.message);
}
</code></pre>

<p>If we apply the same refactoring for all tests in the <code>AssertTrueTest</code> suite, we will see the duplication:</p>

<pre><code class="javascript">try {
    action();
} catch (error) {
    t.assertEqual(expectedMessage, error.message);
}
</code></pre>

<p>Let&rsquo;s give that operation a name and extract is as a function: <code>assertThrow(expectedMessage, action)</code>:</p>

<pre><code class="javascript">function assertThrow(expectedMessage, action) {
    try {
        action();
    } catch (error) {
        t.assertEqual(expectedMessage, error.message);
    }
}
</code></pre>

<p>Use this function in all tests and inline all the extracted local variables:</p>

<pre><code class="javascript">this.testFailure = function () {
    assertThrow("Expected to be true, but got false", function () {
        t.assertTrue(false);
    });
};

this.testCustomFailureMessage = function () {
    assertThrow("it is not true!", function () {
        t.assertTrue(false, "it is not true!");
    });
};

this.testCustomFailureMessage_withOtherMessage = function () {
    assertThrow("should be true", function () {
        t.assertTrue(false, "should be true");
    });
};
</code></pre>

<p>Function <code>assertThrow</code> seems to be useful for any test, not just <code>AssertTrueTest</code> suite. Let&rsquo;s move it to the <code>assertions</code> object. We will be doing that by using Parallel Change technique:</p>

<ol>
<li>Create new functionality first;</li>
<li>Step by step migrate all calls to use new functionality instead of old one;</li>
<li>Once old functionality is not used, remove it.</li>
</ol>


<p>The advantage of that method is that it consists of very small steps, that can be executed with confidence and each such small step never leaves the user in a red state (failing tests or compile/parsing errors).</p>

<p>Let&rsquo;s see how this one can be applied here:</p>

<p><code>1. Create new functionality first</code> - we can do it by copying the <code>assertThrow</code> function to <code>assertions</code> object:</p>

<pre><code class="javascript">// src/TestingFramework.js

var assertions = {
    // ...
    assertThrow: function (expectedMessage, action) {
        try {
            action();
        } catch (error) {
            // `t` needs to be changed to `this` here
            this.assertEqual(expectedMessage, error.message);
        }
    }
};
</code></pre>

<p>The tests should still pass:</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js

Process finished with exit code 0
</code></pre>

<p><code>2. Step by step migrate all calls to use new functionality instead of old one</code> - we do it by calling <code>assertThrow</code> on <code>t</code> (our assertions object) in the test suite. Since we still haven&rsquo;t removed the old <code>assertThrow</code> function, we can do that one function call at the time and the tests will always be green:</p>

<pre><code class="javascript">this.testFailure = function () {
    t.assertThrow("Expected to be true, but got false", function () {
// ^ 't.' added here ^
        t.assertTrue(false);
    });
};

// run tests and they still pass.

this.testCustomFailureMessage = function () {
    t.assertThrow("it is not true!", function () {
// ^ 't.' added here ^
        t.assertTrue(false, "it is not true!");
    });
};

// run tests and they still pass.

this.testCustomFailureMessage_withOtherMessage = function () {
    t.assertThrow("should be true", function () {
// ^ 't.' added here ^
        t.assertTrue(false, "should be true");
    });
};
</code></pre>

<p><code>3. Once old functionality is not used, remove it.</code> - now we can remove our <code>assertThrow</code> function defined inside of the <code>AssertTrueTest</code> suite and run tests:</p>

<pre><code>/usr/local/bin/node AssertTrueTest.js

Process finished with exit code 0
</code></pre>

<p>And they pass. Let&rsquo;s see the complete <code>AssertTrueTest</code> suite again:</p>

<pre><code class="javascript">// test/AssertTrueTest.js
var runTestSuite = require("../src/TestingFramework");

runTestSuite(function (t) {
    this.testSuccess = function () {
        t.assertTrue(true);
    };

    this.testFailure = function () {
        t.assertThrow("Expected to be true, but got false", function () {
            t.assertTrue(false);
        });
    };

    this.testCustomFailureMessage = function () {
        t.assertThrow("it is not true!", function () {
            t.assertTrue(false, "it is not true!");
        });
    };

    this.testCustomFailureMessage_withOtherMessage = function () {
        t.assertThrow("should be true", function () {
            t.assertTrue(false, "should be true");
        });
    };
});
</code></pre>

<p>The only problem here is that we are relying on the untested <code>assertThrow</code> assertion here. Let&rsquo;s unit-test it.</p>

<h2>Testing <code>assertThrow(expectedMessage, action)</code></h2>

<p>Let&rsquo;s create a new test suite with first test when <code>assertThrow</code> succeeds:</p>

<pre><code class="javascript">// test/AssertThrowTest.js
var runTestSuite = require("../src/TestingFramework");

runTestSuite(function (t) {
    this.testSuccess = function () {
        assertThrow("an error message", function () {
            throw new Error("an error message");
        });
    };
});
</code></pre>

<p>And the test should pass:</p>

<pre><code>/usr/local/bin/node AssertThrowTest.js

Process finished with exit code 0
</code></pre>

<p>The code can be broken without test failure by not using <code>expectedMessage</code> parameter:</p>

<pre><code class="javascript">// src/TestingFramework.js

assertThrow: function (expectedMessage, action) {
    try {
        action();
    } catch (error) {
        this.assertEqual("an error message", error.message);
        // ^ here 'expectedMessage' was changed to constant ^
    }
}
</code></pre>

<p>Let&rsquo;s triangulate the code to make sure <code>expectedMessage</code> is used correctly by adding a new test:</p>

<pre><code class="javascript">// test/AssertThrowTest.js

this.testSuccess_withDifferentExpectedMessage = function () {
    t.assertThrow("a different error message", function () {
        throw new Error("a different error message");
    });
};
</code></pre>

<p>And that test fails as expected:</p>

<pre><code>/usr/local/bin/node AssertThrowTest.js
/path/to/project/src/TestingFramework.js:10
            throw new Error(errorMessage);
            ^

Error: Expected to equal an error message, but got: a different error message

Process finished with exit code 1
</code></pre>

<p>Undoing the breaking change (Mutation) will make the test pass:</p>

<pre><code>/usr/local/bin/node AssertThrowTest.js

Process finished with exit code 0
</code></pre>

<p>Next test is to make sure, that <code>assertThrow</code> is actually comparing actual and expected error messages correctly:</p>

<pre><code class="javascript">// test/AssertThrowTest.js

this.testFailure = function () {
    t.assertThrow("Expected to equal an error message, but got: a different error message", function () {
        t.assertThrow("an error message", function () {
            throw new Error("a different error message");
        });
    });
};
</code></pre>

<p>And it passes. The last test, that <code>assertThrow</code> needs is the case, when <code>action()</code> is not throwing any error. In that case <code>assertThrow</code> should fail:</p>

<pre><code class="javascript">// test/AssertThrowTest.js

this.testFailure_whenActionDoesNotThrow = function () {
    t.assertThrow("Expected to throw an error, but nothing was thrown", function () {
        t.assertThrow("an error message", function () {
            // does nothing
        });
    });
};
</code></pre>

<p>Oh, and that test is passing! We clearly don&rsquo;t have that functionality yet. We have to add another test without usage of outer <code>t.assertThrow</code> to make sure that we get a test failure:</p>

<pre><code class="javascript">this.testThrows_whenActionDoesNotThrow = function () {
    var hasThrown = false;

    try {
        t.assertThrow("an error message", function () {
            // does nothing
        });
    } catch (error) {
        hasThrown = true;
    }

    t.assertTrue(hasThrown, "it should have thrown");
};
</code></pre>

<p>And if we run our tests we get the expected failure:</p>

<pre><code>/usr/local/bin/node AssertThrowTest.js
/path/to/project/src/TestingFramework.js:10
            throw new Error(errorMessage);
            ^

Error: it should have thrown

Process finished with exit code 1
</code></pre>

<p>We can fix that by verifying, that <code>catch</code> block is executed in the <code>assertThrow</code> function:</p>

<pre><code class="javascript">// src/TestingFramework.js

assertThrow: function (expectedMessage, action) {
    var hasThrown = false;  // &lt;- we initialize hasThrown here

    try {
        action();
    } catch (error) {
        hasThrown = true;   // &lt;- and we set it to true in the catch block
        this.assertEqual(expectedMessage, error.message);
    }

    this.assertTrue(hasThrown);  // &lt;- and we check that it is true
}
</code></pre>

<p>And now if we run the test suite, the original test that we were trying to write fails as expected:</p>

<pre><code>/usr/local/bin/node AssertThrowTest.js
/path/to/project/src/TestingFramework.js:10
            throw new Error(errorMessage);
            ^

Error: Expected to equal Expected to throw an error, but nothing was thrown, but got: Expected to be true, but got false

Process finished with exit code 1
</code></pre>

<p>Now we need to fix the custom message provided to <code>assertTrue</code> call inside of <code>assertThrow</code>:</p>

<pre><code class="javascript">// src/TestingFramework.js

// inside of assertThrow:
this.assertTrue(hasThrown, "Expected to throw an error, but nothing was thrown");
</code></pre>

<p>And the test pass:</p>

<pre><code>/usr/local/bin/node AssertThrowTest.js

Process finished with exit code 0
</code></pre>

<p>Great, I think we are done with testing the <code>assertThrow</code> function. Let&rsquo;s see the whole <code>AssertThrowTest</code> suite:</p>

<pre><code class="javascript">// test/AssertThrowTest.js
var runTestSuite = require("../src/TestingFramework");

runTestSuite(function (t) {
    this.testSuccess = function () {
        t.assertThrow("an error message", function () {
            throw new Error("an error message");
        });
    };

    this.testSuccess_withDifferentExpectedMessage = function () {
        t.assertThrow("a different error message", function () {
            throw new Error("a different error message");
        });
    };

    this.testFailure = function () {
        t.assertThrow("Expected to equal an error message, but got: a different error message", function () {
            t.assertThrow("an error message", function () {
                throw new Error("a different error message");
            });
        });
    };

    this.testFailure_whenActionDoesNotThrow = function () {
        t.assertThrow("Expected to throw an error, but nothing was thrown", function () {
            t.assertThrow("an error message", function () {
                // does nothing
            });
        });
    };

    this.testThrows_whenActionDoesNotThrow = function () {
        var hasThrown = false;

        try {
            t.assertThrow("an error message", function () {
                // does nothing
            });
        } catch (error) {
            hasThrown = true;
        }

        t.assertTrue(hasThrown, "it should have thrown");
    };
});
</code></pre>

<p>Last one for today is <code>assertEqual</code>:</p>

<h2>Testing <code>assertEqual(expected, actual)</code></h2>

<p>Let&rsquo;s create a test suite with the first test, when <code>assertEqual</code> succeeds:</p>

<pre><code class="javascript">// test/AssertEqualTest.js
var runTestSuite = require("../src/TestingFramework");

runTestSuite(function (t) {
    this.testSuccess = function () {
        t.assertEqual(42, 42);
    };
});
</code></pre>

<p>This test passes, and it can be broken without test failure by always comparing to <code>42</code>:</p>

<pre><code class="javascript">// src/TestingFramework.js

assertEqual: function (expected, actual) {
    this.assertTrue(
        42 == actual,   // &lt;- here 'expected' is replaced with constant
        "Expected to equal " + expected + ", but got: " + actual
    );
},
</code></pre>

<p>Triangulation to fix that:</p>

<pre><code class="javascript">// test
this.testSuccess_whenExpectedIsDifferent = function () {
    t.assertEqual(29, 29);
};

// Error: Expected to equal 29, but got: 29

// fix implementation:
expected == actual,   // &lt;- here 'expected' is restored

// and the test passes
</code></pre>

<p>Next mutation that does not break any tests looks this way:</p>

<pre><code class="javascript">// src/TestingFramework.js

assertEqual: function (expected, actual) {
    this.assertTrue(
        expected == actual,
        // "Expected to equal " + expected + ", but got: " + actual
        "oops"    // &lt;- replace error message
    );
},
</code></pre>

<p>Let&rsquo;s add the test to protect from this kind of mutation:</p>

<pre><code class="javascript">this.testFailure = function () {
    t.assertThrow("Expected to equal 42, but got: 29", function () {
        t.assertEqual(42, 29);
    });
};
</code></pre>

<p>This fails with <code>Error: oops</code>, because <code>assertThrow</code> uses <code>assertEqual</code>. Stack trace shows, that the failure is happening here:</p>

<pre><code class="javascript">// src/TestingFramework.js in assertThrow
this.assertEqual(expectedMessage, error.message);
</code></pre>

<p>So that is the expected failure. We can fix it by always providing the message <code>"Expected to equal 42, but got: 29"</code>:</p>

<pre><code class="javascript">// src/TestingFramework.js in assertions
assertEqual: function (expected, actual) {
    this.assertTrue(
        expected == actual,
        "Expected to equal 42, but got: 29"
    // ^ here the exact constant is used ^
    );
},
</code></pre>

<p>This needs some more triangulation:</p>

<pre><code class="javascript">this.testFailure_withDifferentExpectedAndActual = function () {
    t.assertThrow("Expected to equal 94, but got: 1027", function () {
        t.assertEqual(94, 1027);
    });
};

// Error: Expected to equal 42, but got: 29

// fix:
this.assertTrue(
    expected == actual,
    "Expected to equal " + expected + ", but got: " + actual
);
</code></pre>

<p>I think we are done now with testing the <code>assertEqual</code> function. The <code>AssertEqualTest</code> suite is looking like that now:</p>

<pre><code class="javascript">// test/AssertEqualTest.js
var runTestSuite = require("../src/TestingFramework");

runTestSuite(function (t) {
    this.testSuccess = function () {
        t.assertEqual(42, 42);
    };

    this.testSuccess_whenExpectedIsDifferent = function () {
        t.assertEqual(29, 29);
    };

    this.testFailure = function () {
        t.assertThrow("Expected to equal 42, but got: 29", function () {
            t.assertEqual(42, 29);
        });
    };

    this.testFailure_withDifferentExpectedAndActual = function () {
        t.assertThrow("Expected to equal 94, but got: 1027", function () {
            t.assertEqual(94, 1027);
        });
    };
});
</code></pre>

<h2>Final <code>assertions</code> object after all the testing</h2>

<pre><code class="javascript">// src/TestingFramework.js
var assertions = {
    assertTrue: function (condition, message) {
        var errorMessage = "Expected to be true, but got false";

        if (message) {
            errorMessage = message;
        }

        if (!condition) {
            throw new Error(errorMessage);
        }
    },

    assertEqual: function (expected, actual) {
        this.assertTrue(
            expected == actual,
            "Expected to equal " + expected + ", but got: " + actual
        );
    },

    assertThrow: function (expectedMessage, action) {
        var hasThrown = false;

        try {
            action();
        } catch (error) {
            hasThrown = true;
            this.assertEqual(expectedMessage, error.message);
        }

        this.assertTrue(
            hasThrown,
            "Expected to throw an error, but nothing was thrown"
        );
    }
};
</code></pre>

<h2>Bottom Line</h2>

<p>Congratulations! We have completely unit-tested our assertions <code>assertTrue</code> and <code>assertEqual</code>. This resulted in natural emergence of the new assertion - <code>assertThrow</code>. We have unit-tested it too!</p>

<p>Additionally, we have practiced usage of Mutational Testing and Triangulation Technique to detect missing test cases and derive them from the code. Also, we have slightly touched the Parallel Change refactoring technique - we will see more of that in the future in these series.</p>

<p>The code is available on Github: <a href="https://github.com/waterlink/BuildYourOwnTestingFrameworkPart2">https://github.com/waterlink/BuildYourOwnTestingFrameworkPart2</a></p>

<p>Now that we have unit-tested some basic assertions, we should unit-test our testing framework test runner: <code>runTestSuite</code> function. This will be covered in next series of &ldquo;Build Your Own Testing Framework&rdquo;. Stay tuned!</p>

<h2>Thanks!</h2>

<p>Thank you for reading, my dear reader. If you liked it, please share this article on social networks and follow me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you have any questions or feedback for me, don&rsquo;t hesitate to reach me out on Twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Build Your Own Testing Framework]]></title>
    <link href="http://www.tddfellow.com/blog/2016/07/15/build-your-own-testing-framework/"/>
    <updated>2016-07-15T08:00:06+02:00</updated>
    <id>http://www.tddfellow.com/blog/2016/07/15/build-your-own-testing-framework</id>
    <content type="html"><![CDATA[<p>Today we are going to test-drive the testing framework without any external testing framework.
This will be done through test-driving a simple kata (FizzBuzzKata). For example:</p>

<ul>
<li>every time we expect a test to fail and it doesn&rsquo;t, this is a failing test for our testing framework, that we will be fixing,</li>
<li>every time we expect a test to pass and it doesn&rsquo;t, this is another failing test for our testing framework, that we will be fixing.</li>
</ul>


<p>For practical reasons, today we are going to use concrete programming language instead of pseudo-code - javascript. Except for small details, that we will point out, the techniques shown here are language-agnostic.</p>

<p>This article is only first one of the series &ldquo;Build Your Own Testing Framework&rdquo;, so make sure to stick around for next parts! All articles of these series can be found here: <a href="http://www.tddfellow.com/blog/categories/build-your-own-testing-framework/.">http://www.tddfellow.com/blog/categories/build-your-own-testing-framework/.</a></p>

<p>Shall we begin?</p>

<h2>FizzBuzzKata</h2>

<p>Given the number,</p>

<ul>
<li>return <code>Fizz</code> when the number is divisible by 3,</li>
<li>return <code>Buzz</code> when the number is divisible by 5,</li>
<li>return <code>FizzBuzz</code> when the number is divisible by 3 and 5,</li>
<li>return string representation of number otherwise.</li>
</ul>


<h2>Writing your first test</h2>

<p>How do we write our first test, when we don&rsquo;t have a testing framework and we want to create one? - It seems, that we have to design how the test should like in our brand new testing framework.</p>

<p>I personally, would go with the xUnit-like design, since it is relatively simple. Given this, we might write our first test and it will look something like that:</p>

<pre><code class="javascript">// test/FizzBuzzKataTest.js

function FizzBuzzKataTest() {
    this.testNormalNumberIsReturned = function() {
        this.assertTrue("1" === fizzBuzz(1));
    };
}
</code></pre>

<p>This test should fail, because function <code>fizzBuzz</code> is not defined, but it doesn&rsquo;t fail, since function <code>testNormalNumberIsReturned</code> is never called. In fact, the object with <code>FizzBuzzKataTest</code> is never being created.</p>

<p>Easiest way to solve that:</p>

<pre><code class="javascript">// test/FizzBuzzKataTest.js

function FizzBuzzKataTest() { ... }

var test = new FizzBuzzKataTest();
test.testNormalNumberIsReturned();
</code></pre>

<p>If we run this code with <code>node</code>:</p>

<pre><code class="bash">node test/FizzBuzzKataTest.js
</code></pre>

<p>We will get the expected error:</p>

<pre><code>/path/to/project/test/FizzBuzzKataTest.js:3
        this.assertTrue("1" === fizzBuzz(1));
                               ^

ReferenceError: fizzBuzz is not defined
</code></pre>

<p>So, let&rsquo;s define this function:</p>

<pre><code class="javascript">// test/FizzBuzzKataTest.js

function FizzBuzzKataTest() { ... }

function fizzBuzz() {}
</code></pre>

<p>If we run our test again, we will get the following error:</p>

<pre><code>/path/to/project/test/FizzBuzzKataTest.js:3
        this.assertTrue("1" === fizzBuzz(1));
             ^

TypeError: this.assertTrue is not a function
</code></pre>

<p>Clearly, to fix it we need to define <code>assertTrue</code> on <code>FizzBuzzKataTest</code> object. Obviously, we do not want our user to define all their assertion for every test suite. This means, that we want to define it on <code>FizzBuzzKataTest</code> object outside of the definition of <code>FizzBuzzKataTest</code>.</p>

<p>There are two ways to go about it:</p>

<ul>
<li>inheritance: make <code>FizzBuzzKataTest</code> inherit from some other object function <code>assertTrue</code>, or</li>
<li>composition: make <code>FizzBuzzKataTest</code> accept a special object with function <code>assertTrue</code> defined on it.</li>
</ul>


<p>I would like to go with composition method since it gives us more flexibility in the long run:</p>

<pre><code class="javascript">function FizzBuzzKataTest(t) { ... }
</code></pre>

<p>and the usage of <code>assertTrue</code> has to change appropriately:</p>

<pre><code class="javascript">    t.assertTrue("1" === fizzBuzz(1));
</code></pre>

<p>and <code>t</code> has to be created and passed in correctly:</p>

<pre><code class="javascript">function FizzBuzzKataTest(t) { ... }

function fizzBuzz(number) {}

var assertions = {
    assertTrue: function(condition) {}
};

var test = new FizzBuzzKataTest(assertions);
</code></pre>

<p>If we run the test suite again, we will not get any failure anymore. But we were expecting <code>assertTrue</code> to fail, so let&rsquo;s make it fail:</p>

<pre><code class="javascript">    assertTrue: function(condition) {
        throw new Error("Expected to be true, but was false");
    }
</code></pre>

<p>When we run the test suite, we get:</p>

<pre><code>/path/to/project/test/FizzBuzzKataTest.js:11
        throw new Error("Expected to be true, but got false");
        ^

Error: Expected to be true, but got false
</code></pre>

<p>Now, let&rsquo;s customize the error message a bit:</p>

<pre><code class="javascript">    this.testNormalNumberIsReturned = function() {
        t.assertTrue("1" === fizzBuzz(1), "Expected to equal " + "1" + ", but got: " + fizzBuzz(1));
    }

// ...

    assertTrue: function(condition, message) {
        throw new Error(message || "Expected to be true, but got false");
    }
</code></pre>

<p>When running this, we are getting the expected error:</p>

<pre><code>/path/to/project/test/FizzBuzzKataTest.js:11
        throw new Error(message || "Expected to be true, but got false");
        ^

Error: Expected to equal 1, but got: undefined
</code></pre>

<p>This looks better now. Let&rsquo;s fix the error now by implementing the simplest thing that could work:</p>

<pre><code class="javascript">function fizzBuzz(number) {
    return "1";
}
</code></pre>

<p>And as we run our test suite we get:</p>

<pre><code>/path/to/project/test/FizzBuzzKataTest.js:13
        throw new Error(message || "Expected to be true, but got false");
        ^

Error: Expected to equal 1, but got: 1
</code></pre>

<p>Oh, it should have passed the test. I know why it didn&rsquo;t: we throw this error unconditionally, let&rsquo;s add an appropriate <code>if</code> statement to <code>assertTrue</code> function:</p>

<pre><code class="javascript">    assertTrue: function(condition, message) {
        if (!condition) {
            throw new Error(...);
        }
    }
</code></pre>

<p>If we run this code, it does not fail. That was our first green state - it took as awhile to get here. The reason for this is that we are not only test-driving <code>FizzBuzzKata</code>, additionally, we are writing a feature test for a non-existing testing framework. Now that we are green, we should think about refactoring, i.e.: making the structure of our code right.</p>

<p>Obviously, we should move our testing framework code outside of the test suite file. Probably, somewhere in <code>src/TestingFramework.js</code>. For that, we need to first parametrize <code>FizzBuzzKataTest</code> and extract the function to run the test suite.</p>

<p>Parametrize:</p>

<pre><code class="javascript">var testSuiteConstructor = FizzBuzzKataTest;
var testSuite = new testSuiteConstructor(assertions);
testSuite.testNormalNumberIsReturned();
</code></pre>

<p>and extract method:</p>

<pre><code class="javascript">function runTestSuite(testSuiteConstructor) {
    var testSuite = new testSuiteConstructor(assertions);
    testSuite.testNormalNumberIsReturned();
}

var testSuiteConstructor = FizzBuzzKataTest;
runTestSuite(testSuiteConstructor);
</code></pre>

<p>and inline the variable <code>testSuiteConstructor</code>:</p>

<pre><code class="javascript">runTestSuite(FizzBuzzKataTest);
</code></pre>

<p>Now it is time to move testing code to <code>src/TestingFramework.js</code>:</p>

<pre><code class="javascript">// src/TestingFramework.js

var assertions = {
    assertTrue: function (condition, message) {
        if (!condition) {
            throw new Error(message || "Expected to be true, but got false");
        }
    }
};

function runTestSuite(testSuiteConstructor) {
    var testSuite = new testSuiteConstructor(assertions);
    testSuite.testNormalNumberIsReturned();
}
</code></pre>

<p>And to be able to require <code>runTestSuite</code> function:</p>

<pre><code class="javascript">// src/TestingFramework.js

var assertions = { ... };

function runTestSuite(testSuiteConstructor) { ... }

module.exports = runTestSuite;
</code></pre>

<p>And, finally, let&rsquo;s use that from our test suite:</p>

<pre><code class="javascript">// test/FizzBuzzKataTest.js

var runTestSuite = require("../src/TestingFramework");

function FizzBuzzKataTest(t) { ... }

function fizzBuzz(number) { ... }

runTestSuite(FizzBuzzKataTest);
</code></pre>

<p>If we run the test suite again, everything should pass. Somehow, I don&rsquo;t feel comfortable now, let&rsquo;s try to break the test suite and see if it will fail as expected:</p>

<pre><code class="javascript">function fizzBuzz(number) {
    return "2";  // &lt;-- "1" was changed to "2" here
}
</code></pre>

<p>And run tests:</p>

<pre><code>/path/to/project/src/TestingFramework.js:4
            throw new Error(message || "Expected to be true, but got false");
            ^

Error: Expected to equal 1, but got: 2
</code></pre>

<p>Yes, it still works as expected. We have just introduced a Mutation to our code, to see if it is still tested properly. Let&rsquo;s undo the Mutation and see the test still pass. And it does.</p>

<p>If you look closely now, it should be possible to inline <code>FizzBuzzKataTest</code> definition as an argument of <code>runTestSuite</code> call:</p>

<pre><code class="javascript">var runTestSuite = require(...);

function fizzBuzz(number) { ... }

runTestSuite(function (t) { ... });
</code></pre>

<p>And if we run our test suite, it still works. Just to check, that we are still good, let&rsquo;s repeat our Mutation from the previous step. It should still fail as expected. And it does. Undo the mutation and the test is still passing. Great.</p>

<p>I think we are done with Refactoring step, for now, let&rsquo;s get back to writing another failing test.</p>

<h2>Writing the second test</h2>

<pre><code class="javascript">    this.testAnotherNormalNumberIsReturned = function() {
        t.assertTrue("2" === fizzBuzz(2), "Expected to equal " + "2" + ", but got: " + fizzBuzz(2));
    };
</code></pre>

<p>If we run these tests, they do not fail. This is strange, let&rsquo;s look at <code>runTestSuite</code> function again:</p>

<pre><code class="javascript">function runTestSuite(testSuiteConstructor) {
    var testSuite = new testSuiteConstructor(assertions);
    testSuite.testNormalNumberIsReturned();
}
</code></pre>

<p>Great, it just runs one specific function, we should probably run all functions starting from <code>test</code> instead:</p>

<pre><code class="javascript">function runTestSuite(testSuiteConstructor) {
    var testSuite = new testSuiteConstructor(assertions);

    for (var testName in testSuite) {
        if (testName.match(/^test/)) {
            testSuite[testName]();
        }
    }
}
</code></pre>

<p><em>REMARK: this code is Javascript specific. Other programming languages will have their own way of iterating over the function/method list and calling a function by its name. Usually, it is some sort of reflection for compiled languages and meta-programming features for interpreted languages.</em></p>

<p>If we run tests now, we get the expected failure:</p>

<pre><code>/path/to/project/src/TestingFramework.js:4
            throw new Error(message || "Expected to be true, but got false");
            ^

Error: Expected to equal 2, but got: 1
</code></pre>

<p>If we try to change <code>return "1"</code> to <code>return "2"</code>, of course this test will pass, but the other will fail:</p>

<pre><code>/path/to/project/src/TestingFramework.js:4
            throw new Error(message || "Expected to be true, but got false");
            ^

Error: Expected to equal 1, but got: 2
</code></pre>

<p>This is great for couple of reasons:</p>

<ul>
<li>It validates, that our change to how <code>test*</code> functions are discovered is correct, and</li>
<li>We have to have a bit smarter implementation to pass both tests now:</li>
</ul>


<pre><code class="javascript">function fizzBuzz(number) {
    return number.toString();
}
</code></pre>

<p>And if we run the tests, they pass. Now, that we are in Green state, we should start refactoring. Have you noticed the duplication already?</p>

<pre><code class="javascript">t.assertTrue("1" === fizzBuzz(1), "Expected to equal " + "1" + ", but got: " + fizzBuzz(1));

// and:

t.assertTrue("2" === fizzBuzz(2), "Expected to equal " + "2" + ", but got: " + fizzBuzz(2));
</code></pre>

<p>Extracting <code>"1"</code> and <code>"2"</code> as variable <code>expected</code>, and <code>fizzBuzz(1)</code> and <code>fizzBuzz(2)</code> as variable <code>actual</code>, makes these 2 lines identical:</p>

<pre><code class="javascript">this.testNormalNumberIsReturned = function () {
    var expected = "1";
    var actual = fizzBuzz(1);
    t.assertTrue(expected === actual, "Expected to equal " + expected + ", but got: " + actual);
};

this.testAnotherNormalNumberIsReturned = function() {
    var expected = "2";
    var actual = fizzBuzz(2);
    t.assertTrue(expected === actual, "Expected to equal " + expected + ", but got: " + actual);
};
</code></pre>

<p>Specifically, this is identical:</p>

<pre><code class="javascript">t.assertTrue(expected === actual, "Expected to equal " + expected + ", but got: " + actual);
</code></pre>

<p>This sounds like <code>t.assertEqual(expected, actual)</code> to me. So let&rsquo;s extract it:</p>

<pre><code class="javascript">// src/TestingFramework.js

var assertions = {
    assertTrue: function(condition, message) { ... },

    assertEqual: function(expected, actual) {
        this.assertTrue(
          expected === actual,
          "Expected to equal " + expected + ", but got: " + actual
        );
    }
}
</code></pre>

<p>Now, let&rsquo;s use it and inline our <code>expected</code> and <code>actual</code> variables:</p>

<pre><code class="javascript">this.testNormalNumberIsReturned = function () {
    t.assertEqual("1", fizzBuzz(1));
};

this.testAnotherNormalNumberIsReturned = function() {
    t.assertEqual("2", fizzBuzz(2));
};
</code></pre>

<p>This looks much more readable. If we run tests, they still pass. If we try to break our code by using some Mutation, the tests fail as expected. Great, our refactoring was a success!</p>

<p>Let&rsquo;s finish test-driving our <code>fizzBuzz</code> function.</p>

<h2>Test-Driving Fizz Buzz Kata</h2>

<p>First test for <code>Fizz</code> case:</p>

<pre><code class="javascript">// test:
this.testFizzIsReturned = function () {
    t.assertEqual("Fizz", fizzBuzz(3));
};

// Error: Expected to equal Fizz, but got: 3

// implementation:
function fizzBuzz(number) {
    if (number === 3) return "Fizz";
    return number.toString();
}
</code></pre>

<p>This is pretty stupid implementation, but it works for that one tests, so let&rsquo;s write the test, that will break this implementation and force us to write real <code>if</code> condition:</p>

<pre><code class="javascript">// test:
this.testFizzIsReturnedForDifferentNumber = function () {
    t.assertEqual("Fizz", fizzBuzz(6));
};

// Error: Expected to equal Fizz, but got: 6

// implementation:
function fizzBuzz(number) {
    if (number % 3 === 0) return "Fizz";
    return number.toString();
}
</code></pre>

<p>This technique is called Triangulation:</p>

<ul>
<li>the first test is to force us to write some <code>if</code> statement with a correct body,</li>
<li>second is to force us to make the condition right.</li>
<li>If we had an <code>else</code> clause, we would have had another test to make that part right.</li>
</ul>


<p>OK, that looks like a right implementation for <code>Fizz</code>, let&rsquo;s write the test for <code>Buzz</code> now:</p>

<pre><code class="javascript">// test:
this.testBuzzIsReturned = function () {
    t.assertEqual("Buzz", fizzBuzz(5));
};

// Error: Expected to equal Buzz, but got: 5

// stupid implementation:
function fizzBuzz(number) {
    if (number === 5) return "Buzz";
    if (number % 3 === 0) return "Fizz";
    return number.toString();
}

// Triangulation:
this.testBuzzIsReturnedForDifferentNumber = function () {
    t.assertEqual("Buzz", fizzBuzz(10));
};

// Error: Expected to equal Buzz, but got: 10

// correct implementation:
function fizzBuzz(number) {
    if (number % 5 === 0) return "Buzz";
    if (number % 3 === 0) return "Fizz";
    return number.toString();
}
</code></pre>

<p>And finally let&rsquo;s implement final requirement <code>FizzBuzz</code>:</p>

<pre><code class="javascript">// test:
this.testFizzBuzzIsReturned = function () {
    t.assertEqual("FizzBuzz", fizzBuzz(15));
};

// Error: Expected to equal FizzBuzz, but got: Buzz

// stupid implementation:
function fizzBuzz(number) {
    if (number === 15) return "FizzBuzz";
    if (number % 5 === 0) return "Buzz";
    if (number % 3 === 0) return "Fizz";
    return number.toString();
}

// Triangulation:
this.testFizzBuzzIsReturnedForDifferentNumber = function () {
    t.assertEqual("FizzBuzz", fizzBuzz(30));
};

// Error: Expected to equal FizzBuzz, but got: Buzz

// correct implementation:
function fizzBuzz(number) {
    if (number % 15 === 0) return "FizzBuzz";
    if (number % 5 === 0) return "Buzz";
    if (number % 3 === 0) return "Fizz";
    return number.toString();
}
</code></pre>

<p>I think we are done with the implementation. <code>FizzBuzzKata</code> has an extended set of requirements, but they are out of the scope of this article. These requirements force us to introduce Strategy pattern and stop using this unmaintainable chain of <code>if</code> statements.</p>

<p>Refactoring this code to Strategy pattern is left as an exercise for the reader.</p>

<h2>Bottom Line</h2>

<p>Congratulations! Using <code>FizzBuzzKata</code> we have test-driven bare-bones testing framework to the point, that we can do Test-Driven Development for a simple Kata. And all that without having any testing framework in place.</p>

<p>The code is available on Github: <a href="https://github.com/waterlink/BuildYourOwnTestingFrameworkPart1">https://github.com/waterlink/BuildYourOwnTestingFrameworkPart1</a></p>

<p>Now, with this minimal framework in place, it should be possible to unit-test the framework itself, so that we can support more use cases. This will be covered in next series of &ldquo;Build Your Own Testing Framework&rdquo;. Stay tuned!</p>

<h2>Thanks!</h2>

<p>Thank you for reading, my dear reader. If you liked it, please share this article on social networks and follow me on twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>

<p>If you have any questions or feedback for me, don&rsquo;t hesitate to reach me out on Twitter: <a href="https://twitter.com/waterlink000">@waterlink000</a>.</p>
]]></content>
  </entry>
  
</feed>
